var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "node_modules/negotiator/lib/charset.js"(exports, module2) {
    "use strict";
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match)
        return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/negotiator/lib/encoding.js"(exports, module2) {
    "use strict";
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match)
        return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "node_modules/negotiator/lib/language.js"(exports, module2) {
    "use strict";
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match)
        return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q")
            q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p)
        return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "node_modules/negotiator/lib/mediaType.js"(exports, module2) {
    "use strict";
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match)
        return null;
      var params = Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.substr(0, index);
        val = str.substr(index + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "node_modules/negotiator/index.js"(exports, module2) {
    "use strict";
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding();
    var preferredLanguages = require_language();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers["accept-encoding"], available);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/accepts/index.js
var require_accepts = __commonJS({
  "node_modules/accepts/index.js"(exports, module2) {
    "use strict";
    var Negotiator = require_negotiator();
    var mime = require_mime_types();
    module2.exports = Accepts;
    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }
      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types = types_;
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i];
        }
      }
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types[0];
      }
      var mimes = types.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      return first ? types[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i = 0; i < languages.length; i++) {
          languages[i] = arguments[i];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
  }
});

// node_modules/base64id/lib/base64id.js
var require_base64id = __commonJS({
  "node_modules/base64id/lib/base64id.js"(exports, module2) {
    var crypto = require("crypto");
    var Base64Id = function() {
    };
    Base64Id.prototype.getRandomBytes = function(bytes) {
      var BUFFER_SIZE = 4096;
      var self2 = this;
      bytes = bytes || 12;
      if (bytes > BUFFER_SIZE) {
        return crypto.randomBytes(bytes);
      }
      var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
      var threshold = parseInt(bytesInBuffer * 0.85);
      if (!threshold) {
        return crypto.randomBytes(bytes);
      }
      if (this.bytesBufferIndex == null) {
        this.bytesBufferIndex = -1;
      }
      if (this.bytesBufferIndex == bytesInBuffer) {
        this.bytesBuffer = null;
        this.bytesBufferIndex = -1;
      }
      if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
        if (!this.isGeneratingBytes) {
          this.isGeneratingBytes = true;
          crypto.randomBytes(BUFFER_SIZE, function(err, bytes2) {
            self2.bytesBuffer = bytes2;
            self2.bytesBufferIndex = 0;
            self2.isGeneratingBytes = false;
          });
        }
        if (this.bytesBufferIndex == -1) {
          return crypto.randomBytes(bytes);
        }
      }
      var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
      this.bytesBufferIndex++;
      return result;
    };
    Base64Id.prototype.generateId = function() {
      var rand = Buffer.alloc(15);
      if (!rand.writeInt32BE) {
        return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
      }
      this.sequenceNumber = this.sequenceNumber + 1 | 0;
      rand.writeInt32BE(this.sequenceNumber, 11);
      if (crypto.randomBytes) {
        this.getRandomBytes(12).copy(rand);
      } else {
        [0, 4, 8].forEach(function(i) {
          rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
        });
      }
      return rand.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
    };
    exports = module2.exports = new Base64Id();
  }
});

// node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS({
  "node_modules/engine.io-parser/build/cjs/commons.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
    var PACKET_TYPES = Object.create(null);
    exports.PACKET_TYPES = PACKET_TYPES;
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    var PACKET_TYPES_REVERSE = Object.create(null);
    exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    var ERROR_PACKET = { type: "error", data: "parser error" };
    exports.ERROR_PACKET = ERROR_PACKET;
  }
});

// node_modules/engine.io-parser/build/cjs/encodePacket.js
var require_encodePacket = __commonJS({
  "node_modules/engine.io-parser/build/cjs/encodePacket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        const buffer = toBuffer(data);
        return callback(encodeBuffer(buffer, supportsBinary));
      }
      return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
    };
    var toBuffer = (data) => {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
      } else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      }
    };
    var encodeBuffer = (data, supportsBinary) => {
      return supportsBinary ? data : "b" + data.toString("base64");
    };
    exports.default = encodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/decodePacket.js
var require_decodePacket = __commonJS({
  "node_modules/engine.io-parser/build/cjs/decodePacket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        const buffer = Buffer.from(encodedPacket.substring(1), "base64");
        return {
          type: "message",
          data: mapBinary(buffer, binaryType)
        };
      }
      if (!commons_js_1.PACKET_TYPES_REVERSE[type]) {
        return commons_js_1.ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: commons_js_1.PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      } : {
        type: commons_js_1.PACKET_TYPES_REVERSE[type]
      };
    };
    var mapBinary = (data, binaryType) => {
      const isBuffer = Buffer.isBuffer(data);
      switch (binaryType) {
        case "arraybuffer":
          return isBuffer ? toArrayBuffer(data) : data;
        case "nodebuffer":
        default:
          return data;
      }
    };
    var toArrayBuffer = (buffer) => {
      const arrayBuffer = new ArrayBuffer(buffer.length);
      const view = new Uint8Array(arrayBuffer);
      for (let i = 0; i < buffer.length; i++) {
        view[i] = buffer[i];
      }
      return arrayBuffer;
    };
    exports.default = decodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/engine.io-parser/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
    var encodePacket_js_1 = require_encodePacket();
    exports.encodePacket = encodePacket_js_1.default;
    var decodePacket_js_1 = require_decodePacket();
    exports.decodePacket = decodePacket_js_1.default;
    var SEPARATOR = String.fromCharCode(30);
    var encodePayload = (packets, callback) => {
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
        (0, encodePacket_js_1.default)(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports.encodePayload = encodePayload;
    var decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports.decodePayload = decodePayload;
    exports.protocol = 4;
  }
});

// node_modules/engine.io/build/parser-v3/utf8.js
var require_utf8 = __commonJS({
  "node_modules/engine.io/build/parser-v3/utf8.js"(exports, module2) {
    var stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      var value;
      var extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      var length = array.length;
      var index = -1;
      var value;
      var output = "";
      while (++index < length) {
        value = array[index];
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
      }
      return output;
    }
    function checkScalarValue(codePoint, strict) {
      if (codePoint >= 55296 && codePoint <= 57343) {
        if (strict) {
          throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
        }
        return false;
      }
      return true;
    }
    function createByte(codePoint, shift) {
      return stringFromCharCode(codePoint >> shift & 63 | 128);
    }
    function encodeCodePoint(codePoint, strict) {
      if ((codePoint & 4294967168) == 0) {
        return stringFromCharCode(codePoint);
      }
      var symbol = "";
      if ((codePoint & 4294965248) == 0) {
        symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
      } else if ((codePoint & 4294901760) == 0) {
        if (!checkScalarValue(codePoint, strict)) {
          codePoint = 65533;
        }
        symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
        symbol += createByte(codePoint, 6);
      } else if ((codePoint & 4292870144) == 0) {
        symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
      }
      symbol += stringFromCharCode(codePoint & 63 | 128);
      return symbol;
    }
    function utf8encode(string, opts) {
      opts = opts || {};
      var strict = opts.strict !== false;
      var codePoints = ucs2decode(string);
      var length = codePoints.length;
      var index = -1;
      var codePoint;
      var byteString = "";
      while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint, strict);
      }
      return byteString;
    }
    function readContinuationByte() {
      if (byteIndex >= byteCount) {
        throw Error("Invalid byte index");
      }
      var continuationByte = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((continuationByte & 192) == 128) {
        return continuationByte & 63;
      }
      throw Error("Invalid continuation byte");
    }
    function decodeSymbol(strict) {
      var byte1;
      var byte2;
      var byte3;
      var byte4;
      var codePoint;
      if (byteIndex > byteCount) {
        throw Error("Invalid byte index");
      }
      if (byteIndex == byteCount) {
        return false;
      }
      byte1 = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((byte1 & 128) == 0) {
        return byte1;
      }
      if ((byte1 & 224) == 192) {
        byte2 = readContinuationByte();
        codePoint = (byte1 & 31) << 6 | byte2;
        if (codePoint >= 128) {
          return codePoint;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 240) == 224) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
        if (codePoint >= 2048) {
          return checkScalarValue(codePoint, strict) ? codePoint : 65533;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 248) == 240) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (codePoint >= 65536 && codePoint <= 1114111) {
          return codePoint;
        }
      }
      throw Error("Invalid UTF-8 detected");
    }
    var byteArray;
    var byteCount;
    var byteIndex;
    function utf8decode(byteString, opts) {
      opts = opts || {};
      var strict = opts.strict !== false;
      byteArray = ucs2decode(byteString);
      byteCount = byteArray.length;
      byteIndex = 0;
      var codePoints = [];
      var tmp;
      while ((tmp = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp);
      }
      return ucs2encode(codePoints);
    }
    module2.exports = {
      version: "2.1.2",
      encode: utf8encode,
      decode: utf8decode
    };
  }
});

// node_modules/engine.io/build/parser-v3/index.js
var require_parser_v3 = __commonJS({
  "node_modules/engine.io/build/parser-v3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;
    var utf8 = require_utf8();
    exports.protocol = 3;
    var hasBinary = (packets) => {
      for (const packet of packets) {
        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
          return true;
        }
      }
      return false;
    };
    exports.packets = {
      open: 0,
      close: 1,
      ping: 2,
      pong: 3,
      message: 4,
      upgrade: 5,
      noop: 6
    };
    var packetslist = Object.keys(exports.packets);
    var err = { type: "error", data: "parser error" };
    var EMPTY_BUFFER = Buffer.concat([]);
    function encodePacket(packet, supportsBinary, utf8encode, callback) {
      if (typeof supportsBinary === "function") {
        callback = supportsBinary;
        supportsBinary = null;
      }
      if (typeof utf8encode === "function") {
        callback = utf8encode;
        utf8encode = null;
      }
      if (Buffer.isBuffer(packet.data)) {
        return encodeBuffer(packet, supportsBinary, callback);
      } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
      }
      var encoded = exports.packets[packet.type];
      if (packet.data !== void 0) {
        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
      }
      return callback("" + encoded);
    }
    exports.encodePacket = encodePacket;
    function encodeBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return encodeBase64Packet(packet, callback);
      }
      var data = packet.data;
      var typeBuffer = Buffer.allocUnsafe(1);
      typeBuffer[0] = exports.packets[packet.type];
      return callback(Buffer.concat([typeBuffer, data]));
    }
    function encodeBase64Packet(packet, callback) {
      var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
      var message = "b" + exports.packets[packet.type];
      message += data.toString("base64");
      return callback(message);
    }
    exports.encodeBase64Packet = encodeBase64Packet;
    function decodePacket(data, binaryType, utf8decode) {
      if (data === void 0) {
        return err;
      }
      var type;
      if (typeof data === "string") {
        type = data.charAt(0);
        if (type === "b") {
          return decodeBase64Packet(data.slice(1), binaryType);
        }
        if (utf8decode) {
          data = tryDecode(data);
          if (data === false) {
            return err;
          }
        }
        if (Number(type) != type || !packetslist[type]) {
          return err;
        }
        if (data.length > 1) {
          return { type: packetslist[type], data: data.slice(1) };
        } else {
          return { type: packetslist[type] };
        }
      }
      if (binaryType === "arraybuffer") {
        var intArray = new Uint8Array(data);
        type = intArray[0];
        return { type: packetslist[type], data: intArray.buffer.slice(1) };
      }
      if (data instanceof ArrayBuffer) {
        data = arrayBufferToBuffer(data);
      }
      type = data[0];
      return { type: packetslist[type], data: data.slice(1) };
    }
    exports.decodePacket = decodePacket;
    function tryDecode(data) {
      try {
        data = utf8.decode(data, { strict: false });
      } catch (e) {
        return false;
      }
      return data;
    }
    function decodeBase64Packet(msg, binaryType) {
      var type = packetslist[msg.charAt(0)];
      var data = Buffer.from(msg.slice(1), "base64");
      if (binaryType === "arraybuffer") {
        var abv = new Uint8Array(data.length);
        for (var i = 0; i < abv.length; i++) {
          abv[i] = data[i];
        }
        data = abv.buffer;
      }
      return { type, data };
    }
    exports.decodeBase64Packet = decodeBase64Packet;
    function encodePayload(packets, supportsBinary, callback) {
      if (typeof supportsBinary === "function") {
        callback = supportsBinary;
        supportsBinary = null;
      }
      if (supportsBinary && hasBinary(packets)) {
        return encodePayloadAsBinary(packets, callback);
      }
      if (!packets.length) {
        return callback("0:");
      }
      function encodeOne(packet, doneCallback) {
        encodePacket(packet, supportsBinary, false, function(message) {
          doneCallback(null, setLengthHeader(message));
        });
      }
      map(packets, encodeOne, function(err2, results) {
        return callback(results.join(""));
      });
    }
    exports.encodePayload = encodePayload;
    function setLengthHeader(message) {
      return message.length + ":" + message;
    }
    function map(ary, each, done) {
      const results = new Array(ary.length);
      let count = 0;
      for (let i = 0; i < ary.length; i++) {
        each(ary[i], (error, msg) => {
          results[i] = msg;
          if (++count === ary.length) {
            done(null, results);
          }
        });
      }
    }
    function decodePayload(data, binaryType, callback) {
      if (typeof data !== "string") {
        return decodePayloadAsBinary(data, binaryType, callback);
      }
      if (typeof binaryType === "function") {
        callback = binaryType;
        binaryType = null;
      }
      if (data === "") {
        return callback(err, 0, 1);
      }
      var length = "", n, msg, packet;
      for (var i = 0, l = data.length; i < l; i++) {
        var chr = data.charAt(i);
        if (chr !== ":") {
          length += chr;
          continue;
        }
        if (length === "" || length != (n = Number(length))) {
          return callback(err, 0, 1);
        }
        msg = data.slice(i + 1, i + 1 + n);
        if (length != msg.length) {
          return callback(err, 0, 1);
        }
        if (msg.length) {
          packet = decodePacket(msg, binaryType, false);
          if (err.type === packet.type && err.data === packet.data) {
            return callback(err, 0, 1);
          }
          var more = callback(packet, i + n, l);
          if (more === false)
            return;
        }
        i += n;
        length = "";
      }
      if (length !== "") {
        return callback(err, 0, 1);
      }
    }
    exports.decodePayload = decodePayload;
    function bufferToString(buffer) {
      var str = "";
      for (var i = 0, l = buffer.length; i < l; i++) {
        str += String.fromCharCode(buffer[i]);
      }
      return str;
    }
    function stringToBuffer(string) {
      var buf = Buffer.allocUnsafe(string.length);
      for (var i = 0, l = string.length; i < l; i++) {
        buf.writeUInt8(string.charCodeAt(i), i);
      }
      return buf;
    }
    function arrayBufferToBuffer(data) {
      var length = data.byteLength || data.length;
      var offset = data.byteOffset || 0;
      return Buffer.from(data.buffer || data, offset, length);
    }
    function encodePayloadAsBinary(packets, callback) {
      if (!packets.length) {
        return callback(EMPTY_BUFFER);
      }
      map(packets, encodeOneBinaryPacket, function(err2, results) {
        return callback(Buffer.concat(results));
      });
    }
    exports.encodePayloadAsBinary = encodePayloadAsBinary;
    function encodeOneBinaryPacket(p, doneCallback) {
      function onBinaryPacketEncode(packet) {
        var encodingLength = "" + packet.length;
        var sizeBuffer;
        if (typeof packet === "string") {
          sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
          sizeBuffer[0] = 0;
          for (var i = 0; i < encodingLength.length; i++) {
            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
          }
          sizeBuffer[sizeBuffer.length - 1] = 255;
          return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
        }
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 1;
        for (var i = 0; i < encodingLength.length; i++) {
          sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        doneCallback(null, Buffer.concat([sizeBuffer, packet]));
      }
      encodePacket(p, true, true, onBinaryPacketEncode);
    }
    function decodePayloadAsBinary(data, binaryType, callback) {
      if (typeof binaryType === "function") {
        callback = binaryType;
        binaryType = null;
      }
      var bufferTail = data;
      var buffers = [];
      var i;
      while (bufferTail.length > 0) {
        var strLen = "";
        var isString = bufferTail[0] === 0;
        for (i = 1; ; i++) {
          if (bufferTail[i] === 255)
            break;
          if (strLen.length > 310) {
            return callback(err, 0, 1);
          }
          strLen += "" + bufferTail[i];
        }
        bufferTail = bufferTail.slice(strLen.length + 1);
        var msgLength = parseInt(strLen, 10);
        var msg = bufferTail.slice(1, msgLength + 1);
        if (isString)
          msg = bufferToString(msg);
        buffers.push(msg);
        bufferTail = bufferTail.slice(msgLength + 1);
      }
      var total = buffers.length;
      for (i = 0; i < total; i++) {
        var buffer = buffers[i];
        callback(decodePacket(buffer, binaryType, true), i, total);
      }
    }
    exports.decodePayloadAsBinary = decodePayloadAsBinary;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var support = (level) => {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    };
    var supportLevel = (() => {
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        return 1;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return 0;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return 0;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return 0;
      }
      return 0;
    })();
    if ("FORCE_COLOR" in env) {
      supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : supportLevel || 1;
    }
    module2.exports = process && support(supportLevel);
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/engine.io/build/transport.js
var require_transport = __commonJS({
  "node_modules/engine.io/build/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transport = void 0;
    var events_1 = require("events");
    var parser_v4 = require_cjs();
    var parser_v3 = require_parser_v3();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("engine:transport");
    function noop() {
    }
    var Transport = class extends events_1.EventEmitter {
      constructor(req) {
        super();
        this.readyState = "open";
        this.discarded = false;
        this.protocol = req._query.EIO === "4" ? 4 : 3;
        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
      }
      get readyState() {
        return this._readyState;
      }
      set readyState(state) {
        debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
        this._readyState = state;
      }
      discard() {
        this.discarded = true;
      }
      onRequest(req) {
        debug("setting request");
        this.req = req;
      }
      close(fn) {
        if (this.readyState === "closed" || this.readyState === "closing")
          return;
        this.readyState = "closing";
        this.doClose(fn || noop);
      }
      onError(msg, desc) {
        if (this.listeners("error").length) {
          const err = new Error(msg);
          err.type = "TransportError";
          err.description = desc;
          this.emit("error", err);
        } else {
          debug("ignored transport error %s (%s)", msg, desc);
        }
      }
      onPacket(packet) {
        this.emit("packet", packet);
      }
      onData(data) {
        this.onPacket(this.parser.decodePacket(data));
      }
      onClose() {
        this.readyState = "closed";
        this.emit("close");
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/engine.io/build/transports/polling.js
var require_polling = __commonJS({
  "node_modules/engine.io/build/transports/polling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Polling = void 0;
    var transport_1 = require_transport();
    var zlib_1 = require("zlib");
    var accepts = require_accepts();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("engine:polling");
    var compressionMethods = {
      gzip: zlib_1.createGzip,
      deflate: zlib_1.createDeflate
    };
    var Polling = class extends transport_1.Transport {
      constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1e3;
      }
      get name() {
        return "polling";
      }
      get supportsFraming() {
        return false;
      }
      onRequest(req) {
        const res = req.res;
        if (req.method === "GET") {
          this.onPollRequest(req, res);
        } else if (req.method === "POST") {
          this.onDataRequest(req, res);
        } else {
          res.writeHead(500);
          res.end();
        }
      }
      onPollRequest(req, res) {
        if (this.req) {
          debug("request overlap");
          this.onError("overlap from client");
          res.writeHead(500);
          res.end();
          return;
        }
        debug("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
          this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
          req.removeListener("close", onClose);
          this.req = this.res = null;
        };
        req.cleanup = cleanup;
        req.on("close", onClose);
        this.writable = true;
        this.emit("drain");
        if (this.writable && this.shouldClose) {
          debug("triggering empty send to append close packet");
          this.send([{ type: "noop" }]);
        }
      }
      onDataRequest(req, res) {
        if (this.dataReq) {
          this.onError("data request overlap from client");
          res.writeHead(500);
          res.end();
          return;
        }
        const isBinary = req.headers["content-type"] === "application/octet-stream";
        if (isBinary && this.protocol === 4) {
          return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let chunks = isBinary ? Buffer.concat([]) : "";
        const cleanup = () => {
          req.removeListener("data", onData);
          req.removeListener("end", onEnd);
          req.removeListener("close", onClose);
          this.dataReq = this.dataRes = chunks = null;
        };
        const onClose = () => {
          cleanup();
          this.onError("data request connection closed prematurely");
        };
        const onData = (data) => {
          let contentLength;
          if (isBinary) {
            chunks = Buffer.concat([chunks, data]);
            contentLength = chunks.length;
          } else {
            chunks += data;
            contentLength = Buffer.byteLength(chunks);
          }
          if (contentLength > this.maxHttpBufferSize) {
            res.writeHead(413).end();
            cleanup();
          }
        };
        const onEnd = () => {
          this.onData(chunks);
          const headers = {
            "Content-Type": "text/html",
            "Content-Length": 2
          };
          res.writeHead(200, this.headers(req, headers));
          res.end("ok");
          cleanup();
        };
        req.on("close", onClose);
        if (!isBinary)
          req.setEncoding("utf8");
        req.on("data", onData);
        req.on("end", onEnd);
      }
      onData(data) {
        debug('received "%s"', data);
        const callback = (packet) => {
          if (packet.type === "close") {
            debug("got xhr close packet");
            this.onClose();
            return false;
          }
          this.onPacket(packet);
        };
        if (this.protocol === 3) {
          this.parser.decodePayload(data, callback);
        } else {
          this.parser.decodePayload(data).forEach(callback);
        }
      }
      onClose() {
        if (this.writable) {
          this.send([{ type: "noop" }]);
        }
        super.onClose();
      }
      send(packets) {
        this.writable = false;
        if (this.shouldClose) {
          debug("appending close packet to payload");
          packets.push({ type: "close" });
          this.shouldClose();
          this.shouldClose = null;
        }
        const doWrite = (data) => {
          const compress = packets.some((packet) => {
            return packet.options && packet.options.compress;
          });
          this.write(data, { compress });
        };
        if (this.protocol === 3) {
          this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        } else {
          this.parser.encodePayload(packets, doWrite);
        }
      }
      write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
          this.req.cleanup();
        });
      }
      doWrite(data, options, callback) {
        const isString = typeof data === "string";
        const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
        const headers = {
          "Content-Type": contentType
        };
        const respond = (data2) => {
          headers["Content-Length"] = typeof data2 === "string" ? Buffer.byteLength(data2) : data2.length;
          this.res.writeHead(200, this.headers(this.req, headers));
          this.res.end(data2);
          callback();
        };
        if (!this.httpCompression || !options.compress) {
          respond(data);
          return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
          respond(data);
          return;
        }
        const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
          respond(data);
          return;
        }
        this.compress(data, encoding, (err, data2) => {
          if (err) {
            this.res.writeHead(500);
            this.res.end();
            callback(err);
            return;
          }
          headers["Content-Encoding"] = encoding;
          respond(data2);
        });
      }
      compress(data, encoding, callback) {
        debug("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
          buffers.push(chunk);
          nread += chunk.length;
        }).on("end", function() {
          callback(null, Buffer.concat(buffers, nread));
        }).end(data);
      }
      doClose(fn) {
        debug("closing");
        let closeTimeoutTimer;
        if (this.dataReq) {
          debug("aborting ongoing data request");
          this.dataReq.destroy();
        }
        const onClose = () => {
          clearTimeout(closeTimeoutTimer);
          fn();
          this.onClose();
        };
        if (this.writable) {
          debug("transport writable - closing right away");
          this.send([{ type: "close" }]);
          onClose();
        } else if (this.discarded) {
          debug("transport discarded - closing right away");
          onClose();
        } else {
          debug("transport not writable - buffering orderly close");
          this.shouldClose = onClose;
          closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
      }
      headers(req, headers) {
        headers = headers || {};
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
          headers["X-XSS-Protection"] = "0";
        }
        this.emit("headers", headers, req);
        return headers;
      }
    };
    exports.Polling = Polling;
  }
});

// node_modules/engine.io/build/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS({
  "node_modules/engine.io/build/transports/polling-jsonp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONP = void 0;
    var polling_1 = require_polling();
    var qs = require("querystring");
    var rDoubleSlashes = /\\\\n/g;
    var rSlashes = /(\\)?\\n/g;
    var JSONP = class extends polling_1.Polling {
      constructor(req) {
        super(req);
        this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
        this.foot = ");";
      }
      onData(data) {
        data = qs.parse(data).d;
        if (typeof data === "string") {
          data = data.replace(rSlashes, function(match, slashes) {
            return slashes ? match : "\n";
          });
          super.onData(data.replace(rDoubleSlashes, "\\n"));
        }
      }
      doWrite(data, options, callback) {
        const js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        data = this.head + js + this.foot;
        super.doWrite(data, options, callback);
      }
    };
    exports.JSONP = JSONP;
  }
});

// node_modules/engine.io/build/transports/websocket.js
var require_websocket = __commonJS({
  "node_modules/engine.io/build/transports/websocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocket = void 0;
    var transport_1 = require_transport();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("engine:ws");
    var WebSocket2 = class extends transport_1.Transport {
      constructor(req) {
        super(req);
        this.socket = req.websocket;
        this.socket.on("message", (data, isBinary) => {
          const message = isBinary ? data : data.toString();
          debug('received "%s"', message);
          super.onData(message);
        });
        this.socket.once("close", this.onClose.bind(this));
        this.socket.on("error", this.onError.bind(this));
        this.writable = true;
        this.perMessageDeflate = null;
      }
      get name() {
        return "websocket";
      }
      get handlesUpgrades() {
        return true;
      }
      get supportsFraming() {
        return true;
      }
      send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const isLast = i + 1 === packets.length;
          const opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          const onSent = (err) => {
            if (err) {
              return this.onError("write error", err.stack);
            } else if (isLast) {
              this.writable = true;
              this.emit("drain");
            }
          };
          const send = (data) => {
            if (this.perMessageDeflate) {
              const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
              if (len < this.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
            debug('writing "%s"', data);
            this.socket.send(data, opts, onSent);
          };
          if (packet.options && typeof packet.options.wsPreEncoded === "string") {
            send(packet.options.wsPreEncoded);
          } else if (this._canSendPreEncodedFrame(packet)) {
            this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);
          } else {
            this.parser.encodePacket(packet, this.supportsBinary, send);
          }
        }
      }
      _canSendPreEncodedFrame(packet) {
        var _a, _b, _c;
        return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === "function" && ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== void 0;
      }
      doClose(fn) {
        debug("closing");
        this.socket.close();
        fn && fn();
      }
    };
    exports.WebSocket = WebSocket2;
  }
});

// node_modules/engine.io/build/transports/index.js
var require_transports = __commonJS({
  "node_modules/engine.io/build/transports/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var polling_1 = require_polling();
    var polling_jsonp_1 = require_polling_jsonp();
    var websocket_1 = require_websocket();
    exports.default = {
      polling,
      websocket: websocket_1.WebSocket
    };
    function polling(req) {
      if (typeof req._query.j === "string") {
        return new polling_jsonp_1.JSONP(req);
      } else {
        return new polling_1.Polling(req);
      }
    }
    polling.upgradesTo = ["websocket"];
  }
});

// node_modules/engine.io/build/socket.js
var require_socket = __commonJS({
  "node_modules/engine.io/build/socket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Socket = void 0;
    var events_1 = require("events");
    var debug_1 = require_src();
    var timers_1 = require("timers");
    var debug = (0, debug_1.default)("engine:socket");
    var Socket2 = class extends events_1.EventEmitter {
      constructor(id, server, transport, req, protocol) {
        super();
        this.id = id;
        this.server = server;
        this.upgrading = false;
        this.upgraded = false;
        this.readyState = "opening";
        this.writeBuffer = [];
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.cleanupFn = [];
        this.request = req;
        this.protocol = protocol;
        if (req.websocket && req.websocket._socket) {
          this.remoteAddress = req.websocket._socket.remoteAddress;
        } else {
          this.remoteAddress = req.connection.remoteAddress;
        }
        this.checkIntervalTimer = null;
        this.upgradeTimeoutTimer = null;
        this.pingTimeoutTimer = null;
        this.pingIntervalTimer = null;
        this.setTransport(transport);
        this.onOpen();
      }
      get readyState() {
        return this._readyState;
      }
      set readyState(state) {
        debug("readyState updated from %s to %s", this._readyState, state);
        this._readyState = state;
      }
      onOpen() {
        this.readyState = "open";
        this.transport.sid = this.id;
        this.sendPacket("open", JSON.stringify({
          sid: this.id,
          upgrades: this.getAvailableUpgrades(),
          pingInterval: this.server.opts.pingInterval,
          pingTimeout: this.server.opts.pingTimeout,
          maxPayload: this.server.opts.maxHttpBufferSize
        }));
        if (this.server.opts.initialPacket) {
          this.sendPacket("message", this.server.opts.initialPacket);
        }
        this.emit("open");
        if (this.protocol === 3) {
          this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
        } else {
          this.schedulePing();
        }
      }
      onPacket(packet) {
        if (this.readyState !== "open") {
          return debug("packet received with closed socket");
        }
        debug(`received packet ${packet.type}`);
        this.emit("packet", packet);
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
        switch (packet.type) {
          case "ping":
            if (this.transport.protocol !== 3) {
              this.onError("invalid heartbeat direction");
              return;
            }
            debug("got ping");
            this.sendPacket("pong");
            this.emit("heartbeat");
            break;
          case "pong":
            if (this.transport.protocol === 3) {
              this.onError("invalid heartbeat direction");
              return;
            }
            debug("got pong");
            this.pingIntervalTimer.refresh();
            this.emit("heartbeat");
            break;
          case "error":
            this.onClose("parse error");
            break;
          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      }
      onError(err) {
        debug("transport error");
        this.onClose("transport error", err);
      }
      schedulePing() {
        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
          debug("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
          this.sendPacket("ping");
          this.resetPingTimeout(this.server.opts.pingTimeout);
        }, this.server.opts.pingInterval);
      }
      resetPingTimeout(timeout) {
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
          if (this.readyState === "closed")
            return;
          this.onClose("ping timeout");
        }, timeout);
      }
      setTransport(transport) {
        const onError = this.onError.bind(this);
        const onPacket = this.onPacket.bind(this);
        const flush = this.flush.bind(this);
        const onClose = this.onClose.bind(this, "transport close");
        this.transport = transport;
        this.transport.once("error", onError);
        this.transport.on("packet", onPacket);
        this.transport.on("drain", flush);
        this.transport.once("close", onClose);
        this.setupSendCallback();
        this.cleanupFn.push(function() {
          transport.removeListener("error", onError);
          transport.removeListener("packet", onPacket);
          transport.removeListener("drain", flush);
          transport.removeListener("close", onClose);
        });
      }
      maybeUpgrade(transport) {
        debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
        this.upgrading = true;
        this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
          debug("client did not complete upgrade - closing transport");
          cleanup();
          if (transport.readyState === "open") {
            transport.close();
          }
        }, this.server.opts.upgradeTimeout);
        const onPacket = (packet) => {
          if (packet.type === "ping" && packet.data === "probe") {
            debug("got probe ping packet, sending pong");
            transport.send([{ type: "pong", data: "probe" }]);
            this.emit("upgrading", transport);
            clearInterval(this.checkIntervalTimer);
            this.checkIntervalTimer = setInterval(check, 100);
          } else if (packet.type === "upgrade" && this.readyState !== "closed") {
            debug("got upgrade packet - upgrading");
            cleanup();
            this.transport.discard();
            this.upgraded = true;
            this.clearTransport();
            this.setTransport(transport);
            this.emit("upgrade", transport);
            this.flush();
            if (this.readyState === "closing") {
              transport.close(() => {
                this.onClose("forced close");
              });
            }
          } else {
            cleanup();
            transport.close();
          }
        };
        const check = () => {
          if (this.transport.name === "polling" && this.transport.writable) {
            debug("writing a noop packet to polling for fast upgrade");
            this.transport.send([{ type: "noop" }]);
          }
        };
        const cleanup = () => {
          this.upgrading = false;
          clearInterval(this.checkIntervalTimer);
          this.checkIntervalTimer = null;
          (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);
          this.upgradeTimeoutTimer = null;
          transport.removeListener("packet", onPacket);
          transport.removeListener("close", onTransportClose);
          transport.removeListener("error", onError);
          this.removeListener("close", onClose);
        };
        const onError = (err) => {
          debug("client did not complete upgrade - %s", err);
          cleanup();
          transport.close();
          transport = null;
        };
        const onTransportClose = () => {
          onError("transport closed");
        };
        const onClose = () => {
          onError("socket closed");
        };
        transport.on("packet", onPacket);
        transport.once("close", onTransportClose);
        transport.once("error", onError);
        this.once("close", onClose);
      }
      clearTransport() {
        let cleanup;
        const toCleanUp = this.cleanupFn.length;
        for (let i = 0; i < toCleanUp; i++) {
          cleanup = this.cleanupFn.shift();
          cleanup();
        }
        this.transport.on("error", function() {
          debug("error triggered by discarded transport");
        });
        this.transport.close();
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      }
      onClose(reason, description) {
        if (this.readyState !== "closed") {
          this.readyState = "closed";
          (0, timers_1.clearTimeout)(this.pingIntervalTimer);
          (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
          clearInterval(this.checkIntervalTimer);
          this.checkIntervalTimer = null;
          (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);
          process.nextTick(() => {
            this.writeBuffer = [];
          });
          this.packetsFn = [];
          this.sentCallbackFn = [];
          this.clearTransport();
          this.emit("close", reason, description);
        }
      }
      setupSendCallback() {
        const onDrain = () => {
          if (this.sentCallbackFn.length > 0) {
            const seqFn = this.sentCallbackFn.splice(0, 1)[0];
            if (typeof seqFn === "function") {
              debug("executing send callback");
              seqFn(this.transport);
            } else if (Array.isArray(seqFn)) {
              debug("executing batch send callback");
              const l = seqFn.length;
              let i = 0;
              for (; i < l; i++) {
                if (typeof seqFn[i] === "function") {
                  seqFn[i](this.transport);
                }
              }
            }
          }
        };
        this.transport.on("drain", onDrain);
        this.cleanupFn.push(() => {
          this.transport.removeListener("drain", onDrain);
        });
      }
      send(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
      }
      write(data, options, callback) {
        this.sendPacket("message", data, options, callback);
        return this;
      }
      sendPacket(type, data, options = {}, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (this.readyState !== "closing" && this.readyState !== "closed") {
          debug('sending packet "%s" (%s)', type, data);
          options.compress = options.compress !== false;
          const packet = {
            type,
            options
          };
          if (data)
            packet.data = data;
          this.emit("packetCreate", packet);
          this.writeBuffer.push(packet);
          if (callback)
            this.packetsFn.push(callback);
          this.flush();
        }
      }
      flush() {
        if (this.readyState !== "closed" && this.transport.writable && this.writeBuffer.length) {
          debug("flushing buffer to transport");
          this.emit("flush", this.writeBuffer);
          this.server.emit("flush", this, this.writeBuffer);
          const wbuf = this.writeBuffer;
          this.writeBuffer = [];
          if (!this.transport.supportsFraming) {
            this.sentCallbackFn.push(this.packetsFn);
          } else {
            this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
          }
          this.packetsFn = [];
          this.transport.send(wbuf);
          this.emit("drain");
          this.server.emit("drain", this);
        }
      }
      getAvailableUpgrades() {
        const availableUpgrades = [];
        const allUpgrades = this.server.upgrades(this.transport.name);
        let i = 0;
        const l = allUpgrades.length;
        for (; i < l; ++i) {
          const upg = allUpgrades[i];
          if (this.server.opts.transports.indexOf(upg) !== -1) {
            availableUpgrades.push(upg);
          }
        }
        return availableUpgrades;
      }
      close(discard) {
        if (this.readyState !== "open")
          return;
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
          this.once("drain", () => {
            debug("all packets have been sent, closing the transport");
            this.closeTransport(discard);
          });
          return;
        }
        debug("the buffer is empty, closing the transport right away", discard);
        this.closeTransport(discard);
      }
      closeTransport(discard) {
        debug("closing the transport (discard? %s)", discard);
        if (discard)
          this.transport.discard();
        this.transport.close(this.onClose.bind(this, "forced close"));
      }
    };
    exports.Socket = Socket2;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var index = pair.indexOf("=");
        if (index < 0) {
          continue;
        }
        var key = pair.substring(0, index).trim();
        if (obj[key] == void 0) {
          var val = pair.substring(index + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/engine.io/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/engine.io/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(data, {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1: false
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/engine.io/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/engine.io/node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var https = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter10 {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http2.request;
      const protocolSet = new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      req.end();
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/engine.io/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/engine.io/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/engine.io/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var http2 = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket2();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter10 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/engine.io/node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/engine.io/node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket2 = require_websocket2();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS({
  "node_modules/vary/index.js"(exports, module2) {
    "use strict";
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// node_modules/cors/lib/index.js
var require_lib = __commonJS({
  "node_modules/cors/lib/index.js"(exports, module2) {
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module2.exports = middlewareWrapper;
    })();
  }
});

// node_modules/engine.io/build/server.js
var require_server = __commonJS({
  "node_modules/engine.io/build/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Server = exports.BaseServer = void 0;
    var qs = require("querystring");
    var url_1 = require("url");
    var base64id = require_base64id();
    var transports_1 = require_transports();
    var events_1 = require("events");
    var socket_1 = require_socket();
    var debug_1 = require_src();
    var cookie_1 = require_cookie();
    var ws_1 = require_ws();
    var debug = (0, debug_1.default)("engine");
    var kResponseHeaders = Symbol("responseHeaders");
    var BaseServer = class extends events_1.EventEmitter {
      constructor(opts = {}) {
        super();
        this.middlewares = [];
        this.clients = {};
        this.clientsCount = 0;
        this.opts = Object.assign({
          wsEngine: ws_1.Server,
          pingTimeout: 2e4,
          pingInterval: 25e3,
          upgradeTimeout: 1e4,
          maxHttpBufferSize: 1e6,
          transports: Object.keys(transports_1.default),
          allowUpgrades: true,
          httpCompression: {
            threshold: 1024
          },
          cors: false,
          allowEIO3: false
        }, opts);
        if (opts.cookie) {
          this.opts.cookie = Object.assign({
            name: "io",
            path: "/",
            httpOnly: opts.cookie.path !== false,
            sameSite: "lax"
          }, opts.cookie);
        }
        if (this.opts.cors) {
          this.use(require_lib()(this.opts.cors));
        }
        if (opts.perMessageDeflate) {
          this.opts.perMessageDeflate = Object.assign({
            threshold: 1024
          }, opts.perMessageDeflate);
        }
        this.init();
      }
      _computePath(options) {
        let path = (options.path || "/engine.io").replace(/\/$/, "");
        if (options.addTrailingSlash !== false) {
          path += "/";
        }
        return path;
      }
      upgrades(transport) {
        if (!this.opts.allowUpgrades)
          return [];
        return transports_1.default[transport].upgradesTo || [];
      }
      verify(req, upgrade, fn) {
        const transport = req._query.transport;
        if (!~this.opts.transports.indexOf(transport)) {
          debug('unknown transport "%s"', transport);
          return fn(Server2.errors.UNKNOWN_TRANSPORT, { transport });
        }
        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
        if (isOriginInvalid) {
          const origin = req.headers.origin;
          req.headers.origin = null;
          debug("origin header invalid");
          return fn(Server2.errors.BAD_REQUEST, {
            name: "INVALID_ORIGIN",
            origin
          });
        }
        const sid = req._query.sid;
        if (sid) {
          if (!this.clients.hasOwnProperty(sid)) {
            debug('unknown sid "%s"', sid);
            return fn(Server2.errors.UNKNOWN_SID, {
              sid
            });
          }
          const previousTransport = this.clients[sid].transport.name;
          if (!upgrade && previousTransport !== transport) {
            debug("bad request: unexpected transport without upgrade");
            return fn(Server2.errors.BAD_REQUEST, {
              name: "TRANSPORT_MISMATCH",
              transport,
              previousTransport
            });
          }
        } else {
          if (req.method !== "GET") {
            return fn(Server2.errors.BAD_HANDSHAKE_METHOD, {
              method: req.method
            });
          }
          if (transport === "websocket" && !upgrade) {
            debug("invalid transport upgrade");
            return fn(Server2.errors.BAD_REQUEST, {
              name: "TRANSPORT_HANDSHAKE_ERROR"
            });
          }
          if (!this.opts.allowRequest)
            return fn();
          return this.opts.allowRequest(req, (message, success) => {
            if (!success) {
              return fn(Server2.errors.FORBIDDEN, {
                message
              });
            }
            fn();
          });
        }
        fn();
      }
      use(fn) {
        this.middlewares.push(fn);
      }
      _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
          debug("no middleware to apply, skipping");
          return callback();
        }
        const apply = (i) => {
          debug("applying middleware n\xB0%d", i + 1);
          this.middlewares[i](req, res, () => {
            if (i + 1 < this.middlewares.length) {
              apply(i + 1);
            } else {
              callback();
            }
          });
        };
        apply(0);
      }
      close() {
        debug("closing all open clients");
        for (let i in this.clients) {
          if (this.clients.hasOwnProperty(i)) {
            this.clients[i].close(true);
          }
        }
        this.cleanup();
        return this;
      }
      generateId(req) {
        return base64id.generateId();
      }
      async handshake(transportName, req, closeConnection) {
        const protocol = req._query.EIO === "4" ? 4 : 3;
        if (protocol === 3 && !this.opts.allowEIO3) {
          debug("unsupported protocol version");
          this.emit("connection_error", {
            req,
            code: Server2.errors.UNSUPPORTED_PROTOCOL_VERSION,
            message: Server2.errorMessages[Server2.errors.UNSUPPORTED_PROTOCOL_VERSION],
            context: {
              protocol
            }
          });
          closeConnection(Server2.errors.UNSUPPORTED_PROTOCOL_VERSION);
          return;
        }
        let id;
        try {
          id = await this.generateId(req);
        } catch (e) {
          debug("error while generating an id");
          this.emit("connection_error", {
            req,
            code: Server2.errors.BAD_REQUEST,
            message: Server2.errorMessages[Server2.errors.BAD_REQUEST],
            context: {
              name: "ID_GENERATION_ERROR",
              error: e
            }
          });
          closeConnection(Server2.errors.BAD_REQUEST);
          return;
        }
        debug('handshaking client "%s"', id);
        try {
          var transport = this.createTransport(transportName, req);
          if (transportName === "polling") {
            transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
            transport.httpCompression = this.opts.httpCompression;
          } else if (transportName === "websocket") {
            transport.perMessageDeflate = this.opts.perMessageDeflate;
          }
          if (req._query && req._query.b64) {
            transport.supportsBinary = false;
          } else {
            transport.supportsBinary = true;
          }
        } catch (e) {
          debug('error handshaking to transport "%s"', transportName);
          this.emit("connection_error", {
            req,
            code: Server2.errors.BAD_REQUEST,
            message: Server2.errorMessages[Server2.errors.BAD_REQUEST],
            context: {
              name: "TRANSPORT_HANDSHAKE_ERROR",
              error: e
            }
          });
          closeConnection(Server2.errors.BAD_REQUEST);
          return;
        }
        const socket = new socket_1.Socket(id, this, transport, req, protocol);
        transport.on("headers", (headers, req2) => {
          const isInitialRequest = !req2._query.sid;
          if (isInitialRequest) {
            if (this.opts.cookie) {
              headers["Set-Cookie"] = [
                (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)
              ];
            }
            this.emit("initial_headers", headers, req2);
          }
          this.emit("headers", headers, req2);
        });
        transport.onRequest(req);
        this.clients[id] = socket;
        this.clientsCount++;
        socket.once("close", () => {
          delete this.clients[id];
          this.clientsCount--;
        });
        this.emit("connection", socket);
        return transport;
      }
    };
    exports.BaseServer = BaseServer;
    BaseServer.errors = {
      UNKNOWN_TRANSPORT: 0,
      UNKNOWN_SID: 1,
      BAD_HANDSHAKE_METHOD: 2,
      BAD_REQUEST: 3,
      FORBIDDEN: 4,
      UNSUPPORTED_PROTOCOL_VERSION: 5
    };
    BaseServer.errorMessages = {
      0: "Transport unknown",
      1: "Session ID unknown",
      2: "Bad handshake method",
      3: "Bad request",
      4: "Forbidden",
      5: "Unsupported protocol version"
    };
    var WebSocketResponse = class {
      constructor(req, socket) {
        this.req = req;
        this.socket = socket;
        req[kResponseHeaders] = {};
      }
      setHeader(name, value) {
        this.req[kResponseHeaders][name] = value;
      }
      getHeader(name) {
        return this.req[kResponseHeaders][name];
      }
      removeHeader(name) {
        delete this.req[kResponseHeaders][name];
      }
      write() {
      }
      writeHead() {
      }
      end() {
        this.socket.destroy();
      }
    };
    var Server2 = class extends BaseServer {
      init() {
        if (!~this.opts.transports.indexOf("websocket"))
          return;
        if (this.ws)
          this.ws.close();
        this.ws = new this.opts.wsEngine({
          noServer: true,
          clientTracking: false,
          perMessageDeflate: this.opts.perMessageDeflate,
          maxPayload: this.opts.maxHttpBufferSize
        });
        if (typeof this.ws.on === "function") {
          this.ws.on("headers", (headersArray, req) => {
            const additionalHeaders = req[kResponseHeaders] || {};
            delete req[kResponseHeaders];
            const isInitialRequest = !req._query.sid;
            if (isInitialRequest) {
              this.emit("initial_headers", additionalHeaders, req);
            }
            this.emit("headers", additionalHeaders, req);
            debug("writing headers: %j", additionalHeaders);
            Object.keys(additionalHeaders).forEach((key) => {
              headersArray.push(`${key}: ${additionalHeaders[key]}`);
            });
          });
        }
      }
      cleanup() {
        if (this.ws) {
          debug("closing webSocketServer");
          this.ws.close();
        }
      }
      prepare(req) {
        if (!req._query) {
          req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
        }
      }
      createTransport(transportName, req) {
        return new transports_1.default[transportName](req);
      }
      handleRequest(req, res) {
        debug('handling "%s" http request "%s"', req.method, req.url);
        this.prepare(req);
        req.res = res;
        const callback = (errorCode, errorContext) => {
          if (errorCode !== void 0) {
            this.emit("connection_error", {
              req,
              code: errorCode,
              message: Server2.errorMessages[errorCode],
              context: errorContext
            });
            abortRequest(res, errorCode, errorContext);
            return;
          }
          if (req._query.sid) {
            debug("setting new request for existing client");
            this.clients[req._query.sid].transport.onRequest(req);
          } else {
            const closeConnection = (errorCode2, errorContext2) => abortRequest(res, errorCode2, errorContext2);
            this.handshake(req._query.transport, req, closeConnection);
          }
        };
        this._applyMiddlewares(req, res, () => {
          this.verify(req, false, callback);
        });
      }
      handleUpgrade(req, socket, upgradeHead) {
        this.prepare(req);
        const res = new WebSocketResponse(req, socket);
        this._applyMiddlewares(req, res, () => {
          this.verify(req, true, (errorCode, errorContext) => {
            if (errorCode) {
              this.emit("connection_error", {
                req,
                code: errorCode,
                message: Server2.errorMessages[errorCode],
                context: errorContext
              });
              abortUpgrade(socket, errorCode, errorContext);
              return;
            }
            const head = Buffer.from(upgradeHead);
            upgradeHead = null;
            res.writeHead();
            this.ws.handleUpgrade(req, socket, head, (websocket) => {
              this.onWebSocket(req, socket, websocket);
            });
          });
        });
      }
      onWebSocket(req, socket, websocket) {
        websocket.on("error", onUpgradeError);
        if (transports_1.default[req._query.transport] !== void 0 && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
          debug("transport doesnt handle upgraded requests");
          websocket.close();
          return;
        }
        const id = req._query.sid;
        req.websocket = websocket;
        if (id) {
          const client = this.clients[id];
          if (!client) {
            debug("upgrade attempt for closed client");
            websocket.close();
          } else if (client.upgrading) {
            debug("transport has already been trying to upgrade");
            websocket.close();
          } else if (client.upgraded) {
            debug("transport had already been upgraded");
            websocket.close();
          } else {
            debug("upgrading existing transport");
            websocket.removeListener("error", onUpgradeError);
            const transport = this.createTransport(req._query.transport, req);
            if (req._query && req._query.b64) {
              transport.supportsBinary = false;
            } else {
              transport.supportsBinary = true;
            }
            transport.perMessageDeflate = this.opts.perMessageDeflate;
            client.maybeUpgrade(transport);
          }
        } else {
          const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);
          this.handshake(req._query.transport, req, closeConnection);
        }
        function onUpgradeError() {
          debug("websocket error before upgrade");
        }
      }
      attach(server, options = {}) {
        const path = this._computePath(options);
        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1e3;
        function check(req) {
          return path === req.url.slice(0, path.length);
        }
        const listeners = server.listeners("request").slice(0);
        server.removeAllListeners("request");
        server.on("close", this.close.bind(this));
        server.on("listening", this.init.bind(this));
        server.on("request", (req, res) => {
          if (check(req)) {
            debug('intercepting request for path "%s"', path);
            this.handleRequest(req, res);
          } else {
            let i = 0;
            const l = listeners.length;
            for (; i < l; i++) {
              listeners[i].call(server, req, res);
            }
          }
        });
        if (~this.opts.transports.indexOf("websocket")) {
          server.on("upgrade", (req, socket, head) => {
            if (check(req)) {
              this.handleUpgrade(req, socket, head);
            } else if (options.destroyUpgrade !== false) {
              setTimeout(function() {
                if (socket.writable && socket.bytesWritten <= 0) {
                  socket.on("error", (e) => {
                    debug("error while destroying upgrade: %s", e.message);
                  });
                  return socket.end();
                }
              }, destroyUpgradeTimeout);
            }
          });
        }
      }
    };
    exports.Server = Server2;
    function abortRequest(res, errorCode, errorContext) {
      const statusCode = errorCode === Server2.errors.FORBIDDEN ? 403 : 400;
      const message = errorContext && errorContext.message ? errorContext.message : Server2.errorMessages[errorCode];
      res.writeHead(statusCode, { "Content-Type": "application/json" });
      res.end(JSON.stringify({
        code: errorCode,
        message
      }));
    }
    function abortUpgrade(socket, errorCode, errorContext = {}) {
      socket.on("error", () => {
        debug("ignoring error from closed connection");
      });
      if (socket.writable) {
        const message = errorContext.message || Server2.errorMessages[errorCode];
        const length = Buffer.byteLength(message);
        socket.write("HTTP/1.1 400 Bad Request\r\nConnection: close\r\nContent-type: text/html\r\nContent-Length: " + length + "\r\n\r\n" + message);
      }
      socket.destroy();
    }
    var validHdrChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    function checkInvalidHeaderChar(val) {
      val += "";
      if (val.length < 1)
        return false;
      if (!validHdrChars[val.charCodeAt(0)]) {
        debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
        return true;
      }
      if (val.length < 2)
        return false;
      if (!validHdrChars[val.charCodeAt(1)]) {
        debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
        return true;
      }
      if (val.length < 3)
        return false;
      if (!validHdrChars[val.charCodeAt(2)]) {
        debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
        return true;
      }
      if (val.length < 4)
        return false;
      if (!validHdrChars[val.charCodeAt(3)]) {
        debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
        return true;
      }
      for (let i = 4; i < val.length; ++i) {
        if (!validHdrChars[val.charCodeAt(i)]) {
          debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/engine.io/build/transports-uws/polling.js
var require_polling2 = __commonJS({
  "node_modules/engine.io/build/transports-uws/polling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Polling = void 0;
    var transport_1 = require_transport();
    var zlib_1 = require("zlib");
    var accepts = require_accepts();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("engine:polling");
    var compressionMethods = {
      gzip: zlib_1.createGzip,
      deflate: zlib_1.createDeflate
    };
    var Polling = class extends transport_1.Transport {
      constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1e3;
      }
      get name() {
        return "polling";
      }
      get supportsFraming() {
        return false;
      }
      onRequest(req) {
        const res = req.res;
        if (req.getMethod() === "get") {
          this.onPollRequest(req, res);
        } else if (req.getMethod() === "post") {
          this.onDataRequest(req, res);
        } else {
          res.writeStatus("500 Internal Server Error");
          res.end();
        }
      }
      onPollRequest(req, res) {
        if (this.req) {
          debug("request overlap");
          this.onError("overlap from client");
          res.writeStatus("500 Internal Server Error");
          res.end();
          return;
        }
        debug("setting request");
        this.req = req;
        this.res = res;
        const onClose = () => {
          this.writable = false;
          this.onError("poll connection closed prematurely");
        };
        const cleanup = () => {
          this.req = this.res = null;
        };
        req.cleanup = cleanup;
        res.onAborted(onClose);
        this.writable = true;
        this.emit("drain");
        if (this.writable && this.shouldClose) {
          debug("triggering empty send to append close packet");
          this.send([{ type: "noop" }]);
        }
      }
      onDataRequest(req, res) {
        if (this.dataReq) {
          this.onError("data request overlap from client");
          res.writeStatus("500 Internal Server Error");
          res.end();
          return;
        }
        const expectedContentLength = Number(req.headers["content-length"]);
        if (!expectedContentLength) {
          this.onError("content-length header required");
          res.writeStatus("411 Length Required").end();
          return;
        }
        if (expectedContentLength > this.maxHttpBufferSize) {
          this.onError("payload too large");
          res.writeStatus("413 Payload Too Large").end();
          return;
        }
        const isBinary = req.headers["content-type"] === "application/octet-stream";
        if (isBinary && this.protocol === 4) {
          return this.onError("invalid content");
        }
        this.dataReq = req;
        this.dataRes = res;
        let buffer;
        let offset = 0;
        const headers = {
          "Content-Type": "text/html"
        };
        this.headers(req, headers);
        for (let key in headers) {
          res.writeHeader(key, String(headers[key]));
        }
        const onEnd = (buffer2) => {
          this.onData(buffer2.toString());
          this.onDataRequestCleanup();
          res.end("ok");
        };
        res.onAborted(() => {
          this.onDataRequestCleanup();
          this.onError("data request connection closed prematurely");
        });
        res.onData((arrayBuffer, isLast) => {
          const totalLength = offset + arrayBuffer.byteLength;
          if (totalLength > expectedContentLength) {
            this.onError("content-length mismatch");
            res.close();
            return;
          }
          if (!buffer) {
            if (isLast) {
              onEnd(Buffer.from(arrayBuffer));
              return;
            }
            buffer = Buffer.allocUnsafe(expectedContentLength);
          }
          Buffer.from(arrayBuffer).copy(buffer, offset);
          if (isLast) {
            if (totalLength != expectedContentLength) {
              this.onError("content-length mismatch");
              res.writeStatus("400 Content-Length Mismatch").end();
              this.onDataRequestCleanup();
              return;
            }
            onEnd(buffer);
            return;
          }
          offset = totalLength;
        });
      }
      onDataRequestCleanup() {
        this.dataReq = this.dataRes = null;
      }
      onData(data) {
        debug('received "%s"', data);
        const callback = (packet) => {
          if (packet.type === "close") {
            debug("got xhr close packet");
            this.onClose();
            return false;
          }
          this.onPacket(packet);
        };
        if (this.protocol === 3) {
          this.parser.decodePayload(data, callback);
        } else {
          this.parser.decodePayload(data).forEach(callback);
        }
      }
      onClose() {
        if (this.writable) {
          this.send([{ type: "noop" }]);
        }
        super.onClose();
      }
      send(packets) {
        this.writable = false;
        if (this.shouldClose) {
          debug("appending close packet to payload");
          packets.push({ type: "close" });
          this.shouldClose();
          this.shouldClose = null;
        }
        const doWrite = (data) => {
          const compress = packets.some((packet) => {
            return packet.options && packet.options.compress;
          });
          this.write(data, { compress });
        };
        if (this.protocol === 3) {
          this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        } else {
          this.parser.encodePayload(packets, doWrite);
        }
      }
      write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
          this.req.cleanup();
        });
      }
      doWrite(data, options, callback) {
        const isString = typeof data === "string";
        const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
        const headers = {
          "Content-Type": contentType
        };
        const respond = (data2) => {
          this.headers(this.req, headers);
          Object.keys(headers).forEach((key) => {
            this.res.writeHeader(key, String(headers[key]));
          });
          this.res.end(data2);
          callback();
        };
        if (!this.httpCompression || !options.compress) {
          respond(data);
          return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
          respond(data);
          return;
        }
        const encoding = accepts(this.req).encodings(["gzip", "deflate"]);
        if (!encoding) {
          respond(data);
          return;
        }
        this.compress(data, encoding, (err, data2) => {
          if (err) {
            this.res.writeStatus("500 Internal Server Error");
            this.res.end();
            callback(err);
            return;
          }
          headers["Content-Encoding"] = encoding;
          respond(data2);
        });
      }
      compress(data, encoding, callback) {
        debug("compressing");
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
          buffers.push(chunk);
          nread += chunk.length;
        }).on("end", function() {
          callback(null, Buffer.concat(buffers, nread));
        }).end(data);
      }
      doClose(fn) {
        debug("closing");
        let closeTimeoutTimer;
        const onClose = () => {
          clearTimeout(closeTimeoutTimer);
          fn();
          this.onClose();
        };
        if (this.writable) {
          debug("transport writable - closing right away");
          this.send([{ type: "close" }]);
          onClose();
        } else if (this.discarded) {
          debug("transport discarded - closing right away");
          onClose();
        } else {
          debug("transport not writable - buffering orderly close");
          this.shouldClose = onClose;
          closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
      }
      headers(req, headers) {
        headers = headers || {};
        const ua = req.headers["user-agent"];
        if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
          headers["X-XSS-Protection"] = "0";
        }
        this.emit("headers", headers, req);
        return headers;
      }
    };
    exports.Polling = Polling;
  }
});

// node_modules/engine.io/build/transports-uws/websocket.js
var require_websocket3 = __commonJS({
  "node_modules/engine.io/build/transports-uws/websocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocket = void 0;
    var transport_1 = require_transport();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("engine:ws");
    var WebSocket2 = class extends transport_1.Transport {
      constructor(req) {
        super(req);
        this.writable = false;
        this.perMessageDeflate = null;
      }
      get name() {
        return "websocket";
      }
      get handlesUpgrades() {
        return true;
      }
      get supportsFraming() {
        return true;
      }
      send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const isLast = i + 1 === packets.length;
          const send = (data) => {
            const isBinary = typeof data !== "string";
            const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
            debug('writing "%s"', data);
            this.socket.send(data, isBinary, compress);
            if (isLast) {
              this.writable = true;
              this.emit("drain");
            }
          };
          if (packet.options && typeof packet.options.wsPreEncoded === "string") {
            send(packet.options.wsPreEncoded);
          } else {
            this.parser.encodePacket(packet, this.supportsBinary, send);
          }
        }
      }
      doClose(fn) {
        debug("closing");
        fn && fn();
        this.socket.end();
      }
    };
    exports.WebSocket = WebSocket2;
  }
});

// node_modules/engine.io/build/transports-uws/index.js
var require_transports_uws = __commonJS({
  "node_modules/engine.io/build/transports-uws/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var polling_1 = require_polling2();
    var websocket_1 = require_websocket3();
    exports.default = {
      polling: polling_1.Polling,
      websocket: websocket_1.WebSocket
    };
  }
});

// node_modules/engine.io/build/userver.js
var require_userver = __commonJS({
  "node_modules/engine.io/build/userver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uServer = void 0;
    var debug_1 = require_src();
    var server_1 = require_server();
    var transports_uws_1 = require_transports_uws();
    var debug = (0, debug_1.default)("engine:uws");
    var uServer = class extends server_1.BaseServer {
      init() {
      }
      cleanup() {
      }
      prepare(req, res) {
        req.method = req.getMethod().toUpperCase();
        req.url = req.getUrl();
        const params = new URLSearchParams(req.getQuery());
        req._query = Object.fromEntries(params.entries());
        req.headers = {};
        req.forEach((key, value) => {
          req.headers[key] = value;
        });
        req.connection = {
          remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
        };
        res.onAborted(() => {
          debug("response has been aborted");
        });
      }
      createTransport(transportName, req) {
        return new transports_uws_1.default[transportName](req);
      }
      attach(app, options = {}) {
        const path = this._computePath(options);
        app.any(path, this.handleRequest.bind(this)).ws(path, {
          compression: options.compression,
          idleTimeout: options.idleTimeout,
          maxBackpressure: options.maxBackpressure,
          maxPayloadLength: this.opts.maxHttpBufferSize,
          upgrade: this.handleUpgrade.bind(this),
          open: (ws) => {
            ws.transport.socket = ws;
            ws.transport.writable = true;
            ws.transport.emit("drain");
          },
          message: (ws, message, isBinary) => {
            ws.transport.onData(isBinary ? message : Buffer.from(message).toString());
          },
          close: (ws, code, message) => {
            ws.transport.onClose(code, message);
          }
        });
      }
      _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
          return callback();
        }
        req.res = new ResponseWrapper(res);
        super._applyMiddlewares(req, req.res, () => {
          req.res.writeHead();
          callback();
        });
      }
      handleRequest(res, req) {
        debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
        this.prepare(req, res);
        req.res = res;
        this._applyMiddlewares(req, res, () => {
          this.verify(req, false, (errorCode, errorContext) => {
            if (errorCode !== void 0) {
              this.emit("connection_error", {
                req,
                code: errorCode,
                message: server_1.Server.errorMessages[errorCode],
                context: errorContext
              });
              this.abortRequest(req.res, errorCode, errorContext);
              return;
            }
            if (req._query.sid) {
              debug("setting new request for existing client");
              this.clients[req._query.sid].transport.onRequest(req);
            } else {
              const closeConnection = (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2);
              this.handshake(req._query.transport, req, closeConnection);
            }
          });
        });
      }
      handleUpgrade(res, req, context) {
        debug("on upgrade");
        this.prepare(req, res);
        req.res = res;
        this._applyMiddlewares(req, res, () => {
          this.verify(req, true, async (errorCode, errorContext) => {
            if (errorCode) {
              this.emit("connection_error", {
                req,
                code: errorCode,
                message: server_1.Server.errorMessages[errorCode],
                context: errorContext
              });
              this.abortRequest(res, errorCode, errorContext);
              return;
            }
            const id = req._query.sid;
            let transport;
            if (id) {
              const client = this.clients[id];
              if (!client) {
                debug("upgrade attempt for closed client");
                res.close();
              } else if (client.upgrading) {
                debug("transport has already been trying to upgrade");
                res.close();
              } else if (client.upgraded) {
                debug("transport had already been upgraded");
                res.close();
              } else {
                debug("upgrading existing transport");
                transport = this.createTransport(req._query.transport, req);
                client.maybeUpgrade(transport);
              }
            } else {
              transport = await this.handshake(req._query.transport, req, (errorCode2, errorContext2) => this.abortRequest(res, errorCode2, errorContext2));
              if (!transport) {
                return;
              }
            }
            req.res.writeStatus("101 Switching Protocols");
            res.upgrade({
              transport
            }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
          });
        });
      }
      abortRequest(res, errorCode, errorContext) {
        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
        const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
        res.writeStatus(statusCode);
        res.writeHeader("Content-Type", "application/json");
        res.end(JSON.stringify({
          code: errorCode,
          message
        }));
      }
    };
    exports.uServer = uServer;
    var ResponseWrapper = class {
      constructor(res) {
        this.res = res;
        this.statusWritten = false;
        this.headers = [];
      }
      set statusCode(status) {
        if (!status) {
          return;
        }
        this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
      }
      writeHead(status) {
        this.statusCode = status;
      }
      setHeader(key, value) {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            this.writeHeader(key, val);
          });
        } else {
          this.writeHeader(key, value);
        }
      }
      removeHeader() {
      }
      getHeader() {
      }
      writeStatus(status) {
        this.res.writeStatus(status);
        this.statusWritten = true;
        this.writeBufferedHeaders();
      }
      writeHeader(key, value) {
        if (key === "Content-Length") {
          return;
        }
        if (this.statusWritten) {
          this.res.writeHeader(key, value);
        } else {
          this.headers.push([key, value]);
        }
      }
      writeBufferedHeaders() {
        this.headers.forEach(([key, value]) => {
          this.res.writeHeader(key, value);
        });
      }
      end(data) {
        if (!this.statusWritten) {
          this.writeBufferedHeaders();
        }
        this.res.end(data);
      }
      onData(fn) {
        this.res.onData(fn);
      }
      onAborted(fn) {
        this.res.onAborted(fn);
      }
    };
  }
});

// node_modules/engine.io/build/engine.io.js
var require_engine_io = __commonJS({
  "node_modules/engine.io/build/engine.io.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.attach = exports.listen = exports.transports = exports.Server = void 0;
    var http_1 = require("http");
    var server_1 = require_server();
    Object.defineProperty(exports, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var index_1 = require_transports();
    exports.transports = index_1.default;
    var parser = require_cjs();
    exports.parser = parser;
    var userver_1 = require_userver();
    Object.defineProperty(exports, "uServer", { enumerable: true, get: function() {
      return userver_1.uServer;
    } });
    var socket_1 = require_socket();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_1.Socket;
    } });
    var transport_1 = require_transport();
    Object.defineProperty(exports, "Transport", { enumerable: true, get: function() {
      return transport_1.Transport;
    } });
    exports.protocol = parser.protocol;
    function listen(port, options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      const server = (0, http_1.createServer)(function(req, res) {
        res.writeHead(501);
        res.end("Not Implemented");
      });
      const engine = attach(server, options);
      engine.httpServer = server;
      server.listen(port, fn);
      return engine;
    }
    exports.listen = listen;
    function attach(server, options) {
      const engine = new server_1.Server(options);
      engine.attach(server, options);
      return engine;
    }
    exports.attach = attach;
  }
});

// node_modules/@socket.io/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/@socket.io/component-emitter/index.js"(exports) {
    exports.Emitter = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/is-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasBinary = exports.isBinary = void 0;
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    var toString = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    function isBinary(obj) {
      return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
    }
    exports.isBinary = isBinary;
    function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (isBinary(obj)) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    exports.hasBinary = hasBinary;
  }
});

// node_modules/socket.io-parser/build/cjs/binary.js
var require_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reconstructPacket = exports.deconstructPacket = void 0;
    var is_binary_js_1 = require_is_binary();
    function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length;
      return { packet: pack, buffers };
    }
    exports.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
        }
        return newData;
      }
      return data;
    }
    function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      delete packet.attachments;
      return packet;
    }
    exports.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) {
          return buffers[data.num];
        } else {
          throw new Error("illegal attachments");
        }
      } else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === "object") {
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
      }
      return data;
    }
  }
});

// node_modules/socket.io-parser/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/socket.io-parser/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
    var component_emitter_1 = require_component_emitter();
    var binary_js_1 = require_binary();
    var is_binary_js_1 = require_is_binary();
    var debug_1 = require_src();
    var debug = (0, debug_1.default)("socket.io-parser");
    exports.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
    var Encoder2 = class {
      constructor(replacer) {
        this.replacer = replacer;
      }
      encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if ((0, is_binary_js_1.hasBinary)(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && obj.nsp !== "/") {
          str += obj.nsp + ",";
        }
        if (obj.id != null) {
          str += obj.id;
        }
        if (obj.data != null) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
      }
      encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    };
    exports.Encoder = Encoder2;
    var Decoder = class extends component_emitter_1.Emitter {
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf = str.substring(start, i);
          if (buf != Number(buf) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if (str.charAt(i + 1) === "/") {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c === ",")
              break;
            if (i === str.length)
              break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if (next !== "" && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c == null || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length)
              break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug("decoded %s as %j", str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return typeof payload === "object";
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || typeof payload === "object";
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && payload.length > 0;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    };
    exports.Decoder = Decoder;
    var BinaryReconstructor = class {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io/dist/client.js
var require_client = __commonJS({
  "node_modules/socket.io/dist/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = void 0;
    var socket_io_parser_1 = require_cjs2();
    var debugModule = require_src();
    var url = require("url");
    var debug = debugModule("socket.io:client");
    var Client = class {
      constructor(server, conn) {
        this.sockets = new Map();
        this.nsps = new Map();
        this.server = server;
        this.conn = conn;
        this.encoder = server.encoder;
        this.decoder = new server._parser.Decoder();
        this.id = conn.id;
        this.setup();
      }
      get request() {
        return this.conn.request;
      }
      setup() {
        this.onclose = this.onclose.bind(this);
        this.ondata = this.ondata.bind(this);
        this.onerror = this.onerror.bind(this);
        this.ondecoded = this.ondecoded.bind(this);
        this.decoder.on("decoded", this.ondecoded);
        this.conn.on("data", this.ondata);
        this.conn.on("error", this.onerror);
        this.conn.on("close", this.onclose);
        this.connectTimeout = setTimeout(() => {
          if (this.nsps.size === 0) {
            debug("no namespace joined yet, close the client");
            this.close();
          } else {
            debug("the client has already joined a namespace, nothing to do");
          }
        }, this.server._connectTimeout);
      }
      connect(name, auth = {}) {
        if (this.server._nsps.has(name)) {
          debug("connecting to namespace %s", name);
          return this.doConnect(name, auth);
        }
        this.server._checkNamespace(name, auth, (dynamicNspName) => {
          if (dynamicNspName) {
            this.doConnect(name, auth);
          } else {
            debug("creation of namespace %s was denied", name);
            this._packet({
              type: socket_io_parser_1.PacketType.CONNECT_ERROR,
              nsp: name,
              data: {
                message: "Invalid namespace"
              }
            });
          }
        });
      }
      doConnect(name, auth) {
        const nsp = this.server.of(name);
        nsp._add(this, auth, (socket) => {
          this.sockets.set(socket.id, socket);
          this.nsps.set(nsp.name, socket);
          if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
            this.connectTimeout = void 0;
          }
        });
      }
      _disconnect() {
        for (const socket of this.sockets.values()) {
          socket.disconnect();
        }
        this.sockets.clear();
        this.close();
      }
      _remove(socket) {
        if (this.sockets.has(socket.id)) {
          const nsp = this.sockets.get(socket.id).nsp.name;
          this.sockets.delete(socket.id);
          this.nsps.delete(nsp);
        } else {
          debug("ignoring remove for %s", socket.id);
        }
      }
      close() {
        if (this.conn.readyState === "open") {
          debug("forcing transport close");
          this.conn.close();
          this.onclose("forced server close");
        }
      }
      _packet(packet, opts = {}) {
        if (this.conn.readyState !== "open") {
          debug("ignoring packet write %j", packet);
          return;
        }
        const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
        this.writeToEngine(encodedPackets, opts);
      }
      writeToEngine(encodedPackets, opts) {
        if (opts.volatile && !this.conn.transport.writable) {
          debug("volatile packet is discarded since the transport is not currently writable");
          return;
        }
        const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];
        for (const encodedPacket of packets) {
          this.conn.write(encodedPacket, opts);
        }
      }
      ondata(data) {
        try {
          this.decoder.add(data);
        } catch (e) {
          debug("invalid packet format");
          this.onerror(e);
        }
      }
      ondecoded(packet) {
        let namespace;
        let authPayload;
        if (this.conn.protocol === 3) {
          const parsed = url.parse(packet.nsp, true);
          namespace = parsed.pathname;
          authPayload = parsed.query;
        } else {
          namespace = packet.nsp;
          authPayload = packet.data;
        }
        const socket = this.nsps.get(namespace);
        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {
          this.connect(namespace, authPayload);
        } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {
          process.nextTick(function() {
            socket._onpacket(packet);
          });
        } else {
          debug("invalid state (packet type: %s)", packet.type);
          this.close();
        }
      }
      onerror(err) {
        for (const socket of this.sockets.values()) {
          socket._onerror(err);
        }
        this.conn.close();
      }
      onclose(reason, description) {
        debug("client close with reason %s", reason);
        this.destroy();
        for (const socket of this.sockets.values()) {
          socket._onclose(reason, description);
        }
        this.sockets.clear();
        this.decoder.destroy();
      }
      destroy() {
        this.conn.removeListener("data", this.ondata);
        this.conn.removeListener("error", this.onerror);
        this.conn.removeListener("close", this.onclose);
        this.decoder.removeListener("decoded", this.ondecoded);
        if (this.connectTimeout) {
          clearTimeout(this.connectTimeout);
          this.connectTimeout = void 0;
        }
      }
    };
    exports.Client = Client;
  }
});

// node_modules/socket.io/dist/typed-events.js
var require_typed_events = __commonJS({
  "node_modules/socket.io/dist/typed-events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StrictEventEmitter = void 0;
    var events_1 = require("events");
    var StrictEventEmitter = class extends events_1.EventEmitter {
      on(ev, listener) {
        return super.on(ev, listener);
      }
      once(ev, listener) {
        return super.once(ev, listener);
      }
      emit(ev, ...args) {
        return super.emit(ev, ...args);
      }
      emitReserved(ev, ...args) {
        return super.emit(ev, ...args);
      }
      emitUntyped(ev, ...args) {
        return super.emit(ev, ...args);
      }
      listeners(event) {
        return super.listeners(event);
      }
    };
    exports.StrictEventEmitter = StrictEventEmitter;
  }
});

// node_modules/socket.io/dist/broadcast-operator.js
var require_broadcast_operator = __commonJS({
  "node_modules/socket.io/dist/broadcast-operator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoteSocket = exports.BroadcastOperator = void 0;
    var socket_1 = require_socket2();
    var socket_io_parser_1 = require_cjs2();
    var BroadcastOperator = class {
      constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {
        this.adapter = adapter;
        this.rooms = rooms;
        this.exceptRooms = exceptRooms;
        this.flags = flags;
      }
      to(room) {
        const rooms = new Set(this.rooms);
        if (Array.isArray(room)) {
          room.forEach((r) => rooms.add(r));
        } else {
          rooms.add(room);
        }
        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
      }
      in(room) {
        return this.to(room);
      }
      except(room) {
        const exceptRooms = new Set(this.exceptRooms);
        if (Array.isArray(room)) {
          room.forEach((r) => exceptRooms.add(r));
        } else {
          exceptRooms.add(room);
        }
        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
      }
      compress(compress) {
        const flags = Object.assign({}, this.flags, { compress });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      get volatile() {
        const flags = Object.assign({}, this.flags, { volatile: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      get local() {
        const flags = Object.assign({}, this.flags, { local: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      timeout(timeout) {
        const flags = Object.assign({}, this.flags, { timeout });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      emit(ev, ...args) {
        if (socket_1.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data
        };
        const withAck = typeof data[data.length - 1] === "function";
        if (!withAck) {
          this.adapter.broadcast(packet, {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags
          });
          return true;
        }
        const ack = data.pop();
        let timedOut = false;
        let responses = [];
        const timer = setTimeout(() => {
          timedOut = true;
          ack.apply(this, [
            new Error("operation has timed out"),
            this.flags.expectSingleResponse ? null : responses
          ]);
        }, this.flags.timeout);
        let expectedServerCount = -1;
        let actualServerCount = 0;
        let expectedClientCount = 0;
        const checkCompleteness = () => {
          if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
            clearTimeout(timer);
            ack.apply(this, [
              null,
              this.flags.expectSingleResponse ? null : responses
            ]);
          }
        };
        this.adapter.broadcastWithAck(packet, {
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        }, (clientCount) => {
          expectedClientCount += clientCount;
          actualServerCount++;
          checkCompleteness();
        }, (clientResponse) => {
          responses.push(clientResponse);
          checkCompleteness();
        });
        this.adapter.serverCount().then((serverCount) => {
          expectedServerCount = serverCount;
          checkCompleteness();
        });
        return true;
      }
      emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
          args.push((err, responses) => {
            if (err) {
              err.responses = responses;
              return reject(err);
            } else {
              return resolve(responses);
            }
          });
          this.emit(ev, ...args);
        });
      }
      allSockets() {
        if (!this.adapter) {
          throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
        }
        return this.adapter.sockets(this.rooms);
      }
      fetchSockets() {
        return this.adapter.fetchSockets({
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        }).then((sockets) => {
          return sockets.map((socket) => {
            if (socket instanceof socket_1.Socket) {
              return socket;
            } else {
              return new RemoteSocket(this.adapter, socket);
            }
          });
        });
      }
      socketsJoin(room) {
        this.adapter.addSockets({
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        }, Array.isArray(room) ? room : [room]);
      }
      socketsLeave(room) {
        this.adapter.delSockets({
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        }, Array.isArray(room) ? room : [room]);
      }
      disconnectSockets(close = false) {
        this.adapter.disconnectSockets({
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        }, close);
      }
    };
    exports.BroadcastOperator = BroadcastOperator;
    var RemoteSocket = class {
      constructor(adapter, details) {
        this.id = details.id;
        this.handshake = details.handshake;
        this.rooms = new Set(details.rooms);
        this.data = details.data;
        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {
          expectSingleResponse: true
        });
      }
      timeout(timeout) {
        return this.operator.timeout(timeout);
      }
      emit(ev, ...args) {
        return this.operator.emit(ev, ...args);
      }
      join(room) {
        return this.operator.socketsJoin(room);
      }
      leave(room) {
        return this.operator.socketsLeave(room);
      }
      disconnect(close = false) {
        this.operator.disconnectSockets(close);
        return this;
      }
    };
    exports.RemoteSocket = RemoteSocket;
  }
});

// node_modules/socket.io/dist/socket.js
var require_socket2 = __commonJS({
  "node_modules/socket.io/dist/socket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Socket = exports.RESERVED_EVENTS = void 0;
    var socket_io_parser_1 = require_cjs2();
    var debug_1 = __importDefault(require_src());
    var typed_events_1 = require_typed_events();
    var base64id_1 = __importDefault(require_base64id());
    var broadcast_operator_1 = require_broadcast_operator();
    var debug = (0, debug_1.default)("socket.io:socket");
    var RECOVERABLE_DISCONNECT_REASONS = new Set([
      "transport error",
      "transport close",
      "forced close",
      "ping timeout",
      "server shutting down",
      "forced server close"
    ]);
    exports.RESERVED_EVENTS = new Set([
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
    ]);
    function noop() {
    }
    var Socket2 = class extends typed_events_1.StrictEventEmitter {
      constructor(nsp, client, auth, previousSession) {
        super();
        this.nsp = nsp;
        this.client = client;
        this.recovered = false;
        this.data = {};
        this.connected = false;
        this.acks = new Map();
        this.fns = [];
        this.flags = {};
        this.server = nsp.server;
        this.adapter = this.nsp.adapter;
        if (previousSession) {
          this.id = previousSession.sid;
          this.pid = previousSession.pid;
          previousSession.rooms.forEach((room) => this.join(room));
          this.data = previousSession.data;
          previousSession.missedPackets.forEach((packet) => {
            this.packet({
              type: socket_io_parser_1.PacketType.EVENT,
              data: packet
            });
          });
          this.recovered = true;
        } else {
          if (client.conn.protocol === 3) {
            this.id = nsp.name !== "/" ? nsp.name + "#" + client.id : client.id;
          } else {
            this.id = base64id_1.default.generateId();
          }
          if (this.server._opts.connectionStateRecovery) {
            this.pid = base64id_1.default.generateId();
          }
        }
        this.handshake = this.buildHandshake(auth);
      }
      buildHandshake(auth) {
        return {
          headers: this.request.headers,
          time: new Date() + "",
          address: this.conn.remoteAddress,
          xdomain: !!this.request.headers.origin,
          secure: !!this.request.connection.encrypted,
          issued: +new Date(),
          url: this.request.url,
          query: this.request._query,
          auth
        };
      }
      emit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data
        };
        if (typeof data[data.length - 1] === "function") {
          const id = this.nsp._ids++;
          debug("emitting packet with ack id %d", id);
          this.registerAckCallback(id, data.pop());
          packet.id = id;
        }
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        if (this.nsp.server.opts.connectionStateRecovery) {
          this.adapter.broadcast(packet, {
            rooms: new Set([this.id]),
            except: new Set(),
            flags
          });
        } else {
          this.notifyOutgoingListeners(packet);
          this.packet(packet, flags);
        }
        return true;
      }
      emitWithAck(ev, ...args) {
        const withErr = this.flags.timeout !== void 0;
        return new Promise((resolve, reject) => {
          args.push((arg1, arg2) => {
            if (withErr) {
              return arg1 ? reject(arg1) : resolve(arg2);
            } else {
              return resolve(arg1);
            }
          });
          this.emit(ev, ...args);
        });
      }
      registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === void 0) {
          this.acks.set(id, ack);
          return;
        }
        const timer = setTimeout(() => {
          debug("event with ack id %d has timed out after %d ms", id, timeout);
          this.acks.delete(id);
          ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks.set(id, (...args) => {
          clearTimeout(timer);
          ack.apply(this, [null, ...args]);
        });
      }
      to(room) {
        return this.newBroadcastOperator().to(room);
      }
      in(room) {
        return this.newBroadcastOperator().in(room);
      }
      except(room) {
        return this.newBroadcastOperator().except(room);
      }
      send(...args) {
        this.emit("message", ...args);
        return this;
      }
      write(...args) {
        this.emit("message", ...args);
        return this;
      }
      packet(packet, opts = {}) {
        packet.nsp = this.nsp.name;
        opts.compress = opts.compress !== false;
        this.client._packet(packet, opts);
      }
      join(rooms) {
        debug("join room %s", rooms);
        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
      }
      leave(room) {
        debug("leave room %s", room);
        return this.adapter.del(this.id, room);
      }
      leaveAll() {
        this.adapter.delAll(this.id);
      }
      _onconnect() {
        debug("socket connected - writing packet");
        this.connected = true;
        this.join(this.id);
        if (this.conn.protocol === 3) {
          this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
        } else {
          this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: { sid: this.id, pid: this.pid }
          });
        }
      }
      _onpacket(packet) {
        debug("got packet %j", packet);
        switch (packet.type) {
          case socket_io_parser_1.PacketType.EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
        }
      }
      onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (packet.id != null) {
          debug("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        this.dispatch(args);
      }
      ack(id) {
        const self2 = this;
        let sent = false;
        return function() {
          if (sent)
            return;
          const args = Array.prototype.slice.call(arguments);
          debug("sending ack %j", args);
          self2.packet({
            id,
            type: socket_io_parser_1.PacketType.ACK,
            data: args
          });
          sent = true;
        };
      }
      onack(packet) {
        const ack = this.acks.get(packet.id);
        if (typeof ack == "function") {
          debug("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          this.acks.delete(packet.id);
        } else {
          debug("bad ack %s", packet.id);
        }
      }
      ondisconnect() {
        debug("got disconnect packet");
        this._onclose("client namespace disconnect");
      }
      _onerror(err) {
        if (this.listeners("error").length) {
          this.emitReserved("error", err);
        } else {
          console.error("Missing error handler on `socket`.");
          console.error(err.stack);
        }
      }
      _onclose(reason, description) {
        if (!this.connected)
          return this;
        debug("closing socket - reason %s", reason);
        this.emitReserved("disconnecting", reason, description);
        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
          debug("connection state recovery is enabled for sid %s", this.id);
          this.adapter.persistSession({
            sid: this.id,
            pid: this.pid,
            rooms: [...this.rooms],
            data: this.data
          });
        }
        this._cleanup();
        this.nsp._remove(this);
        this.client._remove(this);
        this.connected = false;
        this.emitReserved("disconnect", reason, description);
        return;
      }
      _cleanup() {
        this.leaveAll();
        this.join = noop;
      }
      _error(err) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
      }
      disconnect(close = false) {
        if (!this.connected)
          return this;
        if (close) {
          this.client._disconnect();
        } else {
          this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
          this._onclose("server namespace disconnect");
        }
        return this;
      }
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      get broadcast() {
        return this.newBroadcastOperator();
      }
      get local() {
        return this.newBroadcastOperator().local;
      }
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      dispatch(event) {
        debug("dispatching an event %j", event);
        this.run(event, (err) => {
          process.nextTick(() => {
            if (err) {
              return this._onerror(err);
            }
            if (this.connected) {
              super.emitUntyped.apply(this, event);
            } else {
              debug("ignore packet received after disconnection");
            }
          });
        });
      }
      use(fn) {
        this.fns.push(fn);
        return this;
      }
      run(event, fn) {
        const fns = this.fns.slice(0);
        if (!fns.length)
          return fn(null);
        function run(i) {
          fns[i](event, function(err) {
            if (err)
              return fn(err);
            if (!fns[i + 1])
              return fn(null);
            run(i + 1);
          });
        }
        run(0);
      }
      get disconnected() {
        return !this.connected;
      }
      get request() {
        return this.client.request;
      }
      get conn() {
        return this.client.conn;
      }
      get rooms() {
        return this.adapter.socketRooms(this.id) || new Set();
      }
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      listenersAny() {
        return this._anyListeners || [];
      }
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
      newBroadcastOperator() {
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
      }
    };
    exports.Socket = Socket2;
  }
});

// node_modules/socket.io/dist/namespace.js
var require_namespace = __commonJS({
  "node_modules/socket.io/dist/namespace.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Namespace = exports.RESERVED_EVENTS = void 0;
    var socket_1 = require_socket2();
    var typed_events_1 = require_typed_events();
    var debug_1 = __importDefault(require_src());
    var broadcast_operator_1 = require_broadcast_operator();
    var debug = (0, debug_1.default)("socket.io:namespace");
    exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);
    var Namespace2 = class extends typed_events_1.StrictEventEmitter {
      constructor(server, name) {
        super();
        this.sockets = new Map();
        this._fns = [];
        this._ids = 0;
        this.server = server;
        this.name = name;
        this._initAdapter();
      }
      _initAdapter() {
        this.adapter = new (this.server.adapter())(this);
      }
      use(fn) {
        this._fns.push(fn);
        return this;
      }
      run(socket, fn) {
        const fns = this._fns.slice(0);
        if (!fns.length)
          return fn(null);
        function run(i) {
          fns[i](socket, function(err) {
            if (err)
              return fn(err);
            if (!fns[i + 1])
              return fn(null);
            run(i + 1);
          });
        }
        run(0);
      }
      to(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
      }
      in(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
      }
      except(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
      }
      async _add(client, auth, fn) {
        var _a;
        debug("adding socket to nsp %s", this.name);
        const socket = await this._createSocket(client, auth);
        if (((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) && socket.recovered && client.conn.readyState === "open") {
          return this._doConnect(socket, fn);
        }
        this.run(socket, (err) => {
          process.nextTick(() => {
            if (client.conn.readyState !== "open") {
              debug("next called after client was closed - ignoring socket");
              socket._cleanup();
              return;
            }
            if (err) {
              debug("middleware error, sending CONNECT_ERROR packet to the client");
              socket._cleanup();
              if (client.conn.protocol === 3) {
                return socket._error(err.data || err.message);
              } else {
                return socket._error({
                  message: err.message,
                  data: err.data
                });
              }
            }
            this._doConnect(socket, fn);
          });
        });
      }
      async _createSocket(client, auth) {
        const sessionId = auth.pid;
        const offset = auth.offset;
        if (this.server.opts.connectionStateRecovery && typeof sessionId === "string" && typeof offset === "string") {
          const session = await this.adapter.restoreSession(sessionId, offset);
          if (session) {
            debug("connection state recovered for sid %s", session.sid);
            return new socket_1.Socket(this, client, auth, session);
          } else {
            debug("unable to restore session state");
          }
        }
        return new socket_1.Socket(this, client, auth);
      }
      _doConnect(socket, fn) {
        this.sockets.set(socket.id, socket);
        socket._onconnect();
        if (fn)
          fn(socket);
        this.emitReserved("connect", socket);
        this.emitReserved("connection", socket);
      }
      _remove(socket) {
        if (this.sockets.has(socket.id)) {
          this.sockets.delete(socket.id);
        } else {
          debug("ignoring remove for %s", socket.id);
        }
      }
      emit(ev, ...args) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
      }
      emitWithAck(ev, ...args) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).emitWithAck(ev, ...args);
      }
      send(...args) {
        this.emit("message", ...args);
        return this;
      }
      write(...args) {
        this.emit("message", ...args);
        return this;
      }
      serverSideEmit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        args.unshift(ev);
        this.adapter.serverSideEmit(args);
        return true;
      }
      serverSideEmitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
          args.push((err, responses) => {
            if (err) {
              err.responses = responses;
              return reject(err);
            } else {
              return resolve(responses);
            }
          });
          this.serverSideEmit(ev, ...args);
        });
      }
      _onServerSideEmit(args) {
        super.emitUntyped.apply(this, args);
      }
      allSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
      }
      compress(compress) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
      }
      get volatile() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
      }
      get local() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
      }
      timeout(timeout) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
      }
      fetchSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
      }
      socketsJoin(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
      }
      socketsLeave(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
      }
      disconnectSockets(close = false) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
      }
    };
    exports.Namespace = Namespace2;
  }
});

// node_modules/socket.io/dist/parent-namespace.js
var require_parent_namespace = __commonJS({
  "node_modules/socket.io/dist/parent-namespace.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentNamespace = void 0;
    var namespace_1 = require_namespace();
    var debug_1 = __importDefault(require_src());
    var debug = (0, debug_1.default)("socket.io:parent-namespace");
    var ParentNamespace = class extends namespace_1.Namespace {
      constructor(server) {
        super(server, "/_" + ParentNamespace.count++);
        this.children = new Set();
      }
      _initAdapter() {
        const broadcast = (packet, opts) => {
          this.children.forEach((nsp) => {
            nsp.adapter.broadcast(packet, opts);
          });
        };
        this.adapter = { broadcast };
      }
      emit(ev, ...args) {
        this.children.forEach((nsp) => {
          nsp.emit(ev, ...args);
        });
        return true;
      }
      createChild(name) {
        debug("creating child namespace %s", name);
        const namespace = new namespace_1.Namespace(this.server, name);
        namespace._fns = this._fns.slice(0);
        this.listeners("connect").forEach((listener) => namespace.on("connect", listener));
        this.listeners("connection").forEach((listener) => namespace.on("connection", listener));
        this.children.add(namespace);
        if (this.server._opts.cleanupEmptyChildNamespaces) {
          const remove = namespace._remove;
          namespace._remove = (socket) => {
            remove.call(namespace, socket);
            if (namespace.sockets.size === 0) {
              debug("closing child namespace %s", name);
              namespace.adapter.close();
              this.server._nsps.delete(namespace.name);
              this.children.delete(namespace);
            }
          };
        }
        this.server._nsps.set(name, namespace);
        return namespace;
      }
      fetchSockets() {
        throw new Error("fetchSockets() is not supported on parent namespaces");
      }
    };
    exports.ParentNamespace = ParentNamespace;
    ParentNamespace.count = 0;
  }
});

// node_modules/socket.io-adapter/dist/contrib/yeast.js
var require_yeast = __commonJS({
  "node_modules/socket.io-adapter/dist/contrib/yeast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.yeast = exports.decode = exports.encode = void 0;
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    var length = 64;
    var map = {};
    var seed = 0;
    var i = 0;
    var prev;
    function encode(num) {
      let encoded = "";
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    exports.encode = encode;
    function decode(str) {
      let decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    exports.decode = decode;
    function yeast() {
      const now = encode(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode(seed++);
    }
    exports.yeast = yeast;
    for (; i < length; i++)
      map[alphabet[i]] = i;
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/buffer-util.js
var require_buffer_util2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/limiter.js
var require_limiter2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util2();
    var Limiter = require_limiter2();
    var { kStatusCode } = require_constants2();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/validation.js
var require_validation2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util2();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/sender.js
var require_sender2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate2();
    var { EMPTY_BUFFER } = require_constants2();
    var { isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util2();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(data, {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1: false
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/event-target.js
var require_event_target2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/extension.js
var require_extension2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/websocket.js
var require_websocket4 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var https = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate2();
    var Receiver = require_receiver2();
    var Sender = require_sender2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target2();
    var { format, parse } = require_extension2();
    var { toBuffer } = require_buffer_util2();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter10 {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http2.request;
      const protocolSet = new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      req.end();
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/subprotocol.js
var require_subprotocol2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function parse(header) {
      const protocols = new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/socket.io-adapter/node_modules/ws/lib/websocket-server.js
var require_websocket_server2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var http2 = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension2();
    var PerMessageDeflate = require_permessage_deflate2();
    var subprotocol = require_subprotocol2();
    var WebSocket2 = require_websocket4();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter10 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/socket.io-adapter/node_modules/ws/index.js
var require_ws2 = __commonJS({
  "node_modules/socket.io-adapter/node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket2 = require_websocket4();
    WebSocket2.createWebSocketStream = require_stream2();
    WebSocket2.Server = require_websocket_server2();
    WebSocket2.Receiver = require_receiver2();
    WebSocket2.Sender = require_sender2();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/socket.io-adapter/dist/index.js
var require_dist = __commonJS({
  "node_modules/socket.io-adapter/dist/index.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionAwareAdapter = exports.Adapter = void 0;
    var events_1 = require("events");
    var yeast_1 = require_yeast();
    var WebSocket2 = require_ws2();
    var canPreComputeFrame = typeof ((_a = WebSocket2 === null || WebSocket2 === void 0 ? void 0 : WebSocket2.Sender) === null || _a === void 0 ? void 0 : _a.frame) === "function";
    var Adapter = class extends events_1.EventEmitter {
      constructor(nsp) {
        super();
        this.nsp = nsp;
        this.rooms = new Map();
        this.sids = new Map();
        this.encoder = nsp.server.encoder;
      }
      init() {
      }
      close() {
      }
      serverCount() {
        return Promise.resolve(1);
      }
      addAll(id, rooms) {
        if (!this.sids.has(id)) {
          this.sids.set(id, new Set());
        }
        for (const room of rooms) {
          this.sids.get(id).add(room);
          if (!this.rooms.has(room)) {
            this.rooms.set(room, new Set());
            this.emit("create-room", room);
          }
          if (!this.rooms.get(room).has(id)) {
            this.rooms.get(room).add(id);
            this.emit("join-room", room, id);
          }
        }
      }
      del(id, room) {
        if (this.sids.has(id)) {
          this.sids.get(id).delete(room);
        }
        this._del(room, id);
      }
      _del(room, id) {
        const _room = this.rooms.get(room);
        if (_room != null) {
          const deleted = _room.delete(id);
          if (deleted) {
            this.emit("leave-room", room, id);
          }
          if (_room.size === 0 && this.rooms.delete(room)) {
            this.emit("delete-room", room);
          }
        }
      }
      delAll(id) {
        if (!this.sids.has(id)) {
          return;
        }
        for (const room of this.sids.get(id)) {
          this._del(room, id);
        }
        this.sids.delete(id);
      }
      broadcast(packet, opts) {
        const flags = opts.flags || {};
        const packetOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this._encode(packet, packetOpts);
        this.apply(opts, (socket) => {
          if (typeof socket.notifyOutgoingListeners === "function") {
            socket.notifyOutgoingListeners(packet);
          }
          socket.client.writeToEngine(encodedPackets, packetOpts);
        });
      }
      broadcastWithAck(packet, opts, clientCountCallback, ack) {
        const flags = opts.flags || {};
        const packetOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress
        };
        packet.nsp = this.nsp.name;
        packet.id = this.nsp._ids++;
        const encodedPackets = this._encode(packet, packetOpts);
        let clientCount = 0;
        this.apply(opts, (socket) => {
          clientCount++;
          socket.acks.set(packet.id, ack);
          if (typeof socket.notifyOutgoingListeners === "function") {
            socket.notifyOutgoingListeners(packet);
          }
          socket.client.writeToEngine(encodedPackets, packetOpts);
        });
        clientCountCallback(clientCount);
      }
      _encode(packet, packetOpts) {
        const encodedPackets = this.encoder.encode(packet);
        if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === "string") {
          const data = Buffer.from("4" + encodedPackets[0]);
          packetOpts.wsPreEncodedFrame = WebSocket2.Sender.frame(data, {
            readOnly: false,
            mask: false,
            rsv1: false,
            opcode: 1,
            fin: true
          });
        }
        return encodedPackets;
      }
      sockets(rooms) {
        const sids = new Set();
        this.apply({ rooms }, (socket) => {
          sids.add(socket.id);
        });
        return Promise.resolve(sids);
      }
      socketRooms(id) {
        return this.sids.get(id);
      }
      fetchSockets(opts) {
        const sockets = [];
        this.apply(opts, (socket) => {
          sockets.push(socket);
        });
        return Promise.resolve(sockets);
      }
      addSockets(opts, rooms) {
        this.apply(opts, (socket) => {
          socket.join(rooms);
        });
      }
      delSockets(opts, rooms) {
        this.apply(opts, (socket) => {
          rooms.forEach((room) => socket.leave(room));
        });
      }
      disconnectSockets(opts, close) {
        this.apply(opts, (socket) => {
          socket.disconnect(close);
        });
      }
      apply(opts, callback) {
        const rooms = opts.rooms;
        const except = this.computeExceptSids(opts.except);
        if (rooms.size) {
          const ids = new Set();
          for (const room of rooms) {
            if (!this.rooms.has(room))
              continue;
            for (const id of this.rooms.get(room)) {
              if (ids.has(id) || except.has(id))
                continue;
              const socket = this.nsp.sockets.get(id);
              if (socket) {
                callback(socket);
                ids.add(id);
              }
            }
          }
        } else {
          for (const [id] of this.sids) {
            if (except.has(id))
              continue;
            const socket = this.nsp.sockets.get(id);
            if (socket)
              callback(socket);
          }
        }
      }
      computeExceptSids(exceptRooms) {
        const exceptSids = new Set();
        if (exceptRooms && exceptRooms.size > 0) {
          for (const room of exceptRooms) {
            if (this.rooms.has(room)) {
              this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
            }
          }
        }
        return exceptSids;
      }
      serverSideEmit(packet) {
        console.warn("this adapter does not support the serverSideEmit() functionality");
      }
      persistSession(session) {
      }
      restoreSession(pid, offset) {
        return null;
      }
    };
    exports.Adapter = Adapter;
    var SessionAwareAdapter = class extends Adapter {
      constructor(nsp) {
        super(nsp);
        this.nsp = nsp;
        this.sessions = new Map();
        this.packets = [];
        this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
        const timer = setInterval(() => {
          const threshold = Date.now() - this.maxDisconnectionDuration;
          this.sessions.forEach((session, sessionId) => {
            const hasExpired = session.disconnectedAt < threshold;
            if (hasExpired) {
              this.sessions.delete(sessionId);
            }
          });
          for (let i = this.packets.length - 1; i >= 0; i--) {
            const hasExpired = this.packets[i].emittedAt < threshold;
            if (hasExpired) {
              this.packets.splice(0, i + 1);
              break;
            }
          }
        }, 60 * 1e3);
        timer.unref();
      }
      persistSession(session) {
        session.disconnectedAt = Date.now();
        this.sessions.set(session.pid, session);
      }
      restoreSession(pid, offset) {
        const session = this.sessions.get(pid);
        if (!session) {
          return null;
        }
        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
        if (hasExpired) {
          this.sessions.delete(pid);
          return null;
        }
        const index = this.packets.findIndex((packet) => packet.id === offset);
        if (index === -1) {
          return null;
        }
        const missedPackets = [];
        for (let i = index + 1; i < this.packets.length; i++) {
          const packet = this.packets[i];
          if (shouldIncludePacket(session.rooms, packet.opts)) {
            missedPackets.push(packet.data);
          }
        }
        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
      }
      broadcast(packet, opts) {
        var _a2;
        const isEventPacket = packet.type === 2;
        const withoutAcknowledgement = packet.id === void 0;
        const notVolatile = ((_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.volatile) === void 0;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
          const id = (0, yeast_1.yeast)();
          packet.data.push(id);
          this.packets.push({
            id,
            opts,
            data: packet.data,
            emittedAt: Date.now()
          });
        }
        super.broadcast(packet, opts);
      }
    };
    exports.SessionAwareAdapter = SessionAwareAdapter;
    function shouldIncludePacket(sessionRooms, opts) {
      const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
      const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
      return included && notExcluded;
    }
  }
});

// node_modules/socket.io/dist/uws.js
var require_uws = __commonJS({
  "node_modules/socket.io/dist/uws.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serveFile = exports.restoreAdapter = exports.patchAdapter = void 0;
    var socket_io_adapter_1 = require_dist();
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_src());
    var debug = (0, debug_1.default)("socket.io:adapter-uws");
    var SEPARATOR = "";
    var { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
    function patchAdapter(app) {
      socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {
        const isNew = !this.sids.has(id);
        addAll.call(this, id, rooms);
        const socket = this.nsp.sockets.get(id);
        if (!socket) {
          return;
        }
        if (socket.conn.transport.name === "websocket") {
          subscribe(this.nsp.name, socket, isNew, rooms);
          return;
        }
        if (isNew) {
          socket.conn.on("upgrade", () => {
            const rooms2 = this.sids.get(id);
            if (rooms2) {
              subscribe(this.nsp.name, socket, isNew, rooms2);
            }
          });
        }
      };
      socket_io_adapter_1.Adapter.prototype.del = function(id, room) {
        del.call(this, id, room);
        const socket = this.nsp.sockets.get(id);
        if (socket && socket.conn.transport.name === "websocket") {
          const sessionId = socket.conn.id;
          const websocket = socket.conn.transport.socket;
          const topic = `${this.nsp.name}${SEPARATOR}${room}`;
          debug("unsubscribe connection %s from topic %s", sessionId, topic);
          websocket.unsubscribe(topic);
        }
      };
      socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
        if (!useFastPublish) {
          broadcast.call(this, packet, opts);
          return;
        }
        const flags = opts.flags || {};
        const basePacketOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this.encoder.encode(packet);
        const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
        debug("fast publish to %s", topic);
        encodedPackets.forEach((encodedPacket) => {
          const isBinary = typeof encodedPacket !== "string";
          app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
        });
        this.apply(opts, (socket) => {
          if (socket.conn.transport.name !== "websocket") {
            socket.client.writeToEngine(encodedPackets, basePacketOpts);
          }
        });
      };
    }
    exports.patchAdapter = patchAdapter;
    function subscribe(namespaceName, socket, isNew, rooms) {
      const sessionId = socket.conn.id;
      const websocket = socket.conn.transport.socket;
      if (isNew) {
        debug("subscribe connection %s to topic %s", sessionId, namespaceName);
        websocket.subscribe(namespaceName);
      }
      rooms.forEach((room) => {
        const topic = `${namespaceName}${SEPARATOR}${room}`;
        debug("subscribe connection %s to topic %s", sessionId, topic);
        websocket.subscribe(topic);
      });
    }
    function restoreAdapter() {
      socket_io_adapter_1.Adapter.prototype.addAll = addAll;
      socket_io_adapter_1.Adapter.prototype.del = del;
      socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
    }
    exports.restoreAdapter = restoreAdapter;
    var toArrayBuffer = (buffer) => {
      const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
      return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };
    function serveFile(res, filepath) {
      const { size } = (0, fs_1.statSync)(filepath);
      const readStream = (0, fs_1.createReadStream)(filepath);
      const destroyReadStream = () => !readStream.destroyed && readStream.destroy();
      const onError = (error) => {
        destroyReadStream();
        throw error;
      };
      const onDataChunk = (chunk) => {
        const arrayBufferChunk = toArrayBuffer(chunk);
        const lastOffset = res.getWriteOffset();
        const [ok, done] = res.tryEnd(arrayBufferChunk, size);
        if (!done && !ok) {
          readStream.pause();
          res.onWritable((offset) => {
            const [ok2, done2] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
            if (!done2 && ok2) {
              readStream.resume();
            }
            return ok2;
          });
        }
      };
      res.onAborted(destroyReadStream);
      readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
    }
    exports.serveFile = serveFile;
  }
});

// node_modules/socket.io/package.json
var require_package = __commonJS({
  "node_modules/socket.io/package.json"(exports, module2) {
    module2.exports = {
      name: "socket.io",
      version: "4.6.0",
      description: "node.js realtime framework server",
      keywords: [
        "realtime",
        "framework",
        "websocket",
        "tcp",
        "events",
        "socket",
        "io"
      ],
      files: [
        "dist/",
        "client-dist/",
        "wrapper.mjs",
        "!**/*.tsbuildinfo"
      ],
      directories: {
        doc: "docs/",
        example: "example/",
        lib: "lib/",
        test: "test/"
      },
      type: "commonjs",
      main: "./dist/index.js",
      exports: {
        import: "./wrapper.mjs",
        require: "./dist/index.js",
        types: "./dist/index.d.ts"
      },
      types: "./dist/index.d.ts",
      license: "MIT",
      repository: {
        type: "git",
        url: "git://github.com/socketio/socket.io"
      },
      scripts: {
        compile: "rimraf ./dist && tsc",
        test: "npm run format:check && npm run compile && npm run test:types && npm run test:unit",
        "test:types": "tsd",
        "test:unit": "nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts",
        "format:check": 'prettier --check "lib/**/*.ts" "test/**/*.ts"',
        "format:fix": 'prettier --write "lib/**/*.ts" "test/**/*.ts"',
        prepack: "npm run compile"
      },
      dependencies: {
        accepts: "~1.3.4",
        base64id: "~2.0.0",
        debug: "~4.3.2",
        "engine.io": "~6.4.0",
        "socket.io-adapter": "~2.5.2",
        "socket.io-parser": "~4.2.1"
      },
      devDependencies: {
        "@types/mocha": "^9.0.0",
        "expect.js": "0.3.1",
        mocha: "^10.0.0",
        nyc: "^15.1.0",
        prettier: "^2.3.2",
        rimraf: "^3.0.2",
        "socket.io-client": "4.6.0",
        "socket.io-client-v2": "npm:socket.io-client@^2.4.0",
        superagent: "^8.0.0",
        supertest: "^6.1.6",
        "ts-node": "^10.2.1",
        tsd: "^0.21.0",
        typescript: "^4.4.2",
        "uWebSockets.js": "github:uNetworking/uWebSockets.js#v20.0.0"
      },
      contributors: [
        {
          name: "Guillermo Rauch",
          email: "rauchg@gmail.com"
        },
        {
          name: "Arnout Kazemier",
          email: "info@3rd-eden.com"
        },
        {
          name: "Vladimir Dronnikov",
          email: "dronnikov@gmail.com"
        },
        {
          name: "Einar Otto Stangvik",
          email: "einaros@gmail.com"
        }
      ],
      engines: {
        node: ">=10.0.0"
      },
      tsd: {
        directory: "test"
      }
    };
  }
});

// node_modules/socket.io/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/socket.io/dist/index.js"(exports, module2) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Namespace = exports.Socket = exports.Server = void 0;
    var http2 = require("http");
    var fs_1 = require("fs");
    var zlib_1 = require("zlib");
    var accepts = require_accepts();
    var stream_1 = require("stream");
    var path = require("path");
    var engine_io_1 = require_engine_io();
    var client_1 = require_client();
    var events_1 = require("events");
    var namespace_1 = require_namespace();
    Object.defineProperty(exports, "Namespace", { enumerable: true, get: function() {
      return namespace_1.Namespace;
    } });
    var parent_namespace_1 = require_parent_namespace();
    var socket_io_adapter_1 = require_dist();
    var parser = __importStar(require_cjs2());
    var debug_1 = __importDefault(require_src());
    var socket_1 = require_socket2();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_1.Socket;
    } });
    var typed_events_1 = require_typed_events();
    var uws_1 = require_uws();
    var debug = (0, debug_1.default)("socket.io:server");
    var clientVersion = require_package().version;
    var dotMapRegex = /\.map/;
    var Server2 = class extends typed_events_1.StrictEventEmitter {
      constructor(srv, opts = {}) {
        super();
        this._nsps = new Map();
        this.parentNsps = new Map();
        if (typeof srv === "object" && srv instanceof Object && !srv.listen) {
          opts = srv;
          srv = void 0;
        }
        this.path(opts.path || "/socket.io");
        this.connectTimeout(opts.connectTimeout || 45e3);
        this.serveClient(opts.serveClient !== false);
        this._parser = opts.parser || parser;
        this.encoder = new this._parser.Encoder();
        this.opts = opts;
        if (opts.connectionStateRecovery) {
          opts.connectionStateRecovery = Object.assign({
            maxDisconnectionDuration: 2 * 60 * 1e3,
            skipMiddlewares: true
          }, opts.connectionStateRecovery);
          this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
        } else {
          this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
        }
        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
        this.sockets = this.of("/");
        if (srv || typeof srv == "number")
          this.attach(srv);
      }
      get _opts() {
        return this.opts;
      }
      serveClient(v) {
        if (!arguments.length)
          return this._serveClient;
        this._serveClient = v;
        return this;
      }
      _checkNamespace(name, auth, fn) {
        if (this.parentNsps.size === 0)
          return fn(false);
        const keysIterator = this.parentNsps.keys();
        const run = () => {
          const nextFn = keysIterator.next();
          if (nextFn.done) {
            return fn(false);
          }
          nextFn.value(name, auth, (err, allow) => {
            if (err || !allow) {
              return run();
            }
            if (this._nsps.has(name)) {
              debug("dynamic namespace %s already exists", name);
              return fn(this._nsps.get(name));
            }
            const namespace = this.parentNsps.get(nextFn.value).createChild(name);
            debug("dynamic namespace %s was created", name);
            this.sockets.emitReserved("new_namespace", namespace);
            fn(namespace);
          });
        };
        run();
      }
      path(v) {
        if (!arguments.length)
          return this._path;
        this._path = v.replace(/\/$/, "");
        const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
        return this;
      }
      connectTimeout(v) {
        if (v === void 0)
          return this._connectTimeout;
        this._connectTimeout = v;
        return this;
      }
      adapter(v) {
        if (!arguments.length)
          return this._adapter;
        this._adapter = v;
        for (const nsp of this._nsps.values()) {
          nsp._initAdapter();
        }
        return this;
      }
      listen(srv, opts = {}) {
        return this.attach(srv, opts);
      }
      attach(srv, opts = {}) {
        if (typeof srv == "function") {
          const msg = "You are trying to attach socket.io to an express request handler function. Please pass a http.Server instance.";
          throw new Error(msg);
        }
        if (Number(srv) == srv) {
          srv = Number(srv);
        }
        if (typeof srv == "number") {
          debug("creating http server and binding to %d", srv);
          const port = srv;
          srv = http2.createServer((req, res) => {
            res.writeHead(404);
            res.end();
          });
          srv.listen(port);
        }
        Object.assign(opts, this.opts);
        opts.path = opts.path || this._path;
        this.initEngine(srv, opts);
        return this;
      }
      attachApp(app, opts = {}) {
        Object.assign(opts, this.opts);
        opts.path = opts.path || this._path;
        debug("creating uWebSockets.js-based engine with opts %j", opts);
        const engine = new engine_io_1.uServer(opts);
        engine.attach(app, opts);
        this.bind(engine);
        if (this._serveClient) {
          app.get(`${this._path}/*`, (res, req) => {
            if (!this.clientPathRegex.test(req.getUrl())) {
              req.setYield(true);
              return;
            }
            const filename = req.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
            const isMap = dotMapRegex.test(filename);
            const type = isMap ? "map" : "source";
            const expectedEtag = '"' + clientVersion + '"';
            const weakEtag = "W/" + expectedEtag;
            const etag = req.getHeader("if-none-match");
            if (etag) {
              if (expectedEtag === etag || weakEtag === etag) {
                debug("serve client %s 304", type);
                res.writeStatus("304 Not Modified");
                res.end();
                return;
              }
            }
            debug("serve client %s", type);
            res.writeHeader("cache-control", "public, max-age=0");
            res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
            res.writeHeader("etag", expectedEtag);
            const filepath = path.join(__dirname, "../client-dist/", filename);
            (0, uws_1.serveFile)(res, filepath);
          });
        }
        (0, uws_1.patchAdapter)(app);
      }
      initEngine(srv, opts) {
        debug("creating engine.io instance with opts %j", opts);
        this.eio = (0, engine_io_1.attach)(srv, opts);
        if (this._serveClient)
          this.attachServe(srv);
        this.httpServer = srv;
        this.bind(this.eio);
      }
      attachServe(srv) {
        debug("attaching client serving req handler");
        const evs = srv.listeners("request").slice(0);
        srv.removeAllListeners("request");
        srv.on("request", (req, res) => {
          if (this.clientPathRegex.test(req.url)) {
            this.serve(req, res);
          } else {
            for (let i = 0; i < evs.length; i++) {
              evs[i].call(srv, req, res);
            }
          }
        });
      }
      serve(req, res) {
        const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
        const isMap = dotMapRegex.test(filename);
        const type = isMap ? "map" : "source";
        const expectedEtag = '"' + clientVersion + '"';
        const weakEtag = "W/" + expectedEtag;
        const etag = req.headers["if-none-match"];
        if (etag) {
          if (expectedEtag === etag || weakEtag === etag) {
            debug("serve client %s 304", type);
            res.writeHead(304);
            res.end();
            return;
          }
        }
        debug("serve client %s", type);
        res.setHeader("Cache-Control", "public, max-age=0");
        res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
        res.setHeader("ETag", expectedEtag);
        Server2.sendFile(filename, req, res);
      }
      static sendFile(filename, req, res) {
        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
        const encoding = accepts(req).encodings(["br", "gzip", "deflate"]);
        const onError = (err) => {
          if (err) {
            res.end();
          }
        };
        switch (encoding) {
          case "br":
            res.writeHead(200, { "content-encoding": "br" });
            readStream.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
            break;
          case "gzip":
            res.writeHead(200, { "content-encoding": "gzip" });
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
            break;
          case "deflate":
            res.writeHead(200, { "content-encoding": "deflate" });
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
            break;
          default:
            res.writeHead(200);
            (0, stream_1.pipeline)(readStream, res, onError);
        }
      }
      bind(engine) {
        this.engine = engine;
        this.engine.on("connection", this.onconnection.bind(this));
        return this;
      }
      onconnection(conn) {
        debug("incoming connection with id %s", conn.id);
        const client = new client_1.Client(this, conn);
        if (conn.protocol === 3) {
          client.connect("/");
        }
        return this;
      }
      of(name, fn) {
        if (typeof name === "function" || name instanceof RegExp) {
          const parentNsp = new parent_namespace_1.ParentNamespace(this);
          debug("initializing parent namespace %s", parentNsp.name);
          if (typeof name === "function") {
            this.parentNsps.set(name, parentNsp);
          } else {
            this.parentNsps.set((nsp2, conn, next) => next(null, name.test(nsp2)), parentNsp);
          }
          if (fn) {
            parentNsp.on("connect", fn);
          }
          return parentNsp;
        }
        if (String(name)[0] !== "/")
          name = "/" + name;
        let nsp = this._nsps.get(name);
        if (!nsp) {
          debug("initializing namespace %s", name);
          nsp = new namespace_1.Namespace(this, name);
          this._nsps.set(name, nsp);
          if (name !== "/") {
            this.sockets.emitReserved("new_namespace", nsp);
          }
        }
        if (fn)
          nsp.on("connect", fn);
        return nsp;
      }
      close(fn) {
        for (const socket of this.sockets.sockets.values()) {
          socket._onclose("server shutting down");
        }
        this.engine.close();
        (0, uws_1.restoreAdapter)();
        if (this.httpServer) {
          this.httpServer.close(fn);
        } else {
          fn && fn();
        }
      }
      use(fn) {
        this.sockets.use(fn);
        return this;
      }
      to(room) {
        return this.sockets.to(room);
      }
      in(room) {
        return this.sockets.in(room);
      }
      except(room) {
        return this.sockets.except(room);
      }
      emitWithAck(ev, ...args) {
        return this.sockets.emitWithAck(ev, ...args);
      }
      send(...args) {
        this.sockets.emit("message", ...args);
        return this;
      }
      write(...args) {
        this.sockets.emit("message", ...args);
        return this;
      }
      serverSideEmit(ev, ...args) {
        return this.sockets.serverSideEmit(ev, ...args);
      }
      serverSideEmitWithAck(ev, ...args) {
        return this.sockets.serverSideEmitWithAck(ev, ...args);
      }
      allSockets() {
        return this.sockets.allSockets();
      }
      compress(compress) {
        return this.sockets.compress(compress);
      }
      get volatile() {
        return this.sockets.volatile;
      }
      get local() {
        return this.sockets.local;
      }
      timeout(timeout) {
        return this.sockets.timeout(timeout);
      }
      fetchSockets() {
        return this.sockets.fetchSockets();
      }
      socketsJoin(room) {
        return this.sockets.socketsJoin(room);
      }
      socketsLeave(room) {
        return this.sockets.socketsLeave(room);
      }
      disconnectSockets(close = false) {
        return this.sockets.disconnectSockets(close);
      }
    };
    exports.Server = Server2;
    var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {
      return typeof events_1.EventEmitter.prototype[key] === "function";
    });
    emitterMethods.forEach(function(fn) {
      Server2.prototype[fn] = function() {
        return this.sockets[fn].apply(this.sockets, arguments);
      };
    });
    module2.exports = (srv, opts) => new Server2(srv, opts);
    module2.exports.Server = Server2;
    module2.exports.Namespace = namespace_1.Namespace;
    module2.exports.Socket = socket_1.Socket;
    var socket_2 = require_socket2();
  }
});

// node_modules/ws/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util3 = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants3();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter3 = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate3 = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util3();
    var Limiter = require_limiter3();
    var { kStatusCode, NOOP } = require_constants3();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation3 = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver3 = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate3();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants3();
    var { concat, toArrayBuffer, unmask } = require_buffer_util3();
    var { isValidStatusCode, isValidUTF8 } = require_validation3();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender3 = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate3();
    var { EMPTY_BUFFER } = require_constants3();
    var { isValidStatusCode } = require_validation3();
    var { mask: applyMask, toBuffer } = require_buffer_util3();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target3 = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension3 = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket5 = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var https = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate3();
    var Receiver = require_receiver3();
    var Sender = require_sender3();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants3();
    var { addEventListener, removeEventListener } = require_event_target3();
    var { format, parse } = require_extension3();
    var { toBuffer } = require_buffer_util3();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket2 = class extends EventEmitter10 {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http2.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream3 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server3 = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter10 = require("events");
    var http2 = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate3();
    var WebSocket2 = require_websocket5();
    var { format, parse } = require_extension3();
    var { GUID, kWebSocket } = require_constants3();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter10 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = new Set();
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket2(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http2.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws3 = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket2 = require_websocket5();
    WebSocket2.createWebSocketStream = require_stream3();
    WebSocket2.Server = require_websocket_server3();
    WebSocket2.Receiver = require_receiver3();
    WebSocket2.Sender = require_sender3();
    module2.exports = WebSocket2;
  }
});

// node_modules/johnny-five/lib/mixins/emitter.js
var require_emitter = __commonJS({
  "node_modules/johnny-five/lib/mixins/emitter.js"(exports, module2) {
    var EventEmitter10 = require("events");
    var wm = new WeakMap();
    var Emitter = class extends EventEmitter10 {
      pause() {
        wm.set(this, {
          ...this._events
        });
        this._events = { __proto__: null };
      }
      resume() {
        const events = wm.get(this);
        if (events) {
          this._events = {
            __proto__: null,
            ...events
          };
          wm.set(this, null);
        }
      }
    };
    Object.assign(Emitter.prototype, EventEmitter10.prototype);
    module2.exports = Emitter;
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/ansi-styles/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/ansi-styles/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f0-9]{4}|x[a-f0-9]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[0-9a-f]{4}|x[0-9a-f]{2}|.)|([^\\])/gi;
    var ESCAPES = {
      n: "\n",
      r: "\r",
      t: "	",
      b: "\b",
      f: "\f",
      v: "\v",
      0: "\0",
      "\\": "\\",
      e: "",
      a: "\x07"
    };
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES[c] || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var supportsColor = require_supports_color();
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = new Set(["gray"]);
    var styles = Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = supportsColor ? supportsColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], key);
        }
      };
    }
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = supportsColor;
  }
});

// node_modules/johnny-five/lib/mixins/collection.js
var require_collection = __commonJS({
  "node_modules/johnny-five/lib/mixins/collection.js"(exports, module2) {
    var EventEmitter10 = require("events");
    var Emitter = require_emitter();
    var Collection = class {
      constructor(numsOrObjects) {
        const Type = this.type;
        let initObjects = [];
        this.length = 0;
        if (Array.isArray(numsOrObjects)) {
          initObjects = numsOrObjects;
        } else {
          if (Array.isArray(numsOrObjects.pins)) {
            const keys = Object.keys(numsOrObjects).filter((key) => key !== "pins");
            initObjects = numsOrObjects.pins.map((pin) => {
              const obj = {};
              if (Array.isArray(pin)) {
                obj.pins = pin;
              } else {
                obj.pin = pin;
              }
              return keys.reduce((accum, key) => {
                accum[key] = numsOrObjects[key];
                return accum;
              }, obj);
            });
          }
        }
        if (initObjects.length) {
          while (initObjects.length) {
            let numOrObject = initObjects.shift();
            if (typeof Type === "function") {
              if (!(numOrObject instanceof Type || numOrObject instanceof this.constructor)) {
                numOrObject = new Type(numOrObject);
              }
            }
            this.add(numOrObject);
          }
        }
      }
      slice() {
        return new this.constructor([].slice.apply(this, arguments));
      }
    };
    Collection.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    Collection.prototype.add = function(...args) {
      let length = this.length;
      if (args.length === 1 && args[0] instanceof this.constructor) {
        args = args[0];
      }
      for (let i = 0; i < args.length; i++) {
        if (this.type) {
          if (args[i] instanceof this.type || args[i] instanceof this.constructor) {
            this[length++] = args[i];
          }
        } else {
          this[length++] = args[i];
        }
      }
      return this.length = length;
    };
    Collection.prototype.each = function(callback) {
      let length = this.length;
      for (let i = 0; i < length; i++) {
        callback.call(this[i], this[i], i);
      }
      return this;
    };
    Collection.prototype.forEach = function() {
      [].forEach.apply(this, arguments);
    };
    Collection.prototype.includes = function() {
      return [].includes.apply(this, arguments);
    };
    Collection.prototype.indexOf = function() {
      return [].indexOf.apply(this, arguments);
    };
    Collection.prototype.map = function() {
      return [].map.apply(this, arguments);
    };
    Collection.prototype.byId = function(id) {
      return [].find.call(this, function(entry) {
        return entry.id !== void 0 && entry.id === id;
      });
    };
    Collection.installMethodForwarding = (target, source, options = {}) => {
      const { skip = [] } = options;
      const nevercopy = "apply|arguments|bind|call|caller|constructor|domain|length|name|prototype|toString".split("|");
      return Object.getOwnPropertyNames(source).reduce((accum, method) => {
        if (skip.includes(method) || nevercopy.includes(method)) {
          return accum;
        }
        accum[method] = function(...args) {
          const length = this.length;
          for (let i = 0; i < length; i++) {
            this[i][method](...args);
          }
          return this;
        };
        return accum;
      }, target);
    };
    var noop = () => {
    };
    Collection.installCallbackReconciliation = (target, methods) => {
      methods.forEach((method) => {
        target[method] = function(duration, callback) {
          const length = this.length;
          const signals = [];
          if (typeof duration === "function") {
            callback = duration;
            duration = 1e3;
          }
          if (typeof callback !== "function") {
            callback = noop;
          }
          for (let i = 0; i < length; i++) {
            signals.push(new Promise((resolve) => this[i][method](duration, () => resolve())));
          }
          Promise.all(signals).then(callback);
          return this;
        };
      });
    };
    Collection.Emitter = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
        let interval = null;
        let period = 5;
        if (!Array.isArray(numsOrObjects) && (typeof numsOrObjects === "object" && numsOrObjects !== null)) {
          period = numsOrObjects.freq || numsOrObjects.period || period;
          if (numsOrObjects.frequency) {
            period = 1 / numsOrObjects.frequency * 1e3;
          }
        }
        Object.defineProperties(this, {
          period: {
            get() {
              return period;
            },
            set(value) {
              if (period !== value) {
                period = value;
              }
              if (interval) {
                clearInterval(interval);
              }
              interval = setInterval(() => {
                this.emit("data", this);
              }, period);
            }
          }
        });
        this.period = period;
        this.on("newListener", (event) => {
          if (event === "change" || event === "data") {
            return;
          }
          this.forEach((input) => {
            input.on(event, (data) => this.emit(event, input, data));
          });
        });
      }
      add(...inputs) {
        if (inputs.length) {
          super.add(...inputs);
          inputs.forEach((input) => {
            if (input) {
              input.on("change", () => this.emit("change", input));
            }
          });
        }
        return this.length;
      }
    };
    Object.assign(Collection.Emitter.prototype, EventEmitter10.prototype, Emitter.prototype);
    Collection.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    module2.exports = Collection;
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = debounce;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = cloneDeep;
  }
});

// node_modules/johnny-five/lib/fn.js
var require_fn = __commonJS({
  "node_modules/johnny-five/lib/fn.js"(exports, module2) {
    var Fn = {
      debounce: require_lodash(),
      cloneDeep: require_lodash2()
    };
    var { ceil, max, min, PI } = Math;
    Fn.toFixed = (number, digits) => +(number || 0).toFixed(digits);
    Fn.map = (value, fromLow, fromHigh, toLow, toHigh) => (value - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow | 0;
    Fn.scale = Fn.map;
    var f32A = new Float32Array(1);
    Fn.fmap = (value, fromLow, fromHigh, toLow, toHigh) => {
      f32A[0] = (value - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow;
      return f32A[0];
    };
    Fn.fscale = Fn.fmap;
    Fn.constrain = (value, lower, upper) => min(upper, max(lower, value));
    Fn.inRange = (value, lower, upper) => value >= lower && value <= upper;
    Fn.range = function(lower, upper, tick) {
      if (arguments.length === 1) {
        upper = lower - 1;
        lower = 0;
      }
      lower = lower || 0;
      upper = upper || 0;
      tick = tick || 1;
      const len = max(ceil((upper - lower) / tick), 0);
      let idx = 0;
      const range = [];
      while (idx <= len) {
        range[idx++] = lower;
        lower += tick;
      }
      return range;
    };
    Fn.uid = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (chr) => {
      const rnd = Math.random() * 16 | 0;
      return (chr === "x" ? rnd : rnd & 3 | 8).toString(16);
    }).toUpperCase();
    Fn.square = (x) => x * x;
    Fn.sum = function sum(values) {
      let vals;
      if (Array.isArray(values)) {
        vals = values;
      } else {
        vals = [].slice.call(arguments);
      }
      return vals.reduce((accum, value) => accum + value, 0);
    };
    Fn.fma = (a, b, c) => {
      let aHigh = 134217729 * a;
      let aLow;
      aHigh = aHigh + (a - aHigh);
      aLow = a - aHigh;
      let bHigh = 134217729 * b;
      let bLow;
      bHigh = bHigh + (b - bHigh);
      bLow = b - bHigh;
      const r1 = a * b;
      const r2 = -r1 + aHigh * bHigh + aHigh * bLow + aLow * bHigh + aLow * bLow;
      const s = r1 + c;
      const t = r1 - (s - c) + (c - (s - r1));
      return s + (t + r2);
    };
    Fn._BV = Fn.bitValue = Fn.bv = (bit) => 1 << bit;
    Fn.int16 = (msb, lsb) => {
      const result = msb << 8 | lsb;
      return result >> 15 ? ((result ^ 65535) + 1) * -1 : result;
    };
    Fn.uint16 = (msb, lsb) => msb << 8 | lsb;
    Fn.int24 = (b16, b8, b0) => {
      const result = b16 << 16 | b8 << 8 | b0;
      return result >> 23 ? ((result ^ 16777215) + 1) * -1 : result;
    };
    Fn.uint24 = (b16, b8, b0) => b16 << 16 | b8 << 8 | b0;
    Fn.int32 = (b24, b16, b8, b0) => {
      const result = b24 << 24 | b16 << 16 | b8 << 8 | b0;
      return result >> 31 ? ((result ^ 4294967295) + 1) * -1 : result;
    };
    Fn.uint32 = (b24, b16, b8, b0) => (b24 << 24 | b16 << 16 | b8 << 8 | b0) >>> 0;
    Fn.bitSize = (n) => Math.round(Math.log2(n));
    var POW = "POW_2_";
    var U = "u";
    var S = "s";
    var MAX = Fn.bitSize(Number.MAX_SAFE_INTEGER) + 1;
    var bitSizes = [4, 8, 10, 12, 16, 20, 24, 32];
    for (let i = 0; i < MAX; i++) {
      Fn[POW + i] = 2 ** i;
    }
    bitSizes.forEach((bitSize) => {
      const decimal = Fn[POW + bitSize];
      const half = decimal / 2 >>> 0;
      const halfMinusOne = half - 1;
      Fn[U + bitSize] = (value) => {
        if (value < 0) {
          value += decimal;
        }
        return Fn.constrain(value, 0, decimal - 1);
      };
      Fn[S + bitSize] = (value) => {
        if (value > halfMinusOne) {
          value -= decimal;
        }
        return Fn.constrain(value, -half, halfMinusOne);
      };
    });
    Fn.RAD_TO_DEG = 180 / PI;
    Fn.DEG_TO_RAD = PI / 180;
    Fn.TAU = 2 * PI;
    module2.exports = Fn;
  }
});

// node_modules/johnny-five/lib/repl.js
var require_repl = __commonJS({
  "node_modules/johnny-five/lib/repl.js"(exports, module2) {
    var Emitter = require_emitter();
    var repl = require("repl");
    var priv = new Map();
    var Repl = class extends Emitter {
      constructor(opts) {
        if (!Repl.isActive) {
          super();
          Repl.isActive = true;
          this.context = {};
          this.ready = false;
          const state = {
            opts,
            board: opts.board
          };
          priv.set(this, state);
          Repl.ref = this;
        } else {
          return Repl.ref;
        }
      }
      initialize(callback) {
        const state = priv.get(this);
        process.stdin.resume();
        process.stdin.setEncoding("utf8");
        const replDefaults = {
          prompt: ">> ",
          useGlobal: false
        };
        state.board.info("Repl", "Initialized");
        const cmd = repl.start(replDefaults);
        this.ready = true;
        this.cmd = cmd;
        this.context = cmd.context;
        cmd.on("exit", () => {
          const failExitTimeout = 1e3;
          state.board.emit("exit");
          state.board.warn("Board", "Closing.");
          const timeout = setTimeout(() => {
            process.reallyExit();
          }, failExitTimeout);
          const interval = setInterval(() => {
            let pendingIo = false;
            if (state.board.length) {
              for (let i = 0; i < state.board.length; i++) {
                if (state.board[i].io.pending) {
                  pendingIo = true;
                  break;
                }
              }
            } else {
              pendingIo = state.board.io.pending;
            }
            if (!pendingIo) {
              clearInterval(interval);
              clearTimeout(timeout);
              process.nextTick(process.reallyExit);
            }
          }, 1);
        });
        this.inject(state.opts);
        if (callback) {
          process.nextTick(callback);
        }
      }
      close() {
        this.cmd.emit("exit");
      }
      inject(obj) {
        Object.keys(obj).forEach(function(key) {
          Object.defineProperty(this.context, key, Object.getOwnPropertyDescriptor(obj, key));
        }, this);
      }
    };
    Repl.isActive = false;
    Repl.isBlocked = false;
    Repl.ref = null;
    module2.exports = Repl;
  }
});

// node_modules/johnny-five/lib/board.options.js
var require_board_options = __commonJS({
  "node_modules/johnny-five/lib/board.options.js"(exports, module2) {
    var Options = class {
      constructor(arg) {
        var options = {};
        if (typeof arg === "number" || typeof arg === "string") {
          options.pin = arg;
        } else if (Array.isArray(arg)) {
          options.pins = arg;
        } else {
          options = arg;
        }
        Object.assign(this, options);
      }
    };
    module2.exports = Options;
  }
});

// node_modules/johnny-five/lib/board.pins.js
var require_board_pins = __commonJS({
  "node_modules/johnny-five/lib/board.pins.js"(exports, module2) {
    var Options = require_board_options();
    var MODES = {
      INPUT: 0,
      OUTPUT: 1,
      ANALOG: 2,
      PWM: 3,
      SERVO: 4
    };
    var pinsToType = {
      20: "UNO",
      25: "LEONARDO",
      70: "MEGA"
    };
    function Pins(board) {
      if (!(this instanceof Pins)) {
        return new Pins(board);
      }
      const io2 = board.io;
      const pins = io2.pins.slice();
      const length = pins.length;
      const type = pinsToType[length] || "OTHER";
      board.type = type;
      for (let i = 0; i < length; i++) {
        this[i] = pins[i];
      }
      Object.defineProperties(this, {
        type: {
          value: type
        },
        length: {
          value: length
        }
      });
      [
        "isInput",
        "isOutput",
        "isAnalog",
        "isPwm",
        "isServo"
      ].forEach((isType) => {
        if (io2[isType]) {
          this[isType] = io2[isType];
        }
      });
    }
    Object.entries(MODES).forEach(([mode, value]) => {
      Object.defineProperty(Pins, mode, { value });
    });
    function isFirmata({ io: io2 }) {
      return io2.name === "Firmata" || io2.name === "Mock";
    }
    function hasPins({ pin, pins }) {
      return typeof pin !== "undefined" || typeof pins !== "undefined" && pins.length;
    }
    Pins.isFirmata = isFirmata;
    Pins.Error = ({ pin, type, via }) => {
      throw new Error(`Pin Error: ${pin} is not a valid ${type} pin (${via})`);
    };
    var normalizers = new Map();
    Pins.normalize = function(options, board) {
      var type = board.pins.type;
      var isArduino = isFirmata(board);
      var normalizer = normalizers.get(board);
      var isNormalizing;
      if (typeof options === "string" || typeof options === "number" || Array.isArray(options)) {
        options = new Options(options);
      }
      if (!normalizer) {
        isNormalizing = board.io && typeof board.io.normalize === "function";
        normalizer = function(pin) {
          return isArduino ? Pins.fromAnalog(Pins.translate(pin, type)) : isNormalizing ? board.io.normalize(pin) : pin;
        };
        normalizers.set(board, normalizer);
      }
      if (hasPins(options)) {
        if (options.pins) {
          options.pins = options.pins.map(normalizer);
        } else {
          options.pin = normalizer(options.pin);
        }
      }
      return options;
    };
    Pins.normalize.clear = function() {
      normalizers.clear();
    };
    Pins.translations = {
      UNO: {
        dtoa: {
          14: "A0",
          15: "A1",
          16: "A2",
          17: "A3",
          18: "A4",
          19: "A5"
        },
        tinker: {
          I0: "A0",
          I1: "A1",
          I2: "A2",
          I3: "A3",
          I4: "A4",
          I5: "A5",
          O0: 11,
          O1: 10,
          O2: 9,
          O3: 6,
          O4: 5,
          O5: 3,
          D13: 13,
          D12: 12,
          D8: 8,
          D7: 7,
          D4: 4,
          D2: 2
        }
      },
      MEGA: {
        dtoa: {
          54: "A0",
          55: "A1",
          56: "A2",
          57: "A3",
          58: "A4",
          59: "A5",
          60: "A6",
          61: "A7",
          62: "A8",
          63: "A9"
        },
        tinker: {
          I0: "A0",
          I1: "A1",
          I2: "A2",
          I3: "A3",
          I4: "A4",
          I5: "A5",
          I6: "A6",
          I7: "A7",
          I8: "A8",
          I9: "A9",
          O0: 11,
          O1: 10,
          O2: 9,
          O3: 6,
          O4: 5,
          O5: 3,
          D13: 13,
          D12: 12,
          D8: 8,
          D7: 7,
          D4: 4,
          D2: 2
        }
      }
    };
    Pins.translations.LEONARDO = Pins.translations.UNO;
    Pins.translate = function(pin, type) {
      var translations = Pins.translations[type.toUpperCase()];
      if (!translations) {
        return pin;
      }
      return Object.keys(translations).reduce(function(pin2, map) {
        return translations[map][pin2] || pin2;
      }, pin);
    };
    Pins.fromAnalog = function(pin) {
      if (typeof pin === "string" && (pin.length > 1 && pin[0] === "A")) {
        return parseInt(pin.slice(1), 10);
      }
      return pin;
    };
    Pins.identity = function(pins, needle) {
      return [].findIndex.call(pins, function(pin) {
        return pin.name === needle || pin.id === needle || pin.port === needle;
      });
    };
    Object.keys(MODES).forEach(function(key) {
      var name = key[0] + key.slice(1).toLowerCase();
      Pins.prototype["is" + name] = function(pin) {
        var attrs = this[pin] || this[Pins.identity(this, pin)];
        if (attrs && attrs.supportedModes.includes(MODES[key])) {
          return true;
        }
        return false;
      };
    });
    Pins.prototype.isDigital = function(pin) {
      var attrs = this[pin] || this[Pins.identity(this, pin)];
      if (attrs && attrs.supportedModes.length) {
        return true;
      }
      return false;
    };
    module2.exports = Pins;
  }
});

// node_modules/browser-serialport/index.js
var require_browser_serialport = __commonJS({
  "node_modules/browser-serialport/index.js"(exports, module2) {
    "use strict";
    var EE = require("events").EventEmitter;
    var util = require("util");
    var DATABITS = [7, 8];
    var STOPBITS = [1, 2];
    var PARITY = ["none", "even", "mark", "odd", "space"];
    var FLOWCONTROLS = ["RTSCTS"];
    var _options = {
      baudrate: 9600,
      parity: "none",
      rtscts: false,
      databits: 8,
      stopbits: 1,
      buffersize: 256
    };
    function convertOptions(options) {
      switch (options.dataBits) {
        case 7:
          options.dataBits = "seven";
          break;
        case 8:
          options.dataBits = "eight";
          break;
      }
      switch (options.stopBits) {
        case 1:
          options.stopBits = "one";
          break;
        case 2:
          options.stopBits = "two";
          break;
      }
      switch (options.parity) {
        case "none":
          options.parity = "no";
          break;
      }
      return options;
    }
    function SerialPort(path, options, openImmediately, callback) {
      EE.call(this);
      var self2 = this;
      var args = Array.prototype.slice.call(arguments);
      callback = args.pop();
      if (typeof callback !== "function") {
        callback = null;
      }
      options = typeof options !== "function" && options || {};
      openImmediately = openImmediately === void 0 || openImmediately === null ? true : openImmediately;
      callback = callback || function(err2) {
        if (err2) {
          self2.emit("error", err2);
        }
      };
      var err;
      options.baudRate = options.baudRate || options.baudrate || _options.baudrate;
      options.dataBits = options.dataBits || options.databits || _options.databits;
      if (DATABITS.indexOf(options.dataBits) === -1) {
        err = new Error('Invalid "databits": ' + options.dataBits);
        callback(err);
        return;
      }
      options.stopBits = options.stopBits || options.stopbits || _options.stopbits;
      if (STOPBITS.indexOf(options.stopBits) === -1) {
        err = new Error('Invalid "stopbits": ' + options.stopbits);
        callback(err);
        return;
      }
      options.parity = options.parity || _options.parity;
      if (PARITY.indexOf(options.parity) === -1) {
        err = new Error('Invalid "parity": ' + options.parity);
        callback(err);
        return;
      }
      if (!path) {
        err = new Error("Invalid port specified: " + path);
        callback(err);
        return;
      }
      options.rtscts = _options.rtscts;
      if (options.flowControl || options.flowcontrol) {
        var fc = options.flowControl || options.flowcontrol;
        if (typeof fc === "boolean") {
          options.rtscts = true;
        } else {
          var clean = fc.every(function(flowControl) {
            var fcup = flowControl.toUpperCase();
            var idx = FLOWCONTROLS.indexOf(fcup);
            if (idx < 0) {
              var err2 = new Error('Invalid "flowControl": ' + fcup + ". Valid options: " + FLOWCONTROLS.join(", "));
              callback(err2);
              return false;
            } else {
              switch (idx) {
                case 0:
                  options.rtscts = true;
                  break;
              }
              return true;
            }
          });
          if (!clean) {
            return;
          }
        }
      }
      options.bufferSize = options.bufferSize || options.buffersize || _options.buffersize;
      options.serial = options.serial || typeof chrome !== "undefined" && chrome.serial;
      if (!options.serial) {
        throw new Error("No access to serial ports. Try loading as a Chrome Application.");
      }
      this.options = convertOptions(options);
      this.options.serial.onReceiveError.addListener(function(info) {
        switch (info.error) {
          case "disconnected":
          case "device_lost":
          case "system_error":
            err = new Error("Disconnected");
            if (self2.options.disconnectedCallback) {
              self2.options.disconnectedCallback(err);
            } else {
              self2.emit("disconnect", err);
            }
            if (self2.connectionId >= 0) {
              self2.close();
            }
            break;
          case "timeout":
            break;
        }
      });
      this.path = path;
      if (openImmediately) {
        process.nextTick(function() {
          self2.open(callback);
        });
      }
    }
    util.inherits(SerialPort, EE);
    SerialPort.prototype.connectionId = -1;
    SerialPort.prototype.open = function(callback) {
      var options = {
        bitrate: parseInt(this.options.baudRate, 10),
        dataBits: this.options.dataBits,
        parityBit: this.options.parity,
        stopBits: this.options.stopBits,
        ctsFlowControl: this.options.rtscts
      };
      this.options.serial.connect(this.path, options, this.proxy("onOpen", callback));
    };
    SerialPort.prototype.onOpen = function(callback, openInfo) {
      if (chrome.runtime.lastError) {
        if (typeof callback === "function") {
          callback(chrome.runtime.lastError);
        } else {
          this.emit("error", chrome.runtime.lastError);
        }
        return;
      }
      this.connectionId = openInfo.connectionId;
      if (this.connectionId === -1) {
        this.emit("error", new Error("Could not open port."));
        return;
      }
      this.emit("open", openInfo);
      this._reader = this.proxy("onRead");
      this.options.serial.onReceive.addListener(this._reader);
      if (typeof callback === "function") {
        callback(chrome.runtime.lastError, openInfo);
      }
    };
    SerialPort.prototype.onRead = function(readInfo) {
      if (readInfo && this.connectionId === readInfo.connectionId) {
        if (this.options.dataCallback) {
          this.options.dataCallback(toBuffer(readInfo.data));
        } else {
          this.emit("data", toBuffer(readInfo.data));
        }
      }
    };
    SerialPort.prototype.write = function(buffer, callback) {
      if (this.connectionId < 0) {
        var err = new Error("Serialport not open.");
        if (typeof callback === "function") {
          callback(err);
        } else {
          this.emit("error", err);
        }
        return;
      }
      if (typeof buffer === "string") {
        buffer = str2ab(buffer);
      }
      if (buffer instanceof ArrayBuffer === false) {
        buffer = buffer2ArrayBuffer(buffer);
      }
      this.options.serial.send(this.connectionId, buffer, function(info) {
        if (typeof callback === "function") {
          callback(chrome.runtime.lastError, info);
        }
      });
    };
    SerialPort.prototype.close = function(callback) {
      if (this.connectionId < 0) {
        var err = new Error("Serialport not open.");
        if (typeof callback === "function") {
          callback(err);
        } else {
          this.emit("error", err);
        }
        return;
      }
      this.options.serial.disconnect(this.connectionId, this.proxy("onClose", callback));
    };
    SerialPort.prototype.onClose = function(callback, result) {
      this.connectionId = -1;
      this.emit("close");
      this.removeAllListeners();
      if (this._reader) {
        this.options.serial.onReceive.removeListener(this._reader);
        this._reader = null;
      }
      if (typeof callback === "function") {
        callback(chrome.runtime.lastError, result);
      }
    };
    SerialPort.prototype.flush = function(callback) {
      if (this.connectionId < 0) {
        var err = new Error("Serialport not open.");
        if (typeof callback === "function") {
          callback(err);
        } else {
          this.emit("error", err);
        }
        return;
      }
      var self2 = this;
      this.options.serial.flush(this.connectionId, function(result) {
        if (chrome.runtime.lastError) {
          if (typeof callback === "function") {
            callback(chrome.runtime.lastError, result);
          } else {
            self2.emit("error", chrome.runtime.lastError);
          }
          return;
        } else {
          callback(null, result);
        }
      });
    };
    SerialPort.prototype.drain = function(callback) {
      if (this.connectionId < 0) {
        var err = new Error("Serialport not open.");
        if (typeof callback === "function") {
          callback(err);
        } else {
          this.emit("error", err);
        }
        return;
      }
      if (typeof callback === "function") {
        callback();
      }
    };
    SerialPort.prototype.proxy = function() {
      var self2 = this;
      var proxyArgs = [];
      for (var i = 0; i < arguments.length; i++) {
        proxyArgs[i] = arguments[i];
      }
      var functionName = proxyArgs.splice(0, 1)[0];
      var func = function() {
        var funcArgs = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          funcArgs[i2] = arguments[i2];
        }
        var allArgs = proxyArgs.concat(funcArgs);
        self2[functionName].apply(self2, allArgs);
      };
      return func;
    };
    SerialPort.prototype.set = function(options, callback) {
      this.options.serial.setControlSignals(this.connectionId, options, function(result) {
        callback(chrome.runtime.lastError, result);
      });
    };
    SerialPort.prototype.isOpen = function() {
      return this.connectionId > -1;
    };
    function SerialPortList(callback) {
      if (typeof chrome != "undefined" && chrome.serial) {
        chrome.serial.getDevices(function(ports) {
          var portObjects = new Array(ports.length);
          for (var i = 0; i < ports.length; i++) {
            portObjects[i] = {
              comName: ports[i].path,
              manufacturer: ports[i].displayName,
              serialNumber: "",
              pnpId: "",
              locationId: "",
              vendorId: "0x" + (ports[i].vendorId || 0).toString(16),
              productId: "0x" + (ports[i].productId || 0).toString(16)
            };
          }
          callback(chrome.runtime.lastError, portObjects);
        });
      } else {
        callback(new Error("No access to serial ports. Try loading as a Chrome Application."), null);
      }
    }
    function str2ab(str) {
      var buf = new ArrayBuffer(str.length);
      var bufView = new Uint8Array(buf);
      for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }
    function buffer2ArrayBuffer(buffer) {
      var buf = new ArrayBuffer(buffer.length);
      var bufView = new Uint8Array(buf);
      for (var i = 0; i < buffer.length; i++) {
        bufView[i] = buffer[i];
      }
      return buf;
    }
    function toBuffer(ab) {
      var buffer = new Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
      return buffer;
    }
    module2.exports = {
      SerialPort,
      list: SerialPortList,
      buffer2ArrayBuffer,
      used: []
    };
  }
});

// node_modules/@serialport/parser-byte-length/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@serialport/parser-byte-length/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteLengthParser = void 0;
    var stream_1 = require("stream");
    var ByteLengthParser = class extends stream_1.Transform {
      constructor(options) {
        super(options);
        if (typeof options.length !== "number") {
          throw new TypeError('"length" is not a number');
        }
        if (options.length < 1) {
          throw new TypeError('"length" is not greater than 0');
        }
        this.length = options.length;
        this.position = 0;
        this.buffer = Buffer.alloc(this.length);
      }
      _transform(chunk, _encoding, cb) {
        let cursor = 0;
        while (cursor < chunk.length) {
          this.buffer[this.position] = chunk[cursor];
          cursor++;
          this.position++;
          if (this.position === this.length) {
            this.push(this.buffer);
            this.buffer = Buffer.alloc(this.length);
            this.position = 0;
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer.slice(0, this.position));
        this.buffer = Buffer.alloc(this.length);
        cb();
      }
    };
    exports.ByteLengthParser = ByteLengthParser;
  }
});

// node_modules/@serialport/parser-cctalk/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@serialport/parser-cctalk/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CCTalkParser = void 0;
    var stream_1 = require("stream");
    var CCTalkParser = class extends stream_1.Transform {
      constructor(maxDelayBetweenBytesMs = 50) {
        super();
        this.array = [];
        this.cursor = 0;
        this.lastByteFetchTime = 0;
        this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;
      }
      _transform(buffer, encoding, cb) {
        if (this.maxDelayBetweenBytesMs > 0) {
          const now = Date.now();
          if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {
            this.array = [];
            this.cursor = 0;
          }
          this.lastByteFetchTime = now;
        }
        this.cursor += buffer.length;
        Array.from(buffer).map((byte) => this.array.push(byte));
        while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {
          const FullMsgLength = this.array[1] + 5;
          const frame = Buffer.from(this.array.slice(0, FullMsgLength));
          this.array = this.array.slice(frame.length, this.array.length);
          this.cursor -= FullMsgLength;
          this.push(frame);
        }
        cb();
      }
    };
    exports.CCTalkParser = CCTalkParser;
  }
});

// node_modules/@serialport/parser-delimiter/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@serialport/parser-delimiter/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DelimiterParser = void 0;
    var stream_1 = require("stream");
    var DelimiterParser = class extends stream_1.Transform {
      constructor({ delimiter, includeDelimiter = false, ...options }) {
        super(options);
        if (delimiter === void 0) {
          throw new TypeError('"delimiter" is not a bufferable object');
        }
        if (delimiter.length === 0) {
          throw new TypeError('"delimiter" has a 0 or undefined length');
        }
        this.includeDelimiter = includeDelimiter;
        this.delimiter = Buffer.from(delimiter);
        this.buffer = Buffer.alloc(0);
      }
      _transform(chunk, encoding, cb) {
        let data = Buffer.concat([this.buffer, chunk]);
        let position;
        while ((position = data.indexOf(this.delimiter)) !== -1) {
          this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));
          data = data.slice(position + this.delimiter.length);
        }
        this.buffer = data;
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.DelimiterParser = DelimiterParser;
  }
});

// node_modules/@serialport/parser-inter-byte-timeout/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@serialport/parser-inter-byte-timeout/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterByteTimeoutParser = void 0;
    var stream_1 = require("stream");
    var InterByteTimeoutParser = class extends stream_1.Transform {
      constructor({ maxBufferSize = 65536, interval, ...transformOptions }) {
        super(transformOptions);
        if (!interval) {
          throw new TypeError('"interval" is required');
        }
        if (typeof interval !== "number" || Number.isNaN(interval)) {
          throw new TypeError('"interval" is not a number');
        }
        if (interval < 1) {
          throw new TypeError('"interval" is not greater than 0');
        }
        if (typeof maxBufferSize !== "number" || Number.isNaN(maxBufferSize)) {
          throw new TypeError('"maxBufferSize" is not a number');
        }
        if (maxBufferSize < 1) {
          throw new TypeError('"maxBufferSize" is not greater than 0');
        }
        this.maxBufferSize = maxBufferSize;
        this.currentPacket = [];
        this.interval = interval;
      }
      _transform(chunk, encoding, cb) {
        if (this.intervalID) {
          clearTimeout(this.intervalID);
        }
        for (let offset = 0; offset < chunk.length; offset++) {
          this.currentPacket.push(chunk[offset]);
          if (this.currentPacket.length >= this.maxBufferSize) {
            this.emitPacket();
          }
        }
        this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);
        cb();
      }
      emitPacket() {
        if (this.intervalID) {
          clearTimeout(this.intervalID);
        }
        if (this.currentPacket.length > 0) {
          this.push(Buffer.from(this.currentPacket));
        }
        this.currentPacket = [];
      }
      _flush(cb) {
        this.emitPacket();
        cb();
      }
    };
    exports.InterByteTimeoutParser = InterByteTimeoutParser;
  }
});

// node_modules/@serialport/parser-packet-length/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@serialport/parser-packet-length/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PacketLengthParser = void 0;
    var stream_1 = require("stream");
    var PacketLengthParser = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { delimiter = 170, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 255 } = options;
        this.opts = {
          delimiter,
          packetOverhead,
          lengthBytes,
          lengthOffset,
          maxLen
        };
        this.buffer = Buffer.alloc(0);
        this.start = false;
      }
      _transform(chunk, encoding, cb) {
        for (let ndx = 0; ndx < chunk.length; ndx++) {
          const byte = chunk[ndx];
          if (byte === this.opts.delimiter) {
            this.start = true;
          }
          if (this.start === true) {
            this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
            if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {
              const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);
              if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {
                this.push(this.buffer);
                this.buffer = Buffer.alloc(0);
                this.start = false;
              }
            }
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.PacketLengthParser = PacketLengthParser;
  }
});

// node_modules/@serialport/parser-readline/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@serialport/parser-readline/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadlineParser = void 0;
    var parser_delimiter_1 = require_dist5();
    var ReadlineParser = class extends parser_delimiter_1.DelimiterParser {
      constructor(options) {
        const opts = {
          delimiter: Buffer.from("\n", "utf8"),
          encoding: "utf8",
          ...options
        };
        if (typeof opts.delimiter === "string") {
          opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);
        }
        super(opts);
      }
    };
    exports.ReadlineParser = ReadlineParser;
  }
});

// node_modules/@serialport/parser-ready/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@serialport/parser-ready/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadyParser = void 0;
    var stream_1 = require("stream");
    var ReadyParser = class extends stream_1.Transform {
      constructor({ delimiter, ...options }) {
        if (delimiter === void 0) {
          throw new TypeError('"delimiter" is not a bufferable object');
        }
        if (delimiter.length === 0) {
          throw new TypeError('"delimiter" has a 0 or undefined length');
        }
        super(options);
        this.delimiter = Buffer.from(delimiter);
        this.readOffset = 0;
        this.ready = false;
      }
      _transform(chunk, encoding, cb) {
        if (this.ready) {
          this.push(chunk);
          return cb();
        }
        const delimiter = this.delimiter;
        let chunkOffset = 0;
        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {
          if (delimiter[this.readOffset] === chunk[chunkOffset]) {
            this.readOffset++;
          } else {
            this.readOffset = 0;
          }
          chunkOffset++;
        }
        if (this.readOffset === delimiter.length) {
          this.ready = true;
          this.emit("ready");
          const chunkRest = chunk.slice(chunkOffset);
          if (chunkRest.length > 0) {
            this.push(chunkRest);
          }
        }
        cb();
      }
    };
    exports.ReadyParser = ReadyParser;
  }
});

// node_modules/@serialport/parser-regex/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@serialport/parser-regex/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RegexParser = void 0;
    var stream_1 = require("stream");
    var RegexParser = class extends stream_1.Transform {
      constructor({ regex, ...options }) {
        const opts = {
          encoding: "utf8",
          ...options
        };
        if (regex === void 0) {
          throw new TypeError('"options.regex" must be a regular expression pattern or object');
        }
        if (!(regex instanceof RegExp)) {
          regex = new RegExp(regex.toString());
        }
        super(opts);
        this.regex = regex;
        this.data = "";
      }
      _transform(chunk, encoding, cb) {
        const data = this.data + chunk;
        const parts = data.split(this.regex);
        this.data = parts.pop() || "";
        parts.forEach((part) => {
          this.push(part);
        });
        cb();
      }
      _flush(cb) {
        this.push(this.data);
        this.data = "";
        cb();
      }
    };
    exports.RegexParser = RegexParser;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/decoder.js
var require_decoder = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlipDecoder = void 0;
    var stream_1 = require("stream");
    var SlipDecoder = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221 } = options;
        this.opts = {
          START,
          ESC,
          END,
          ESC_START,
          ESC_END,
          ESC_ESC
        };
        this.buffer = Buffer.alloc(0);
        this.escape = false;
        this.start = false;
      }
      _transform(chunk, encoding, cb) {
        for (let ndx = 0; ndx < chunk.length; ndx++) {
          let byte = chunk[ndx];
          if (byte === this.opts.START) {
            this.start = true;
            continue;
          } else if (this.opts.START == void 0) {
            this.start = true;
          }
          if (this.escape) {
            if (byte === this.opts.ESC_START && this.opts.START) {
              byte = this.opts.START;
            } else if (byte === this.opts.ESC_ESC) {
              byte = this.opts.ESC;
            } else if (byte === this.opts.ESC_END) {
              byte = this.opts.END;
            } else {
              this.escape = false;
              this.push(this.buffer);
              this.buffer = Buffer.alloc(0);
            }
          } else {
            if (byte === this.opts.ESC) {
              this.escape = true;
              continue;
            }
            if (byte === this.opts.END) {
              this.push(this.buffer);
              this.buffer = Buffer.alloc(0);
              this.escape = false;
              this.start = false;
              continue;
            }
          }
          this.escape = false;
          if (this.start) {
            this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
          }
        }
        cb();
      }
      _flush(cb) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(0);
        cb();
      }
    };
    exports.SlipDecoder = SlipDecoder;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/encoder.js
var require_encoder = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlipEncoder = void 0;
    var stream_1 = require("stream");
    var SlipEncoder = class extends stream_1.Transform {
      constructor(options = {}) {
        super(options);
        const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221, bluetoothQuirk = false } = options;
        this.opts = {
          START,
          ESC,
          END,
          ESC_START,
          ESC_END,
          ESC_ESC,
          bluetoothQuirk
        };
      }
      _transform(chunk, encoding, cb) {
        const chunkLength = chunk.length;
        if (this.opts.bluetoothQuirk && chunkLength === 0) {
          return cb();
        }
        const encoded = Buffer.alloc(chunkLength * 2 + 2);
        let j = 0;
        if (this.opts.bluetoothQuirk == true) {
          encoded[j++] = this.opts.END;
        }
        if (this.opts.START !== void 0) {
          encoded[j++] = this.opts.START;
        }
        for (let i = 0; i < chunkLength; i++) {
          let byte = chunk[i];
          if (byte === this.opts.START && this.opts.ESC_START) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_START;
          } else if (byte === this.opts.END) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_END;
          } else if (byte === this.opts.ESC) {
            encoded[j++] = this.opts.ESC;
            byte = this.opts.ESC_ESC;
          }
          encoded[j++] = byte;
        }
        encoded[j++] = this.opts.END;
        cb(null, encoded.slice(0, j));
      }
    };
    exports.SlipEncoder = SlipEncoder;
  }
});

// node_modules/@serialport/parser-slip-encoder/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@serialport/parser-slip-encoder/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_decoder(), exports);
    __exportStar(require_encoder(), exports);
  }
});

// node_modules/@serialport/parser-spacepacket/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@serialport/parser-spacepacket/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertHeaderBufferToObj = exports.HEADER_LENGTH = void 0;
    exports.HEADER_LENGTH = 6;
    var toOctetStr = (num) => {
      let str = Number(num).toString(2);
      while (str.length < 8) {
        str = `0${str}`;
      }
      return str;
    };
    var convertHeaderBufferToObj = (buf) => {
      const headerStr = Array.from(buf.slice(0, exports.HEADER_LENGTH)).reduce((accum, curr) => `${accum}${toOctetStr(curr)}`, "");
      const isVersion1 = headerStr.slice(0, 3) === "000";
      const versionNumber = isVersion1 ? 1 : "UNKNOWN_VERSION";
      const type = Number(headerStr[3]);
      const secondaryHeader = Number(headerStr[4]);
      const apid = parseInt(headerStr.slice(5, 16), 2);
      const sequenceFlags = parseInt(headerStr.slice(16, 18), 2);
      const packetName = parseInt(headerStr.slice(18, 32), 2);
      const dataLength = parseInt(headerStr.slice(-16), 2) + 1;
      return {
        versionNumber,
        identification: {
          apid,
          secondaryHeader,
          type
        },
        sequenceControl: {
          packetName,
          sequenceFlags
        },
        dataLength
      };
    };
    exports.convertHeaderBufferToObj = convertHeaderBufferToObj;
  }
});

// node_modules/@serialport/parser-spacepacket/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@serialport/parser-spacepacket/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpacePacketParser = void 0;
    var stream_1 = require("stream");
    var utils_1 = require_utils();
    var SpacePacketParser = class extends stream_1.Transform {
      constructor(options = {}) {
        super({ ...options, objectMode: true });
        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;
        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;
        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;
        this.dataBuffer = Buffer.alloc(0);
        this.headerBuffer = Buffer.alloc(0);
        this.dataLength = 0;
        this.expectingHeader = true;
      }
      pushCompletedPacket() {
        if (!this.header) {
          throw new Error("Missing header");
        }
        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));
        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));
        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));
        const completedPacket = {
          header: { ...this.header },
          data: data.toString()
        };
        if (timeCode.length > 0 || ancillaryData.length > 0) {
          completedPacket.secondaryHeader = {};
          if (timeCode.length) {
            completedPacket.secondaryHeader.timeCode = timeCode.toString();
          }
          if (ancillaryData.length) {
            completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();
          }
        }
        this.push(completedPacket);
        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));
        if (nextChunk.length >= utils_1.HEADER_LENGTH) {
          this.extractHeader(nextChunk);
        } else {
          this.headerBuffer = nextChunk;
          this.dataBuffer = Buffer.alloc(0);
          this.expectingHeader = true;
          this.dataLength = 0;
          this.header = void 0;
        }
      }
      extractHeader(chunk) {
        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);
        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);
        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {
          this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);
          this.dataLength = this.header.dataLength;
          this.headerBuffer = Buffer.alloc(0);
          this.expectingHeader = false;
        } else {
          this.headerBuffer = headerAsBuffer;
        }
        if (startOfDataBuffer.length > 0) {
          this.dataBuffer = Buffer.from(startOfDataBuffer);
          if (this.dataBuffer.length >= this.dataLength) {
            this.pushCompletedPacket();
          }
        }
      }
      _transform(chunk, encoding, cb) {
        if (this.expectingHeader) {
          this.extractHeader(chunk);
        } else {
          this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);
          if (this.dataBuffer.length >= this.dataLength) {
            this.pushCompletedPacket();
          }
        }
        cb();
      }
      _flush(cb) {
        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);
        const remainingArray = Array.from(remaining);
        this.push(remainingArray);
        cb();
      }
    };
    exports.SpacePacketParser = SpacePacketParser;
  }
});

// node_modules/@serialport/stream/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@serialport/stream/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPortStream = exports.DisconnectedError = void 0;
    var stream_1 = require("stream");
    var debug_1 = __importDefault(require_src());
    var debug = (0, debug_1.default)("serialport/stream");
    var DisconnectedError = class extends Error {
      constructor(message) {
        super(message);
        this.disconnected = true;
      }
    };
    exports.DisconnectedError = DisconnectedError;
    var defaultSetFlags = {
      brk: false,
      cts: false,
      dtr: true,
      rts: true
    };
    function allocNewReadPool(poolSize) {
      const pool = Buffer.allocUnsafe(poolSize);
      pool.used = 0;
      return pool;
    }
    var SerialPortStream = class extends stream_1.Duplex {
      constructor(options, openCallback) {
        const settings = {
          autoOpen: true,
          endOnClose: false,
          highWaterMark: 64 * 1024,
          ...options
        };
        super({
          highWaterMark: settings.highWaterMark
        });
        if (!settings.binding) {
          throw new TypeError('"Bindings" is invalid pass it as `options.binding`');
        }
        if (!settings.path) {
          throw new TypeError(`"path" is not defined: ${settings.path}`);
        }
        if (typeof settings.baudRate !== "number") {
          throw new TypeError(`"baudRate" must be a number: ${settings.baudRate}`);
        }
        this.settings = settings;
        this.opening = false;
        this.closing = false;
        this._pool = allocNewReadPool(this.settings.highWaterMark);
        this._kMinPoolSpace = 128;
        if (this.settings.autoOpen) {
          this.open(openCallback);
        }
      }
      get path() {
        return this.settings.path;
      }
      get baudRate() {
        return this.settings.baudRate;
      }
      get isOpen() {
        var _a, _b;
        return ((_b = (_a = this.port) === null || _a === void 0 ? void 0 : _a.isOpen) !== null && _b !== void 0 ? _b : false) && !this.closing;
      }
      _error(error, callback) {
        if (callback) {
          callback.call(this, error);
        } else {
          this.emit("error", error);
        }
      }
      _asyncError(error, callback) {
        process.nextTick(() => this._error(error, callback));
      }
      open(openCallback) {
        if (this.isOpen) {
          return this._asyncError(new Error("Port is already open"), openCallback);
        }
        if (this.opening) {
          return this._asyncError(new Error("Port is opening"), openCallback);
        }
        const { highWaterMark, binding, autoOpen, endOnClose, ...openOptions } = this.settings;
        this.opening = true;
        debug("opening", `path: ${this.path}`);
        this.settings.binding.open(openOptions).then((port) => {
          debug("opened", `path: ${this.path}`);
          this.port = port;
          this.opening = false;
          this.emit("open");
          if (openCallback) {
            openCallback.call(this, null);
          }
        }, (err) => {
          this.opening = false;
          debug("Binding #open had an error", err);
          this._error(err, openCallback);
        });
      }
      update(options, callback) {
        if (!this.isOpen || !this.port) {
          debug("update attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("update", `baudRate: ${options.baudRate}`);
        this.port.update(options).then(() => {
          debug("binding.update", "finished");
          this.settings.baudRate = options.baudRate;
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.update", "error", err);
          return this._error(err, callback);
        });
      }
      write(data, encoding, callback) {
        if (Array.isArray(data)) {
          data = Buffer.from(data);
        }
        if (typeof encoding === "function") {
          return super.write(data, encoding);
        }
        return super.write(data, encoding, callback);
      }
      _write(data, encoding, callback) {
        if (!this.isOpen || !this.port) {
          this.once("open", () => {
            this._write(data, encoding, callback);
          });
          return;
        }
        debug("_write", `${data.length} bytes of data`);
        this.port.write(data).then(() => {
          debug("binding.write", "write finished");
          callback(null);
        }, (err) => {
          debug("binding.write", "error", err);
          if (!err.canceled) {
            this._disconnected(err);
          }
          callback(err);
        });
      }
      _writev(data, callback) {
        debug("_writev", `${data.length} chunks of data`);
        const dataV = data.map((write) => write.chunk);
        this._write(Buffer.concat(dataV), void 0, callback);
      }
      _read(bytesToRead) {
        if (!this.isOpen || !this.port) {
          debug("_read", "queueing _read for after open");
          this.once("open", () => {
            this._read(bytesToRead);
          });
          return;
        }
        if (!this._pool || this._pool.length - this._pool.used < this._kMinPoolSpace) {
          debug("_read", "discarding the read buffer pool because it is below kMinPoolSpace");
          this._pool = allocNewReadPool(this.settings.highWaterMark);
        }
        const pool = this._pool;
        const toRead = Math.min(pool.length - pool.used, bytesToRead);
        const start = pool.used;
        debug("_read", `reading`, { start, toRead });
        this.port.read(pool, start, toRead).then(({ bytesRead }) => {
          debug("binding.read", `finished`, { bytesRead });
          if (bytesRead === 0) {
            debug("binding.read", "Zero bytes read closing readable stream");
            this.push(null);
            return;
          }
          pool.used += bytesRead;
          this.push(pool.slice(start, start + bytesRead));
        }, (err) => {
          debug("binding.read", `error`, err);
          if (!err.canceled) {
            this._disconnected(err);
          }
          this._read(bytesToRead);
        });
      }
      _disconnected(err) {
        if (!this.isOpen) {
          debug("disconnected aborted because already closed", err);
          return;
        }
        debug("disconnected", err);
        this.close(void 0, new DisconnectedError(err.message));
      }
      close(callback, disconnectError = null) {
        if (!this.isOpen || !this.port) {
          debug("close attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        this.closing = true;
        debug("#close");
        this.port.close().then(() => {
          this.closing = false;
          debug("binding.close", "finished");
          this.emit("close", disconnectError);
          if (this.settings.endOnClose) {
            this.emit("end");
          }
          if (callback) {
            callback.call(this, disconnectError);
          }
        }, (err) => {
          this.closing = false;
          debug("binding.close", "had an error", err);
          return this._error(err, callback);
        });
      }
      set(options, callback) {
        if (!this.isOpen || !this.port) {
          debug("set attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        const settings = { ...defaultSetFlags, ...options };
        debug("#set", settings);
        this.port.set(settings).then(() => {
          debug("binding.set", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.set", "had an error", err);
          return this._error(err, callback);
        });
      }
      get(callback) {
        if (!this.isOpen || !this.port) {
          debug("get attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("#get");
        this.port.get().then((status) => {
          debug("binding.get", "finished");
          callback.call(this, null, status);
        }, (err) => {
          debug("binding.get", "had an error", err);
          return this._error(err, callback);
        });
      }
      flush(callback) {
        if (!this.isOpen || !this.port) {
          debug("flush attempted, but port is not open");
          return this._asyncError(new Error("Port is not open"), callback);
        }
        debug("#flush");
        this.port.flush().then(() => {
          debug("binding.flush", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.flush", "had an error", err);
          return this._error(err, callback);
        });
      }
      drain(callback) {
        debug("drain");
        if (!this.isOpen || !this.port) {
          debug("drain queuing on port open");
          this.once("open", () => {
            this.drain(callback);
          });
          return;
        }
        this.port.drain().then(() => {
          debug("binding.drain", "finished");
          if (callback) {
            callback.call(this, null);
          }
        }, (err) => {
          debug("binding.drain", "had an error", err);
          return this._error(err, callback);
        });
      }
    };
    exports.SerialPortStream = SerialPortStream;
  }
});

// node_modules/@serialport/binding-mock/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/@serialport/binding-mock/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugFactory = require_src();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debugFactory__default = /* @__PURE__ */ _interopDefaultLegacy(debugFactory);
    var debug = debugFactory__default["default"]("serialport/binding-mock");
    var ports = {};
    var serialNumber = 0;
    function resolveNextTick() {
      return new Promise((resolve) => process.nextTick(() => resolve()));
    }
    var CanceledError = class extends Error {
      constructor(message) {
        super(message);
        this.canceled = true;
      }
    };
    var MockBinding = {
      reset() {
        ports = {};
        serialNumber = 0;
      },
      createPort(path, options = {}) {
        serialNumber++;
        const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: "The J5 Robotics Company", vendorId: void 0, productId: void 0, maxReadSize: 1024 }, options);
        ports[path] = {
          data: Buffer.alloc(0),
          echo: optWithDefaults.echo,
          record: optWithDefaults.record,
          readyData: optWithDefaults.readyData,
          maxReadSize: optWithDefaults.maxReadSize,
          info: {
            path,
            manufacturer: optWithDefaults.manufacturer,
            serialNumber: `${serialNumber}`,
            pnpId: void 0,
            locationId: void 0,
            vendorId: optWithDefaults.vendorId,
            productId: optWithDefaults.productId
          }
        };
        debug(serialNumber, "created port", JSON.stringify({ path, opt: options }));
      },
      async list() {
        debug(null, "list");
        return Object.values(ports).map((port) => port.info);
      },
      async open(options) {
        var _a;
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const { path } = openOptions;
        debug(null, `open: opening path ${path}`);
        const port = ports[path];
        await resolveNextTick();
        if (!port) {
          throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);
        }
        const serialNumber2 = port.info.serialNumber;
        if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {
          debug(serialNumber2, "open: Port is locked cannot open");
          throw new Error("Port is locked cannot open");
        }
        debug(serialNumber2, `open: opened path ${path}`);
        port.openOpt = Object.assign({}, openOptions);
        return new MockPortBinding(port, openOptions);
      }
    };
    var MockPortBinding = class {
      constructor(port, openOptions) {
        this.port = port;
        this.openOptions = openOptions;
        this.pendingRead = null;
        this.isOpen = true;
        this.lastWrite = null;
        this.recording = Buffer.alloc(0);
        this.writeOperation = null;
        this.serialNumber = port.info.serialNumber;
        if (port.readyData) {
          const data = port.readyData;
          process.nextTick(() => {
            if (this.isOpen) {
              debug(this.serialNumber, "emitting ready data");
              this.emitData(data);
            }
          });
        }
      }
      emitData(data) {
        if (!this.isOpen || !this.port) {
          throw new Error("Port must be open to pretend to receive data");
        }
        const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);
        debug(this.serialNumber, "emitting data - pending read:", Boolean(this.pendingRead));
        this.port.data = Buffer.concat([this.port.data, bufferData]);
        if (this.pendingRead) {
          process.nextTick(this.pendingRead);
          this.pendingRead = null;
        }
      }
      async close() {
        debug(this.serialNumber, "close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const port = this.port;
        if (!port) {
          throw new Error("already closed");
        }
        port.openOpt = void 0;
        port.data = Buffer.alloc(0);
        debug(this.serialNumber, "port is closed");
        this.serialNumber = void 0;
        this.isOpen = false;
        if (this.pendingRead) {
          this.pendingRead(new CanceledError("port is closed"));
        }
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        debug(this.serialNumber, "read", length, "bytes");
        await resolveNextTick();
        if (!this.isOpen || !this.port) {
          throw new CanceledError("Read canceled");
        }
        if (this.port.data.length <= 0) {
          return new Promise((resolve, reject) => {
            this.pendingRead = (err) => {
              if (err) {
                return reject(err);
              }
              this.read(buffer, offset, length).then(resolve, reject);
            };
          });
        }
        const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;
        const data = this.port.data.slice(0, lengthToRead);
        const bytesRead = data.copy(buffer, offset);
        this.port.data = this.port.data.slice(lengthToRead);
        debug(this.serialNumber, "read", bytesRead, "bytes");
        return { bytesRead, buffer };
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (!this.isOpen || !this.port) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        debug(this.serialNumber, "write", buffer.length, "bytes");
        if (this.writeOperation) {
          throw new Error("Overlapping writes are not supported and should be queued by the serialport object");
        }
        this.writeOperation = (async () => {
          await resolveNextTick();
          if (!this.isOpen || !this.port) {
            throw new Error("Write canceled");
          }
          const data = this.lastWrite = Buffer.from(buffer);
          if (this.port.record) {
            this.recording = Buffer.concat([this.recording, data]);
          }
          if (this.port.echo) {
            process.nextTick(() => {
              if (this.isOpen) {
                this.emitData(data);
              }
            });
          }
          this.writeOperation = null;
          debug(this.serialNumber, "writing finished");
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (typeof options !== "object") {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug(this.serialNumber, "update");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        if (this.port.openOpt) {
          this.port.openOpt.baudRate = options.baudRate;
        }
      }
      async set(options) {
        if (typeof options !== "object") {
          throw new TypeError('"options" is not an object');
        }
        debug(this.serialNumber, "set");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
      }
      async get() {
        debug(this.serialNumber, "get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        return {
          cts: true,
          dsr: false,
          dcd: false
        };
      }
      async getBaudRate() {
        var _a;
        debug(this.serialNumber, "getBaudRate");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {
          throw new Error("Internal Error");
        }
        return {
          baudRate: this.port.openOpt.baudRate
        };
      }
      async flush() {
        debug(this.serialNumber, "flush");
        if (!this.isOpen || !this.port) {
          throw new Error("Port is not open");
        }
        await resolveNextTick();
        this.port.data = Buffer.alloc(0);
      }
      async drain() {
        debug(this.serialNumber, "drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await resolveNextTick();
      }
    };
    exports.CanceledError = CanceledError;
    exports.MockBinding = MockBinding;
    exports.MockPortBinding = MockPortBinding;
  }
});

// node_modules/serialport/dist/serialport-mock.js
var require_serialport_mock = __commonJS({
  "node_modules/serialport/dist/serialport-mock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPortMock = void 0;
    var stream_1 = require_dist13();
    var binding_mock_1 = require_dist14();
    var SerialPortMock = class extends stream_1.SerialPortStream {
      constructor(options, openCallback) {
        const opts = {
          binding: binding_mock_1.MockBinding,
          ...options
        };
        super(opts, openCallback);
      }
    };
    exports.SerialPortMock = SerialPortMock;
    SerialPortMock.list = binding_mock_1.MockBinding.list;
    SerialPortMock.binding = binding_mock_1.MockBinding;
  }
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/node-gyp-build.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module2) {
    if (typeof process.addon === "function") {
      module2.exports = process.addon.bind(process);
    } else {
      module2.exports = require_node_gyp_build();
    }
  }
});

// node_modules/@serialport/bindings-cpp/dist/load-bindings.js
var require_load_bindings = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/load-bindings.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncWrite = exports.asyncRead = exports.asyncUpdate = exports.asyncSet = exports.asyncOpen = exports.asyncList = exports.asyncGetBaudRate = exports.asyncGet = exports.asyncFlush = exports.asyncDrain = exports.asyncClose = void 0;
    var node_gyp_build_1 = __importDefault(require_node_gyp_build2());
    var util_1 = require("util");
    var path_1 = require("path");
    var binding = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, "../"));
    exports.asyncClose = binding.close ? (0, util_1.promisify)(binding.close) : async () => {
      throw new Error('"binding.close" Method not implemented');
    };
    exports.asyncDrain = binding.drain ? (0, util_1.promisify)(binding.drain) : async () => {
      throw new Error('"binding.drain" Method not implemented');
    };
    exports.asyncFlush = binding.flush ? (0, util_1.promisify)(binding.flush) : async () => {
      throw new Error('"binding.flush" Method not implemented');
    };
    exports.asyncGet = binding.get ? (0, util_1.promisify)(binding.get) : async () => {
      throw new Error('"binding.get" Method not implemented');
    };
    exports.asyncGetBaudRate = binding.getBaudRate ? (0, util_1.promisify)(binding.getBaudRate) : async () => {
      throw new Error('"binding.getBaudRate" Method not implemented');
    };
    exports.asyncList = binding.list ? (0, util_1.promisify)(binding.list) : async () => {
      throw new Error('"binding.list" Method not implemented');
    };
    exports.asyncOpen = binding.open ? (0, util_1.promisify)(binding.open) : async () => {
      throw new Error('"binding.open" Method not implemented');
    };
    exports.asyncSet = binding.set ? (0, util_1.promisify)(binding.set) : async () => {
      throw new Error('"binding.set" Method not implemented');
    };
    exports.asyncUpdate = binding.update ? (0, util_1.promisify)(binding.update) : async () => {
      throw new Error('"binding.update" Method not implemented');
    };
    exports.asyncRead = binding.read ? (0, util_1.promisify)(binding.read) : async () => {
      throw new Error('"binding.read" Method not implemented');
    };
    exports.asyncWrite = binding.read ? (0, util_1.promisify)(binding.write) : async () => {
      throw new Error('"binding.write" Method not implemented');
    };
  }
});

// node_modules/@serialport/bindings-cpp/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingsError = void 0;
    var BindingsError = class extends Error {
      constructor(message, { canceled = false } = {}) {
        super(message);
        this.canceled = canceled;
      }
    };
    exports.BindingsError = BindingsError;
  }
});

// node_modules/@serialport/bindings-cpp/dist/poller.js
var require_poller = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/poller.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Poller = exports.EVENTS = void 0;
    var debug_1 = __importDefault(require_src());
    var events_1 = require("events");
    var path_1 = require("path");
    var node_gyp_build_1 = __importDefault(require_node_gyp_build2());
    var errors_1 = require_errors();
    var { Poller: PollerBindings } = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, "../"));
    var logger = (0, debug_1.default)("serialport/bindings-cpp/poller");
    exports.EVENTS = {
      UV_READABLE: 1,
      UV_WRITABLE: 2,
      UV_DISCONNECT: 4
    };
    function handleEvent(error, eventFlag) {
      if (error) {
        logger("error", error);
        this.emit("readable", error);
        this.emit("writable", error);
        this.emit("disconnect", error);
        return;
      }
      if (eventFlag & exports.EVENTS.UV_READABLE) {
        logger('received "readable"');
        this.emit("readable", null);
      }
      if (eventFlag & exports.EVENTS.UV_WRITABLE) {
        logger('received "writable"');
        this.emit("writable", null);
      }
      if (eventFlag & exports.EVENTS.UV_DISCONNECT) {
        logger('received "disconnect"');
        this.emit("disconnect", null);
      }
    }
    var Poller = class extends events_1.EventEmitter {
      constructor(fd, FDPoller = PollerBindings) {
        logger("Creating poller");
        super();
        this.poller = new FDPoller(fd, handleEvent.bind(this));
      }
      once(event, callback) {
        switch (event) {
          case "readable":
            this.poll(exports.EVENTS.UV_READABLE);
            break;
          case "writable":
            this.poll(exports.EVENTS.UV_WRITABLE);
            break;
          case "disconnect":
            this.poll(exports.EVENTS.UV_DISCONNECT);
            break;
        }
        return super.once(event, callback);
      }
      poll(eventFlag = 0) {
        if (eventFlag & exports.EVENTS.UV_READABLE) {
          logger('Polling for "readable"');
        }
        if (eventFlag & exports.EVENTS.UV_WRITABLE) {
          logger('Polling for "writable"');
        }
        if (eventFlag & exports.EVENTS.UV_DISCONNECT) {
          logger('Polling for "disconnect"');
        }
        this.poller.poll(eventFlag);
      }
      stop() {
        logger("Stopping poller");
        this.poller.stop();
        this.emitCanceled();
      }
      destroy() {
        logger("Destroying poller");
        this.poller.destroy();
        this.emitCanceled();
      }
      emitCanceled() {
        const err = new errors_1.BindingsError("Canceled", { canceled: true });
        this.emit("readable", err);
        this.emit("writable", err);
        this.emit("disconnect", err);
      }
    };
    exports.Poller = Poller;
  }
});

// node_modules/@serialport/bindings-cpp/dist/unix-read.js
var require_unix_read = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/unix-read.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unixRead = void 0;
    var util_1 = require("util");
    var fs_1 = require("fs");
    var errors_1 = require_errors();
    var debug_1 = __importDefault(require_src());
    var logger = (0, debug_1.default)("serialport/bindings-cpp/unixRead");
    var readAsync = (0, util_1.promisify)(fs_1.read);
    var readable = (binding) => {
      return new Promise((resolve, reject) => {
        if (!binding.poller) {
          throw new Error("No poller on bindings");
        }
        binding.poller.once("readable", (err) => err ? reject(err) : resolve());
      });
    };
    var unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync }) => {
      logger("Starting read");
      if (!binding.isOpen || !binding.fd) {
        throw new errors_1.BindingsError("Port is not open", { canceled: true });
      }
      try {
        const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null);
        if (bytesRead === 0) {
          return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });
        }
        logger("Finished read", bytesRead, "bytes");
        return { bytesRead, buffer };
      } catch (err) {
        logger("read error", err);
        if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
          if (!binding.isOpen) {
            throw new errors_1.BindingsError("Port is not open", { canceled: true });
          }
          logger("waiting for readable because of code:", err.code);
          await readable(binding);
          return (0, exports.unixRead)({ binding, buffer, offset, length, fsReadAsync });
        }
        const disconnectError = err.code === "EBADF" || err.code === "ENXIO" || err.code === "UNKNOWN" || err.errno === -1;
        if (disconnectError) {
          err.disconnect = true;
          logger("disconnecting", err);
        }
        throw err;
      }
    };
    exports.unixRead = unixRead;
  }
});

// node_modules/@serialport/bindings-cpp/dist/unix-write.js
var require_unix_write = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/unix-write.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unixWrite = void 0;
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_src());
    var util_1 = require("util");
    var logger = (0, debug_1.default)("serialport/bindings-cpp/unixWrite");
    var writeAsync = (0, util_1.promisify)(fs_1.write);
    var writable = (binding) => {
      return new Promise((resolve, reject) => {
        binding.poller.once("writable", (err) => err ? reject(err) : resolve());
      });
    };
    var unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {
      const bytesToWrite = buffer.length - offset;
      logger("Starting write", buffer.length, "bytes offset", offset, "bytesToWrite", bytesToWrite);
      if (!binding.isOpen || !binding.fd) {
        throw new Error("Port is not open");
      }
      try {
        const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);
        logger("write returned: wrote", bytesWritten, "bytes");
        if (bytesWritten + offset < buffer.length) {
          if (!binding.isOpen) {
            throw new Error("Port is not open");
          }
          return (0, exports.unixWrite)({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync });
        }
        logger("Finished writing", bytesWritten + offset, "bytes");
      } catch (err) {
        logger("write errored", err);
        if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
          if (!binding.isOpen) {
            throw new Error("Port is not open");
          }
          logger("waiting for writable because of code:", err.code);
          await writable(binding);
          return (0, exports.unixWrite)({ binding, buffer, offset, fsWriteAsync });
        }
        const disconnectError = err.code === "EBADF" || err.code === "ENXIO" || err.code === "UNKNOWN" || err.errno === -1;
        if (disconnectError) {
          err.disconnect = true;
          logger("disconnecting", err);
        }
        logger("error", err);
        throw err;
      }
    };
    exports.unixWrite = unixWrite;
  }
});

// node_modules/@serialport/bindings-cpp/dist/darwin.js
var require_darwin = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/darwin.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DarwinPortBinding = exports.DarwinBinding = void 0;
    var debug_1 = __importDefault(require_src());
    var load_bindings_1 = require_load_bindings();
    var poller_1 = require_poller();
    var unix_read_1 = require_unix_read();
    var unix_write_1 = require_unix_write();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.DarwinBinding = {
      list() {
        debug("list");
        return (0, load_bindings_1.asyncList)();
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        return new DarwinPortBinding(fd, openOptions);
      }
    };
    var DarwinPortBinding = class {
      constructor(fd, options) {
        this.fd = fd;
        this.openOptions = options;
        this.poller = new poller_1.Poller(fd);
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.poller.stop();
        this.poller.destroy();
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, unix_write_1.unixWrite)({ binding: this, buffer });
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set", options);
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        throw new Error("getBaudRate is not implemented on darwin");
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.DarwinPortBinding = DarwinPortBinding;
  }
});

// node_modules/@serialport/bindings-cpp/dist/linux-list.js
var require_linux_list = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/linux-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.linuxList = void 0;
    var child_process_1 = require("child_process");
    var parser_readline_1 = require_dist8();
    function checkPathOfDevice(path) {
      return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path;
    }
    function propName(name) {
      return {
        DEVNAME: "path",
        ID_VENDOR_ENC: "manufacturer",
        ID_SERIAL_SHORT: "serialNumber",
        ID_VENDOR_ID: "vendorId",
        ID_MODEL_ID: "productId",
        DEVLINKS: "pnpId"
      }[name.toUpperCase()];
    }
    function decodeHexEscape(str) {
      return str.replace(/\\x([a-fA-F0-9]{2})/g, (a, b) => {
        return String.fromCharCode(parseInt(b, 16));
      });
    }
    function propVal(name, val) {
      if (name === "pnpId") {
        const match = val.match(/\/by-id\/([^\s]+)/);
        return (match === null || match === void 0 ? void 0 : match[1]) || void 0;
      }
      if (name === "manufacturer") {
        return decodeHexEscape(val);
      }
      if (/^0x/.test(val)) {
        return val.substr(2);
      }
      return val;
    }
    function linuxList(spawnCmd = child_process_1.spawn) {
      const ports = [];
      const udevadm = spawnCmd("udevadm", ["info", "-e"]);
      const lines = udevadm.stdout.pipe(new parser_readline_1.ReadlineParser());
      let skipPort = false;
      let port = {
        path: "",
        manufacturer: void 0,
        serialNumber: void 0,
        pnpId: void 0,
        locationId: void 0,
        vendorId: void 0,
        productId: void 0
      };
      lines.on("data", (line) => {
        const lineType = line.slice(0, 1);
        const data = line.slice(3);
        if (lineType === "P") {
          port = {
            path: "",
            manufacturer: void 0,
            serialNumber: void 0,
            pnpId: void 0,
            locationId: void 0,
            vendorId: void 0,
            productId: void 0
          };
          skipPort = false;
          return;
        }
        if (skipPort) {
          return;
        }
        if (lineType === "N") {
          if (checkPathOfDevice(data)) {
            ports.push(port);
          } else {
            skipPort = true;
          }
          return;
        }
        if (lineType === "E") {
          const keyValue = data.match(/^(.+)=(.*)/);
          if (!keyValue) {
            return;
          }
          const key = propName(keyValue[1]);
          if (!key) {
            return;
          }
          port[key] = propVal(key, keyValue[2]);
        }
      });
      return new Promise((resolve, reject) => {
        udevadm.on("close", (code) => {
          if (code) {
            reject(new Error(`Error listing ports udevadm exited with error code: ${code}`));
          }
        });
        udevadm.on("error", reject);
        lines.on("error", reject);
        lines.on("finish", () => resolve(ports));
      });
    }
    exports.linuxList = linuxList;
  }
});

// node_modules/@serialport/bindings-cpp/dist/linux.js
var require_linux = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/linux.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinuxPortBinding = exports.LinuxBinding = void 0;
    var debug_1 = __importDefault(require_src());
    var linux_list_1 = require_linux_list();
    var poller_1 = require_poller();
    var unix_read_1 = require_unix_read();
    var unix_write_1 = require_unix_write();
    var load_bindings_1 = require_load_bindings();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.LinuxBinding = {
      list() {
        debug("list");
        return (0, linux_list_1.linuxList)();
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        this.fd = fd;
        return new LinuxPortBinding(fd, openOptions);
      }
    };
    var LinuxPortBinding = class {
      constructor(fd, openOptions) {
        this.fd = fd;
        this.openOptions = openOptions;
        this.poller = new poller_1.Poller(fd);
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.poller.stop();
        this.poller.destroy();
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, unix_read_1.unixRead)({ binding: this, buffer, offset, length });
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, unix_write_1.unixWrite)({ binding: this, buffer });
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.LinuxPortBinding = LinuxPortBinding;
  }
});

// node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js
var require_win32_sn_parser = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/win32-sn-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialNumParser = void 0;
    var PARSERS = [/USB\\(?:.+)\\(.+)/, /FTDIBUS\\(?:.+)\+(.+?)A?\\.+/];
    var serialNumParser = (pnpId) => {
      if (!pnpId) {
        return null;
      }
      for (const parser of PARSERS) {
        const sn = pnpId.match(parser);
        if (sn) {
          return sn[1];
        }
      }
      return null;
    };
    exports.serialNumParser = serialNumParser;
  }
});

// node_modules/@serialport/bindings-cpp/dist/win32.js
var require_win32 = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/win32.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowsPortBinding = exports.WindowsBinding = void 0;
    var debug_1 = __importDefault(require_src());
    var _1 = require_dist16();
    var load_bindings_1 = require_load_bindings();
    var win32_sn_parser_1 = require_win32_sn_parser();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    exports.WindowsBinding = {
      async list() {
        const ports = await (0, load_bindings_1.asyncList)();
        return ports.map((port) => {
          if (port.pnpId && !port.serialNumber) {
            const serialNumber = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);
            if (serialNumber) {
              return Object.assign(Object.assign({}, port), { serialNumber });
            }
          }
          return port;
        });
      },
      async open(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        if (!options.path) {
          throw new TypeError('"path" is not a valid port');
        }
        if (!options.baudRate) {
          throw new TypeError('"baudRate" is not a valid baudRate');
        }
        debug("open");
        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, rtsMode: "handshake", xon: false, xoff: false, xany: false, hupcl: true }, options);
        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
        return new WindowsPortBinding(fd, openOptions);
      }
    };
    var WindowsPortBinding = class {
      constructor(fd, options) {
        this.fd = fd;
        this.openOptions = options;
        this.writeOperation = null;
      }
      get isOpen() {
        return this.fd !== null;
      }
      async close() {
        debug("close");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        const fd = this.fd;
        this.fd = null;
        await (0, load_bindings_1.asyncClose)(fd);
      }
      async read(buffer, offset, length) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        if (typeof offset !== "number" || isNaN(offset)) {
          throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
        }
        if (typeof length !== "number" || isNaN(length)) {
          throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
        }
        debug("read");
        if (buffer.length < offset + length) {
          throw new Error("buffer is too small");
        }
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        try {
          const bytesRead = await (0, load_bindings_1.asyncRead)(this.fd, buffer, offset, length);
          return { bytesRead, buffer };
        } catch (err) {
          if (!this.isOpen) {
            throw new _1.BindingsError(err.message, { canceled: true });
          }
          throw err;
        }
      }
      async write(buffer) {
        if (!Buffer.isBuffer(buffer)) {
          throw new TypeError('"buffer" is not a Buffer');
        }
        debug("write", buffer.length, "bytes");
        if (!this.isOpen) {
          debug("write", "error port is not open");
          throw new Error("Port is not open");
        }
        this.writeOperation = (async () => {
          if (buffer.length === 0) {
            return;
          }
          await (0, load_bindings_1.asyncWrite)(this.fd, buffer);
          this.writeOperation = null;
        })();
        return this.writeOperation;
      }
      async update(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw TypeError('"options" is not an object');
        }
        if (typeof options.baudRate !== "number") {
          throw new TypeError('"options.baudRate" is not a number');
        }
        debug("update");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncUpdate)(this.fd, options);
      }
      async set(options) {
        if (!options || typeof options !== "object" || Array.isArray(options)) {
          throw new TypeError('"options" is not an object');
        }
        debug("set", options);
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncSet)(this.fd, options);
      }
      async get() {
        debug("get");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGet)(this.fd);
      }
      async getBaudRate() {
        debug("getBaudRate");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);
      }
      async flush() {
        debug("flush");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await (0, load_bindings_1.asyncFlush)(this.fd);
      }
      async drain() {
        debug("drain");
        if (!this.isOpen) {
          throw new Error("Port is not open");
        }
        await this.writeOperation;
        await (0, load_bindings_1.asyncDrain)(this.fd);
      }
    };
    exports.WindowsPortBinding = WindowsPortBinding;
  }
});

// node_modules/@serialport/bindings-interface/dist/index.js
var require_dist15 = __commonJS({
  "node_modules/@serialport/bindings-interface/dist/index.js"() {
    "use strict";
  }
});

// node_modules/@serialport/bindings-cpp/dist/index.js
var require_dist16 = __commonJS({
  "node_modules/@serialport/bindings-cpp/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autoDetect = void 0;
    var debug_1 = __importDefault(require_src());
    var darwin_1 = require_darwin();
    var linux_1 = require_linux();
    var win32_1 = require_win32();
    var debug = (0, debug_1.default)("serialport/bindings-cpp");
    __exportStar(require_dist15(), exports);
    __exportStar(require_darwin(), exports);
    __exportStar(require_linux(), exports);
    __exportStar(require_win32(), exports);
    __exportStar(require_errors(), exports);
    function autoDetect() {
      switch (process.platform) {
        case "win32":
          debug("loading WindowsBinding");
          return win32_1.WindowsBinding;
        case "darwin":
          debug("loading DarwinBinding");
          return darwin_1.DarwinBinding;
        default:
          debug("loading LinuxBinding");
          return linux_1.LinuxBinding;
      }
    }
    exports.autoDetect = autoDetect;
  }
});

// node_modules/serialport/dist/serialport.js
var require_serialport = __commonJS({
  "node_modules/serialport/dist/serialport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialPort = void 0;
    var stream_1 = require_dist13();
    var bindings_cpp_1 = require_dist16();
    var DetectedBinding = (0, bindings_cpp_1.autoDetect)();
    var SerialPort = class extends stream_1.SerialPortStream {
      constructor(options, openCallback) {
        const opts = {
          binding: DetectedBinding,
          ...options
        };
        super(opts, openCallback);
      }
    };
    exports.SerialPort = SerialPort;
    SerialPort.list = DetectedBinding.list;
    SerialPort.binding = DetectedBinding;
  }
});

// node_modules/serialport/dist/index.js
var require_dist17 = __commonJS({
  "node_modules/serialport/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_dist3(), exports);
    __exportStar(require_dist4(), exports);
    __exportStar(require_dist5(), exports);
    __exportStar(require_dist6(), exports);
    __exportStar(require_dist7(), exports);
    __exportStar(require_dist8(), exports);
    __exportStar(require_dist9(), exports);
    __exportStar(require_dist10(), exports);
    __exportStar(require_dist11(), exports);
    __exportStar(require_dist12(), exports);
    __exportStar(require_serialport_mock(), exports);
    __exportStar(require_serialport(), exports);
  }
});

// node_modules/firmata/lib/encoder7bit.js
var require_encoder7bit = __commonJS({
  "node_modules/firmata/lib/encoder7bit.js"(exports, module2) {
    "use strict";
    module2.exports = {
      to7BitArray(data) {
        let shift = 0;
        let previous = 0;
        const output = [];
        for (let byte of data) {
          if (shift === 0) {
            output.push(byte & 127);
            shift++;
            previous = byte >> 7;
          } else {
            output.push(byte << shift & 127 | previous);
            if (shift === 6) {
              output.push(byte >> 1);
              shift = 0;
            } else {
              shift++;
              previous = byte >> 8 - shift;
            }
          }
        }
        if (shift > 0) {
          output.push(previous);
        }
        return output;
      },
      from7BitArray(encoded) {
        const expectedBytes = encoded.length * 7 >> 3;
        const decoded = [];
        for (let i = 0; i < expectedBytes; i++) {
          const j = i << 3;
          const pos = j / 7 >>> 0;
          const shift = j % 7;
          decoded[i] = encoded[pos] >> shift | encoded[pos + 1] << 7 - shift & 255;
        }
        return decoded;
      }
    };
  }
});

// node_modules/firmata/lib/onewireutils.js
var require_onewireutils = __commonJS({
  "node_modules/firmata/lib/onewireutils.js"(exports, module2) {
    "use strict";
    var Encoder7Bit = require_encoder7bit();
    var OneWireUtils = {
      crc8(data) {
        let crc = 0;
        for (let inbyte of data) {
          for (let n = 8; n; n--) {
            const mix = (crc ^ inbyte) & 1;
            crc >>= 1;
            if (mix) {
              crc ^= 140;
            }
            inbyte >>= 1;
          }
        }
        return crc;
      },
      readDevices(data) {
        const deviceBytes = Encoder7Bit.from7BitArray(data);
        const devices = [];
        for (let i = 0; i < deviceBytes.length; i += 8) {
          const device = deviceBytes.slice(i, i + 8);
          if (device.length !== 8) {
            continue;
          }
          const check = OneWireUtils.crc8(device.slice(0, 7));
          if (check !== device[7]) {
            console.error("ROM invalid!");
          }
          devices.push(device);
        }
        return devices;
      }
    };
    module2.exports = OneWireUtils;
  }
});

// node_modules/firmata/lib/firmata-io.js
var require_firmata_io = __commonJS({
  "node_modules/firmata/lib/firmata-io.js"(exports, module2) {
    "use strict";
    var Emitter = require("events");
    var Encoder7Bit = require_encoder7bit();
    var OneWire = require_onewireutils();
    var i2cActive = new Map();
    var ANALOG_MAPPING_QUERY = 105;
    var ANALOG_MAPPING_RESPONSE = 106;
    var ANALOG_MESSAGE = 224;
    var CAPABILITY_QUERY = 107;
    var CAPABILITY_RESPONSE = 108;
    var DIGITAL_MESSAGE = 144;
    var END_SYSEX = 247;
    var EXTENDED_ANALOG = 111;
    var I2C_CONFIG = 120;
    var I2C_REPLY = 119;
    var I2C_REQUEST = 118;
    var I2C_READ_MASK = 24;
    var ONEWIRE_CONFIG_REQUEST = 65;
    var ONEWIRE_DATA = 115;
    var ONEWIRE_DELAY_REQUEST_BIT = 16;
    var ONEWIRE_READ_REPLY = 67;
    var ONEWIRE_READ_REQUEST_BIT = 8;
    var ONEWIRE_RESET_REQUEST_BIT = 1;
    var ONEWIRE_SEARCH_ALARMS_REPLY = 69;
    var ONEWIRE_SEARCH_ALARMS_REQUEST = 68;
    var ONEWIRE_SEARCH_REPLY = 66;
    var ONEWIRE_SEARCH_REQUEST = 64;
    var ONEWIRE_WITHDATA_REQUEST_BITS = 60;
    var ONEWIRE_WRITE_REQUEST_BIT = 32;
    var PIN_MODE = 244;
    var PIN_STATE_QUERY = 109;
    var PIN_STATE_RESPONSE = 110;
    var PING_READ = 117;
    var QUERY_FIRMWARE = 121;
    var REPORT_ANALOG = 192;
    var REPORT_DIGITAL = 208;
    var REPORT_VERSION = 249;
    var SAMPLING_INTERVAL = 122;
    var SERVO_CONFIG = 112;
    var SERIAL_MESSAGE = 96;
    var SERIAL_CONFIG = 16;
    var SERIAL_WRITE = 32;
    var SERIAL_READ = 48;
    var SERIAL_REPLY = 64;
    var SERIAL_CLOSE = 80;
    var SERIAL_FLUSH = 96;
    var SERIAL_LISTEN = 112;
    var START_SYSEX = 240;
    var STEPPER = 114;
    var ACCELSTEPPER = 98;
    var STRING_DATA = 113;
    var SYSTEM_RESET = 255;
    var MAX_PIN_COUNT = 128;
    var SYM_sendOneWireSearch = Symbol("sendOneWireSearch");
    var SYM_sendOneWireRequest = Symbol("sendOneWireRequest");
    var MIDI_RESPONSE = {
      [REPORT_VERSION](board) {
        board.version.major = board.buffer[1];
        board.version.minor = board.buffer[2];
        board.emit("reportversion");
      },
      [ANALOG_MESSAGE](board) {
        const pin = board.buffer[0] & 15;
        const value = board.buffer[1] | board.buffer[2] << 7;
        if (board.pins[board.analogPins[pin]]) {
          board.pins[board.analogPins[pin]].value = value;
        }
        board.emit(`analog-read-${pin}`, value);
        board.emit("analog-read", {
          pin,
          value
        });
      },
      [DIGITAL_MESSAGE](board) {
        const port = board.buffer[0] & 15;
        const portValue = board.buffer[1] | board.buffer[2] << 7;
        for (let i = 0; i < 8; i++) {
          const pin = 8 * port + i;
          const pinRec = board.pins[pin];
          const bit = 1 << i;
          if (pinRec && (pinRec.mode === board.MODES.INPUT || pinRec.mode === board.MODES.PULLUP)) {
            pinRec.value = portValue >> (i & 7) & 1;
            if (pinRec.value) {
              board.ports[port] |= bit;
            } else {
              board.ports[port] &= ~bit;
            }
            let { value } = pinRec;
            board.emit(`digital-read-${pin}`, value);
            board.emit("digital-read", {
              pin,
              value
            });
          }
        }
      }
    };
    var SYSEX_RESPONSE = {
      [QUERY_FIRMWARE](board) {
        const length = board.buffer.length - 2;
        const buffer = Buffer.alloc(Math.round((length - 4) / 2));
        let byte = 0;
        let offset = 0;
        for (let i = 4; i < length; i += 2) {
          byte = (board.buffer[i] & 127 | (board.buffer[i + 1] & 127) << 7) & 255;
          buffer.writeUInt8(byte, offset++);
        }
        board.firmware = {
          name: buffer.toString(),
          version: {
            major: board.buffer[2],
            minor: board.buffer[3]
          }
        }, board.emit("queryfirmware");
      },
      [CAPABILITY_RESPONSE](board) {
        const modes = Object.keys(board.MODES).map((key) => board.MODES[key]);
        let mode, resolution;
        let capability = 0;
        function supportedModes(capability2) {
          return modes.reduce((accum, mode2) => {
            if (capability2 & 1 << mode2) {
              accum.push(mode2);
            }
            return accum;
          }, []);
        }
        if (!board.pins.length) {
          for (let i = 2, n = 0; i < board.buffer.length - 1; i++) {
            if (board.buffer[i] === 127) {
              board.pins.push({
                supportedModes: supportedModes(capability),
                mode: void 0,
                value: 0,
                report: 1
              });
              capability = 0;
              n = 0;
              continue;
            }
            if (n === 0) {
              mode = board.buffer[i];
              resolution = (1 << board.buffer[i + 1]) - 1;
              capability |= 1 << mode;
              if (mode === board.MODES.ANALOG && board.RESOLUTION.ADC === null) {
                board.RESOLUTION.ADC = resolution;
              }
              if (mode === board.MODES.PWM && board.RESOLUTION.PWM === null) {
                board.RESOLUTION.PWM = resolution;
              }
            }
            n ^= 1;
          }
        }
        board.emit("capability-query");
      },
      [PIN_STATE_RESPONSE](board) {
        let pin = board.buffer[2];
        board.pins[pin].mode = board.buffer[3];
        board.pins[pin].state = board.buffer[4];
        if (board.buffer.length > 6) {
          board.pins[pin].state |= board.buffer[5] << 7;
        }
        if (board.buffer.length > 7) {
          board.pins[pin].state |= board.buffer[6] << 14;
        }
        board.emit(`pin-state-${pin}`);
      },
      [ANALOG_MAPPING_RESPONSE](board) {
        let pin = 0;
        let currentValue;
        for (let i = 2; i < board.buffer.length - 1; i++) {
          currentValue = board.buffer[i];
          board.pins[pin].analogChannel = currentValue;
          if (currentValue !== 127) {
            board.analogPins.push(pin);
          }
          pin++;
        }
        board.emit("analog-mapping-query");
      },
      [I2C_REPLY](board) {
        const reply = [];
        const address = board.buffer[2] & 127 | (board.buffer[3] & 127) << 7;
        const register = board.buffer[4] & 127 | (board.buffer[5] & 127) << 7;
        for (let i = 6, length = board.buffer.length - 1; i < length; i += 2) {
          reply.push(board.buffer[i] | board.buffer[i + 1] << 7);
        }
        board.emit(`I2C-reply-${address}-${register}`, reply);
      },
      [ONEWIRE_DATA](board) {
        const subCommand = board.buffer[2];
        if (!SYSEX_RESPONSE[subCommand]) {
          return;
        }
        SYSEX_RESPONSE[subCommand](board);
      },
      [ONEWIRE_SEARCH_REPLY](board) {
        const pin = board.buffer[3];
        const buffer = board.buffer.slice(4, board.buffer.length - 1);
        board.emit(`1-wire-search-reply-${pin}`, OneWire.readDevices(buffer));
      },
      [ONEWIRE_SEARCH_ALARMS_REPLY](board) {
        const pin = board.buffer[3];
        const buffer = board.buffer.slice(4, board.buffer.length - 1);
        board.emit(`1-wire-search-alarms-reply-${pin}`, OneWire.readDevices(buffer));
      },
      [ONEWIRE_READ_REPLY](board) {
        const encoded = board.buffer.slice(4, board.buffer.length - 1);
        const decoded = Encoder7Bit.from7BitArray(encoded);
        const correlationId = decoded[1] << 8 | decoded[0];
        board.emit(`1-wire-read-reply-${correlationId}`, decoded.slice(2));
      },
      [STRING_DATA](board) {
        board.emit("string", Buffer.from(board.buffer.slice(2, -1)).toString().replace(/\0/g, ""));
      },
      [PING_READ](board) {
        const pin = board.buffer[2] & 127 | (board.buffer[3] & 127) << 7;
        const durationBuffer = [
          board.buffer[4] & 127 | (board.buffer[5] & 127) << 7,
          board.buffer[6] & 127 | (board.buffer[7] & 127) << 7,
          board.buffer[8] & 127 | (board.buffer[9] & 127) << 7,
          board.buffer[10] & 127 | (board.buffer[11] & 127) << 7
        ];
        const duration = (durationBuffer[0] << 24) + (durationBuffer[1] << 16) + (durationBuffer[2] << 8) + durationBuffer[3];
        board.emit(`ping-read-${pin}`, duration);
      },
      [STEPPER](board) {
        const deviceNum = board.buffer[2];
        board.emit(`stepper-done-${deviceNum}`, true);
      },
      [ACCELSTEPPER](board) {
        const command = board.buffer[2];
        const deviceNum = board.buffer[3];
        const value = command === 6 || command === 10 ? decode32BitSignedInteger(board.buffer.slice(4, 9)) : null;
        if (command === 6) {
          board.emit(`stepper-position-${deviceNum}`, value);
        }
        if (command === 10) {
          board.emit(`stepper-done-${deviceNum}`, value);
        }
        if (command === 36) {
          board.emit(`multi-stepper-done-${deviceNum}`);
        }
      },
      [SERIAL_MESSAGE](board) {
        const command = board.buffer[2] & START_SYSEX;
        const portId = board.buffer[2] & 15;
        const reply = [];
        if (command === SERIAL_REPLY) {
          for (let i = 3, len = board.buffer.length; i < len - 1; i += 2) {
            reply.push(board.buffer[i + 1] << 7 | board.buffer[i]);
          }
          board.emit(`serial-data-${portId}`, reply);
        }
      }
    };
    var Transport = null;
    var Firmata = class extends Emitter {
      constructor(port, options, callback) {
        super();
        if (typeof options === "function" || typeof options === "undefined") {
          callback = options;
          options = {};
        }
        const board = this;
        const defaults = {
          reportVersionTimeout: 5e3,
          samplingInterval: 19,
          serialport: {
            baudRate: 57600,
            highWaterMark: 256,
            path: port
          }
        };
        const settings = Object.assign({}, defaults, options);
        this.isReady = false;
        this.MODES = {
          INPUT: 0,
          OUTPUT: 1,
          ANALOG: 2,
          PWM: 3,
          SERVO: 4,
          SHIFT: 5,
          I2C: 6,
          ONEWIRE: 7,
          STEPPER: 8,
          SERIAL: 10,
          PULLUP: 11,
          IGNORE: 127,
          PING_READ: 117,
          UNKOWN: 16
        };
        this.I2C_MODES = {
          WRITE: 0,
          READ: 1,
          CONTINUOUS_READ: 2,
          STOP_READING: 3
        };
        this.STEPPER = {
          TYPE: {
            DRIVER: 1,
            TWO_WIRE: 2,
            THREE_WIRE: 3,
            FOUR_WIRE: 4
          },
          STEP_SIZE: {
            WHOLE: 0,
            HALF: 1
          },
          RUN_STATE: {
            STOP: 0,
            ACCEL: 1,
            DECEL: 2,
            RUN: 3
          },
          DIRECTION: {
            CCW: 0,
            CW: 1
          }
        };
        this.SERIAL_MODES = {
          CONTINUOUS_READ: 0,
          STOP_READING: 1
        };
        this.SERIAL_PORT_IDs = {
          HW_SERIAL0: 0,
          HW_SERIAL1: 1,
          HW_SERIAL2: 2,
          HW_SERIAL3: 3,
          SW_SERIAL0: 8,
          SW_SERIAL1: 9,
          SW_SERIAL2: 16,
          SW_SERIAL3: 17,
          DEFAULT: 8
        };
        this.SERIAL_PIN_TYPES = {
          RES_RX0: 0,
          RES_TX0: 1,
          RES_RX1: 2,
          RES_TX1: 3,
          RES_RX2: 4,
          RES_TX2: 5,
          RES_RX3: 6,
          RES_TX3: 7
        };
        this.RESOLUTION = {
          ADC: null,
          DAC: null,
          PWM: null
        };
        this.HIGH = 1;
        this.LOW = 0;
        this.pins = [];
        this.ports = Array(16).fill(0);
        this.analogPins = [];
        this.version = {};
        this.firmware = {};
        this.buffer = [];
        this.versionReceived = false;
        this.name = "Firmata";
        this.settings = settings;
        this.pending = 0;
        this.digitalPortQueue = 0;
        if (typeof port === "object") {
          this.transport = port;
        } else {
          if (!Transport) {
            throw new Error("Missing Default Transport");
          }
          this.transport = new Transport(settings.serialport);
        }
        this.transport.on("close", (event) => {
          if (event && event.disconnected) {
            this.emit("disconnect");
            return;
          }
          this.emit("close");
        });
        this.transport.on("open", (event) => {
          this.emit("open", event);
          this.emit("connect", event);
        });
        this.transport.on("error", (error) => {
          if (!this.isReady && typeof callback === "function") {
            callback(error);
          } else {
            this.emit("error", error);
          }
        });
        this.transport.on("data", (data) => {
          for (let i = 0; i < data.length; i++) {
            let byte = data[i];
            if (this.buffer.length === 0 && byte === 0) {
              continue;
            } else {
              this.buffer.push(byte);
              let first = this.buffer[0];
              let last = this.buffer[this.buffer.length - 1];
              if (first === START_SYSEX && last === END_SYSEX) {
                let handler = SYSEX_RESPONSE[this.buffer[1]];
                if (handler && this.versionReceived) {
                  handler(this);
                }
                this.buffer.length = 0;
              } else if (first === START_SYSEX && this.buffer.length > 0) {
                let currByte = data[i];
                if (currByte > 127) {
                  this.buffer.length = 0;
                  this.buffer.push(currByte);
                }
              } else {
                if (first !== START_SYSEX) {
                  let response = first < START_SYSEX ? first & START_SYSEX : first;
                  if (response !== REPORT_VERSION && response !== ANALOG_MESSAGE && response !== DIGITAL_MESSAGE) {
                    this.buffer.length = 0;
                  }
                }
              }
              if (this.buffer.length === 3 && first !== START_SYSEX) {
                let response = first < START_SYSEX ? first & START_SYSEX : first;
                if (MIDI_RESPONSE[response]) {
                  if (this.versionReceived || first === REPORT_VERSION) {
                    this.versionReceived = true;
                    MIDI_RESPONSE[response](this);
                  }
                  this.buffer.length = 0;
                } else {
                  this.buffer.length = 0;
                }
              }
            }
          }
        });
        this.reportVersionTimeoutId = setTimeout(() => {
          if (this.versionReceived === false) {
            this.reportVersion(function() {
            });
            this.queryFirmware(function() {
            });
          }
        }, settings.reportVersionTimeout);
        function ready() {
          board.isReady = true;
          board.emit("ready");
          if (typeof callback === "function") {
            callback();
          }
        }
        this.once("reportversion", () => {
          clearTimeout(this.reportVersionTimeoutId);
          this.versionReceived = true;
          this.once("queryfirmware", () => {
            if (options.samplingInterval !== void 0) {
              this.setSamplingInterval(options.samplingInterval);
            }
            if (settings.skipCapabilities) {
              this.analogPins = settings.analogPins || this.analogPins;
              this.pins = settings.pins || this.pins;
              if (!this.pins.length) {
                for (var i = 0; i < (settings.pinCount || MAX_PIN_COUNT); i++) {
                  var supportedModes = [];
                  var analogChannel = this.analogPins.indexOf(i);
                  if (analogChannel < 0) {
                    analogChannel = 127;
                  }
                  this.pins.push({ supportedModes, analogChannel });
                }
              }
              this.RESOLUTION.ADC = 1023;
              this.RESOLUTION.PWM = 255;
              ready();
            } else {
              this.queryCapabilities(() => {
                this.queryAnalogMapping(ready);
              });
            }
          });
        });
      }
      reportVersion(callback) {
        this.once("reportversion", callback);
        writeToTransport(this, [REPORT_VERSION]);
      }
      queryFirmware(callback) {
        this.once("queryfirmware", callback);
        writeToTransport(this, [START_SYSEX, QUERY_FIRMWARE, END_SYSEX]);
      }
      analogRead(pin, callback) {
        this.reportAnalogPin(pin, 1);
        this.addListener(`analog-read-${pin}`, callback);
      }
      pwmWrite(pin, value) {
        let data;
        this.pins[pin].value = value;
        if (pin > 15) {
          data = [
            START_SYSEX,
            EXTENDED_ANALOG,
            pin,
            value & 127,
            value >> 7 & 127
          ];
          if (value > 16384) {
            data[data.length] = value >> 14 & 127;
          }
          if (value > 2097152) {
            data[data.length] = value >> 21 & 127;
          }
          if (value > 268435456) {
            data[data.length] = value >> 28 & 127;
          }
          data[data.length] = END_SYSEX;
        } else {
          data = [ANALOG_MESSAGE | pin, value & 127, value >> 7 & 127];
        }
        writeToTransport(this, data);
      }
      servoConfig(pin, min, max) {
        if (typeof pin === "object" && pin !== null) {
          let temp = pin;
          pin = temp.pin;
          min = temp.min;
          max = temp.max;
        }
        if (typeof pin === "undefined") {
          throw new Error("servoConfig: pin must be specified");
        }
        if (typeof min === "undefined") {
          throw new Error("servoConfig: min must be specified");
        }
        if (typeof max === "undefined") {
          throw new Error("servoConfig: max must be specified");
        }
        this.pins[pin].mode = this.MODES.SERVO;
        writeToTransport(this, [
          START_SYSEX,
          SERVO_CONFIG,
          pin,
          min & 127,
          min >> 7 & 127,
          max & 127,
          max >> 7 & 127,
          END_SYSEX
        ]);
      }
      servoWrite(...args) {
        this.analogWrite(...args);
      }
      pinMode(pin, mode) {
        if (mode === this.MODES.ANALOG) {
          this.pins[this.analogPins[pin]].mode = mode;
        } else {
          this.pins[pin].mode = mode;
          writeToTransport(this, [PIN_MODE, pin, mode]);
        }
      }
      digitalWrite(pin, value, enqueue) {
        let port = this.updateDigitalPort(pin, value);
        if (enqueue) {
          this.digitalPortQueue |= 1 << port;
        } else {
          this.writeDigitalPort(port);
        }
      }
      updateDigitalPort(pin, value) {
        const port = pin >> 3;
        const bit = 1 << (pin & 7);
        this.pins[pin].value = value;
        if (value) {
          this.ports[port] |= bit;
        } else {
          this.ports[port] &= ~bit;
        }
        return port;
      }
      flushDigitalPorts() {
        for (let i = 0; i < this.ports.length; i++) {
          if (this.digitalPortQueue >> i) {
            this.writeDigitalPort(i);
          }
        }
        this.digitalPortQueue = 0;
      }
      writeDigitalPort(port) {
        writeToTransport(this, [
          DIGITAL_MESSAGE | port,
          this.ports[port] & 127,
          this.ports[port] >> 7 & 127
        ]);
      }
      digitalRead(pin, callback) {
        this.reportDigitalPin(pin, 1);
        this.addListener(`digital-read-${pin}`, callback);
      }
      queryCapabilities(callback) {
        this.once("capability-query", callback);
        writeToTransport(this, [START_SYSEX, CAPABILITY_QUERY, END_SYSEX]);
      }
      queryAnalogMapping(callback) {
        this.once("analog-mapping-query", callback);
        writeToTransport(this, [START_SYSEX, ANALOG_MAPPING_QUERY, END_SYSEX]);
      }
      queryPinState(pin, callback) {
        this.once(`pin-state-${pin}`, callback);
        writeToTransport(this, [START_SYSEX, PIN_STATE_QUERY, pin, END_SYSEX]);
      }
      sendString(string) {
        const bytes = Buffer.from(`${string}\0`, "utf8");
        const data = [];
        data.push(START_SYSEX, STRING_DATA);
        for (let i = 0, length = bytes.length; i < length; i++) {
          data.push(bytes[i] & 127, bytes[i] >> 7 & 127);
        }
        data.push(END_SYSEX);
        writeToTransport(this, data);
      }
      sendI2CConfig(delay) {
        return this.i2cConfig(delay);
      }
      i2cConfig(options) {
        let settings = i2cActive.get(this);
        let delay;
        if (!settings) {
          settings = {};
          i2cActive.set(this, settings);
        }
        if (typeof options === "number") {
          delay = options;
        } else {
          if (typeof options === "object" && options !== null) {
            delay = Number(options.delay);
            if (typeof options.address !== "undefined") {
              if (!settings[options.address]) {
                settings[options.address] = {
                  stopTX: true
                };
              }
            }
            if (typeof options.settings !== "undefined") {
              Object.assign(settings[options.address], options.settings);
            }
          }
        }
        settings.delay = delay = delay || 0;
        i2cRequest(this, [
          START_SYSEX,
          I2C_CONFIG,
          delay & 255,
          delay >> 8 & 255,
          END_SYSEX
        ]);
        return this;
      }
      sendI2CWriteRequest(slaveAddress, bytes) {
        const data = [];
        bytes = bytes || [];
        data.push(START_SYSEX, I2C_REQUEST, slaveAddress, this.I2C_MODES.WRITE << 3);
        for (let i = 0, length = bytes.length; i < length; i++) {
          data.push(bytes[i] & 127, bytes[i] >> 7 & 127);
        }
        data.push(END_SYSEX);
        i2cRequest(this, data);
      }
      i2cWrite(address, registerOrData, inBytes) {
        const data = [START_SYSEX, I2C_REQUEST, address, this.I2C_MODES.WRITE << 3];
        if (arguments.length === 3 && !Array.isArray(registerOrData) && !Array.isArray(inBytes)) {
          return this.i2cWriteReg(address, registerOrData, inBytes);
        }
        if (arguments.length === 2) {
          if (Array.isArray(registerOrData)) {
            inBytes = registerOrData.slice();
            registerOrData = inBytes.shift();
          } else {
            inBytes = [];
          }
        }
        const bytes = Buffer.from([registerOrData].concat(inBytes));
        for (var i = 0, length = bytes.length; i < length; i++) {
          data.push(bytes[i] & 127, bytes[i] >> 7 & 127);
        }
        data.push(END_SYSEX);
        i2cRequest(this, data);
        return this;
      }
      i2cWriteReg(address, register, byte) {
        i2cRequest(this, [
          START_SYSEX,
          I2C_REQUEST,
          address,
          this.I2C_MODES.WRITE << 3,
          register & 127,
          register >> 7 & 127,
          byte & 127,
          byte >> 7 & 127,
          END_SYSEX
        ]);
        return this;
      }
      sendI2CReadRequest(address, numBytes, callback) {
        i2cRequest(this, [
          START_SYSEX,
          I2C_REQUEST,
          address,
          this.I2C_MODES.READ << 3,
          numBytes & 127,
          numBytes >> 7 & 127,
          END_SYSEX
        ]);
        this.once(`I2C-reply-${address}-0`, callback);
      }
      i2cRead(address, register, bytesToRead, callback) {
        if (arguments.length === 3 && typeof register === "number" && typeof bytesToRead === "function") {
          callback = bytesToRead;
          bytesToRead = register;
          register = null;
        }
        const data = [
          START_SYSEX,
          I2C_REQUEST,
          address,
          this.I2C_MODES.CONTINUOUS_READ << 3
        ];
        let event = `I2C-reply-${address}-`;
        if (register !== null) {
          data.push(register & 127, register >> 7 & 127);
        } else {
          register = 0;
        }
        event += register;
        data.push(bytesToRead & 127, bytesToRead >> 7 & 127, END_SYSEX);
        this.on(event, callback);
        i2cRequest(this, data);
        return this;
      }
      i2cStop(options) {
        if (options == null) {
          return;
        }
        if (typeof options === "number") {
          options = {
            address: options
          };
        }
        writeToTransport(this, [
          START_SYSEX,
          I2C_REQUEST,
          options.address,
          this.I2C_MODES.STOP_READING << 3,
          END_SYSEX
        ]);
        Object.keys(this._events).forEach((event) => {
          if (event.startsWith(`I2C-reply-${options.address}`)) {
            this.removeAllListeners(event);
          }
        });
      }
      i2cReadOnce(address, register, bytesToRead, callback) {
        if (arguments.length === 3 && typeof register === "number" && typeof bytesToRead === "function") {
          callback = bytesToRead;
          bytesToRead = register;
          register = null;
        }
        const data = [START_SYSEX, I2C_REQUEST, address, this.I2C_MODES.READ << 3];
        let event = `I2C-reply-${address}-`;
        if (register !== null) {
          data.push(register & 127, register >> 7 & 127);
        } else {
          register = 0;
        }
        event += register;
        data.push(bytesToRead & 127, bytesToRead >> 7 & 127, END_SYSEX);
        this.once(event, callback);
        i2cRequest(this, data);
        return this;
      }
      sendOneWireConfig(pin, enableParasiticPower) {
        writeToTransport(this, [
          START_SYSEX,
          ONEWIRE_DATA,
          ONEWIRE_CONFIG_REQUEST,
          pin,
          enableParasiticPower ? 1 : 0,
          END_SYSEX
        ]);
      }
      sendOneWireSearch(pin, callback) {
        this[SYM_sendOneWireSearch](ONEWIRE_SEARCH_REQUEST, `1-wire-search-reply-${pin}`, pin, callback);
      }
      sendOneWireAlarmsSearch(pin, callback) {
        this[SYM_sendOneWireSearch](ONEWIRE_SEARCH_ALARMS_REQUEST, `1-wire-search-alarms-reply-${pin}`, pin, callback);
      }
      [SYM_sendOneWireSearch](type, event, pin, callback) {
        writeToTransport(this, [START_SYSEX, ONEWIRE_DATA, type, pin, END_SYSEX]);
        const timeout = setTimeout(() => {
          callback(new Error("1-Wire device search timeout - are you running ConfigurableFirmata?"));
        }, 5e3);
        this.once(event, (devices) => {
          clearTimeout(timeout);
          callback(null, devices);
        });
      }
      sendOneWireRead(pin, device, numBytesToRead, callback) {
        const correlationId = Math.floor(Math.random() * 255);
        const timeout = setTimeout(() => {
          callback(new Error("1-Wire device read timeout - are you running ConfigurableFirmata?"));
        }, 5e3);
        this[SYM_sendOneWireRequest](pin, ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, null, `1-wire-read-reply-${correlationId}`, (data) => {
          clearTimeout(timeout);
          callback(null, data);
        });
      }
      sendOneWireReset(pin) {
        this[SYM_sendOneWireRequest](pin, ONEWIRE_RESET_REQUEST_BIT);
      }
      sendOneWireWrite(pin, device, data) {
        this[SYM_sendOneWireRequest](pin, ONEWIRE_WRITE_REQUEST_BIT, device, null, null, null, Array.isArray(data) ? data : [data]);
      }
      sendOneWireDelay(pin, delay) {
        this[SYM_sendOneWireRequest](pin, ONEWIRE_DELAY_REQUEST_BIT, null, null, null, delay);
      }
      sendOneWireWriteAndRead(pin, device, data, numBytesToRead, callback) {
        const correlationId = Math.floor(Math.random() * 255);
        const timeout = setTimeout(() => {
          callback(new Error("1-Wire device read timeout - are you running ConfigurableFirmata?"));
        }, 5e3);
        this[SYM_sendOneWireRequest](pin, ONEWIRE_WRITE_REQUEST_BIT | ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, Array.isArray(data) ? data : [data], `1-wire-read-reply-${correlationId}`, (data2) => {
          clearTimeout(timeout);
          callback(null, data2);
        });
      }
      [SYM_sendOneWireRequest](pin, subcommand, device, numBytesToRead, correlationId, delay, dataToWrite, event, callback) {
        const bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        if (device || numBytesToRead || correlationId || delay || dataToWrite) {
          subcommand = subcommand | ONEWIRE_WITHDATA_REQUEST_BITS;
        }
        if (device) {
          bytes.splice(...[0, 8].concat(device));
        }
        if (numBytesToRead) {
          bytes[8] = numBytesToRead & 255;
          bytes[9] = numBytesToRead >> 8 & 255;
        }
        if (correlationId) {
          bytes[10] = correlationId & 255;
          bytes[11] = correlationId >> 8 & 255;
        }
        if (delay) {
          bytes[12] = delay & 255;
          bytes[13] = delay >> 8 & 255;
          bytes[14] = delay >> 16 & 255;
          bytes[15] = delay >> 24 & 255;
        }
        if (dataToWrite) {
          bytes.push(...dataToWrite);
        }
        const output = [
          START_SYSEX,
          ONEWIRE_DATA,
          subcommand,
          pin,
          ...Encoder7Bit.to7BitArray(bytes),
          END_SYSEX
        ];
        writeToTransport(this, output);
        if (event && callback) {
          this.once(event, callback);
        }
      }
      setSamplingInterval(interval) {
        const safeint = interval < 10 ? 10 : interval > 65535 ? 65535 : interval;
        this.settings.samplingInterval = safeint;
        writeToTransport(this, [
          START_SYSEX,
          SAMPLING_INTERVAL,
          safeint & 127,
          safeint >> 7 & 127,
          END_SYSEX
        ]);
      }
      getSamplingInterval() {
        return this.settings.samplingInterval;
      }
      reportAnalogPin(pin, value) {
        if (value === 0 || value === 1) {
          this.pins[this.analogPins[pin]].report = value;
          writeToTransport(this, [REPORT_ANALOG | pin, value]);
        }
      }
      reportDigitalPin(pin, value) {
        const port = pin >> 3;
        if (value === 0 || value === 1) {
          this.pins[pin].report = value;
          writeToTransport(this, [REPORT_DIGITAL | port, value]);
        }
      }
      pingRead(options, callback) {
        if (!this.pins[options.pin].supportedModes.includes(PING_READ)) {
          throw new Error("Please upload PingFirmata to the board");
        }
        const { pin, value, pulseOut = 0, timeout = 1e6 } = options;
        writeToTransport(this, [
          START_SYSEX,
          PING_READ,
          pin,
          value,
          ...Firmata.encode([
            pulseOut >> 24 & 255,
            pulseOut >> 16 & 255,
            pulseOut >> 8 & 255,
            pulseOut & 255
          ]),
          ...Firmata.encode([
            timeout >> 24 & 255,
            timeout >> 16 & 255,
            timeout >> 8 & 255,
            timeout & 255
          ]),
          END_SYSEX
        ]);
        this.once(`ping-read-${pin}`, callback);
      }
      accelStepperConfig(options) {
        let {
          deviceNum,
          invertPins,
          motorPin1,
          motorPin2,
          motorPin3,
          motorPin4,
          enablePin,
          stepSize = this.STEPPER.STEP_SIZE.WHOLE,
          type = this.STEPPER.TYPE.FOUR_WIRE
        } = options;
        const data = [
          START_SYSEX,
          ACCELSTEPPER,
          0,
          deviceNum
        ];
        let iface = (type & 7) << 4 | (stepSize & 7) << 1;
        let pinsToInvert = 0;
        if (typeof enablePin !== "undefined") {
          iface = iface | 1;
        }
        data.push(iface);
        [
          "stepPin",
          "motorPin1",
          "directionPin",
          "motorPin2",
          "motorPin3",
          "motorPin4",
          "enablePin"
        ].forEach((pin) => {
          if (typeof options[pin] !== "undefined") {
            data.push(options[pin]);
          }
        });
        if (Array.isArray(invertPins)) {
          if (invertPins.includes(motorPin1)) {
            pinsToInvert |= 1;
          }
          if (invertPins.includes(motorPin2)) {
            pinsToInvert |= 2;
          }
          if (invertPins.includes(motorPin3)) {
            pinsToInvert |= 4;
          }
          if (invertPins.includes(motorPin4)) {
            pinsToInvert |= 8;
          }
          if (invertPins.includes(enablePin)) {
            pinsToInvert |= 16;
          }
        }
        data.push(pinsToInvert, END_SYSEX);
        writeToTransport(this, data);
      }
      accelStepperZero(deviceNum) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          1,
          deviceNum,
          END_SYSEX
        ]);
      }
      accelStepperStep(deviceNum, steps, callback) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          2,
          deviceNum,
          ...encode32BitSignedInteger(steps),
          END_SYSEX
        ]);
        if (callback) {
          this.once(`stepper-done-${deviceNum}`, callback);
        }
      }
      accelStepperTo(deviceNum, position, callback) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          3,
          deviceNum,
          ...encode32BitSignedInteger(position),
          END_SYSEX
        ]);
        if (callback) {
          this.once(`stepper-done-${deviceNum}`, callback);
        }
      }
      accelStepperEnable(deviceNum, enabled = true) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          4,
          deviceNum,
          enabled & 1,
          END_SYSEX
        ]);
      }
      accelStepperStop(deviceNum) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          5,
          deviceNum,
          END_SYSEX
        ]);
      }
      accelStepperReportPosition(deviceNum, callback) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          6,
          deviceNum,
          END_SYSEX
        ]);
        if (callback) {
          this.once(`stepper-position-${deviceNum}`, callback);
        }
      }
      accelStepperAcceleration(deviceNum, acceleration) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          8,
          deviceNum,
          ...encodeCustomFloat(acceleration),
          END_SYSEX
        ]);
      }
      accelStepperSpeed(deviceNum, speed) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          9,
          deviceNum,
          ...encodeCustomFloat(speed),
          END_SYSEX
        ]);
      }
      multiStepperConfig(options) {
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          32,
          options.groupNum,
          ...options.devices,
          END_SYSEX
        ]);
      }
      multiStepperTo(groupNum, positions, callback) {
        if (groupNum < 0 || groupNum > 5) {
          throw new RangeError(`Invalid "groupNum": ${groupNum}. Expected "groupNum" between 0-5`);
        }
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          33,
          groupNum,
          ...positions.reduce((a, b) => a.concat(...encode32BitSignedInteger(b)), []),
          END_SYSEX
        ]);
        if (callback) {
          this.once(`multi-stepper-done-${groupNum}`, callback);
        }
      }
      multiStepperStop(groupNum) {
        if (groupNum < 0 || groupNum > 5) {
          throw new RangeError(`Invalid "groupNum": ${groupNum}. Expected "groupNum" between 0-5`);
        }
        writeToTransport(this, [
          START_SYSEX,
          ACCELSTEPPER,
          35,
          groupNum,
          END_SYSEX
        ]);
      }
      stepperConfig(deviceNum, type, stepsPerRev, dirOrMotor1Pin, dirOrMotor2Pin, motorPin3, motorPin4) {
        writeToTransport(this, [
          START_SYSEX,
          STEPPER,
          0,
          deviceNum,
          type,
          stepsPerRev & 127,
          stepsPerRev >> 7 & 127,
          dirOrMotor1Pin,
          dirOrMotor2Pin,
          ...type === this.STEPPER.TYPE.FOUR_WIRE ? [motorPin3, motorPin4] : [],
          END_SYSEX
        ]);
      }
      stepperStep(deviceNum, direction, steps, speed, accel, decel, callback) {
        if (typeof accel === "function") {
          callback = accel;
          accel = 0;
          decel = 0;
        }
        writeToTransport(this, [
          START_SYSEX,
          STEPPER,
          1,
          deviceNum,
          direction,
          steps & 127,
          steps >> 7 & 127,
          steps >> 14 & 127,
          speed & 127,
          speed >> 7 & 127,
          ...accel > 0 || decel > 0 ? [accel & 127, accel >> 7 & 127, decel & 127, decel >> 7 & 127] : [],
          END_SYSEX
        ]);
        if (callback) {
          this.once(`stepper-done-${deviceNum}`, callback);
        }
      }
      serialConfig(options) {
        let portId;
        let baud;
        let rxPin;
        let txPin;
        if (typeof options === "object" && options !== null) {
          portId = options.portId;
          baud = options.baud;
          rxPin = options.rxPin;
          txPin = options.txPin;
        }
        if (typeof portId === "undefined") {
          throw new Error("portId must be specified, see SERIAL_PORT_IDs for options.");
        }
        baud = baud || 57600;
        const data = [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_CONFIG | portId,
          baud & 127,
          baud >> 7 & 127,
          baud >> 14 & 127
        ];
        if (portId > 7 && typeof rxPin !== "undefined" && typeof txPin !== "undefined") {
          data.push(rxPin, txPin);
        } else if (portId > 7) {
          throw new Error("Both RX and TX pins must be defined when using Software Serial.");
        }
        data.push(END_SYSEX);
        writeToTransport(this, data);
      }
      serialWrite(portId, bytes) {
        const data = [START_SYSEX, SERIAL_MESSAGE, SERIAL_WRITE | portId];
        for (let i = 0, len = bytes.length; i < len; i++) {
          data.push(bytes[i] & 127, bytes[i] >> 7 & 127);
        }
        data.push(END_SYSEX);
        if (bytes.length > 0) {
          writeToTransport(this, data);
        }
      }
      serialRead(portId, maxBytesToRead, callback) {
        const data = [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_READ | portId,
          this.SERIAL_MODES.CONTINUOUS_READ
        ];
        if (arguments.length === 2 && typeof maxBytesToRead === "function") {
          callback = maxBytesToRead;
        } else {
          data.push(maxBytesToRead & 127, maxBytesToRead >> 7 & 127);
        }
        data.push(END_SYSEX);
        writeToTransport(this, data);
        this.on(`serial-data-${portId}`, callback);
      }
      serialStop(portId) {
        writeToTransport(this, [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_READ | portId,
          this.SERIAL_MODES.STOP_READING,
          END_SYSEX
        ]);
        this.removeAllListeners(`serial-data-${portId}`);
      }
      serialClose(portId) {
        writeToTransport(this, [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_CLOSE | portId,
          END_SYSEX
        ]);
      }
      serialFlush(portId) {
        writeToTransport(this, [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_FLUSH | portId,
          END_SYSEX
        ]);
      }
      serialListen(portId) {
        if (portId < 8) {
          return;
        }
        writeToTransport(this, [
          START_SYSEX,
          SERIAL_MESSAGE,
          SERIAL_LISTEN | portId,
          END_SYSEX
        ]);
      }
      sysexResponse(commandByte, handler) {
        if (Firmata.SYSEX_RESPONSE[commandByte]) {
          throw new Error(`${commandByte} is not an available SYSEX_RESPONSE byte`);
        }
        Firmata.SYSEX_RESPONSE[commandByte] = (board) => handler.call(board, board.buffer.slice(2, -1));
        return this;
      }
      clearSysexResponse(commandByte) {
        if (Firmata.SYSEX_RESPONSE[commandByte]) {
          delete Firmata.SYSEX_RESPONSE[commandByte];
        }
      }
      sysexCommand(message) {
        if (!message || !message.length) {
          throw new Error("Sysex Command cannot be empty");
        }
        writeToTransport(this, [START_SYSEX, ...message.slice(), END_SYSEX]);
        return this;
      }
      reset() {
        writeToTransport(this, [SYSTEM_RESET]);
      }
      static isAcceptablePort(port) {
        let rport = /usb|acm|^com/i;
        if (rport.test(port.path)) {
          return true;
        }
        return false;
      }
      static requestPort(callback) {
        if (!Transport || Transport && typeof Transport.list !== "function") {
          process.nextTick(() => {
            callback(new Error("No Transport provided"), null);
          });
          return;
        }
        Transport.list().then((ports) => {
          const port = ports.find((port2) => Firmata.isAcceptablePort(port2) && port2);
          if (port) {
            callback(null, port);
          } else {
            callback(new Error("No Acceptable Port Found"), null);
          }
        }).catch((error) => {
          callback(error, null);
        });
      }
      static encode(data) {
        const encoded = [];
        const length = data.length;
        for (let i = 0; i < length; i++) {
          encoded.push(data[i] & 127, data[i] >> 7 & 127);
        }
        return encoded;
      }
      static decode(data) {
        const decoded = [];
        if (data.length % 2 !== 0) {
          throw new Error("Firmata.decode(data) called with odd number of data bytes");
        }
        while (data.length) {
          const lsb = data.shift();
          const msb = data.shift();
          decoded.push(lsb | msb << 7);
        }
        return decoded;
      }
    };
    Firmata.prototype.analogWrite = Firmata.prototype.pwmWrite;
    Firmata.Board = Firmata;
    Firmata.SYSEX_RESPONSE = SYSEX_RESPONSE;
    Firmata.MIDI_RESPONSE = MIDI_RESPONSE;
    function writeToTransport(board, data) {
      board.pending++;
      board.transport.write(Buffer.from(data), () => board.pending--);
    }
    function i2cRequest(board, bytes) {
      const active = i2cActive.get(board);
      if (!active) {
        throw new Error("I2C is not enabled for this board. To enable, call the i2cConfig() method.");
      }
      if (bytes[1] === I2C_REQUEST) {
        const address = bytes[2];
        if (!active[address]) {
          active[address] = {
            stopTX: true
          };
        }
        if (bytes[3] & I2C_READ_MASK) {
          bytes[3] |= Number(!active[address].stopTX) << 6;
        }
      }
      writeToTransport(board, bytes);
    }
    function encode32BitSignedInteger(data) {
      const negative = data < 0;
      data = Math.abs(data);
      const encoded = [
        data & 127,
        data >> 7 & 127,
        data >> 14 & 127,
        data >> 21 & 127,
        data >> 28 & 7
      ];
      if (negative) {
        encoded[encoded.length - 1] |= 8;
      }
      return encoded;
    }
    function decode32BitSignedInteger(bytes) {
      let result = bytes[0] & 127 | (bytes[1] & 127) << 7 | (bytes[2] & 127) << 14 | (bytes[3] & 127) << 21 | (bytes[4] & 7) << 28;
      if (bytes[4] >> 3) {
        result *= -1;
      }
      return result;
    }
    var MAX_SIGNIFICAND = Math.pow(2, 23);
    function encodeCustomFloat(input) {
      const sign = input < 0 ? 1 : 0;
      input = Math.abs(input);
      const base10 = Math.floor(Math.log10(input));
      let exponent = 0 + base10;
      input /= Math.pow(10, base10);
      while (!Number.isInteger(input) && input < MAX_SIGNIFICAND) {
        exponent -= 1;
        input *= 10;
      }
      while (input > MAX_SIGNIFICAND) {
        exponent += 1;
        input /= 10;
      }
      input = Math.trunc(input);
      exponent += 11;
      const encoded = [
        input & 127,
        input >> 7 & 127,
        input >> 14 & 127,
        input >> 21 & 3 | (exponent & 15) << 2 | (sign & 1) << 6
      ];
      return encoded;
    }
    function decodeCustomFloat(input) {
      const exponent = (input[3] >> 2 & 15) - 11;
      const sign = input[3] >> 6 & 1;
      let result = input[0] | input[1] << 7 | input[2] << 14 | (input[3] & 3) << 21;
      if (sign) {
        result *= -1;
      }
      return result * Math.pow(10, exponent);
    }
    if (process.env.IS_TEST_MODE) {
      let transport = null;
      Firmata.test = {
        i2cPeripheralSettings(board) {
          return i2cActive.get(board);
        },
        get i2cActive() {
          return i2cActive;
        },
        set transport(value) {
          transport = Transport;
          Transport = value;
        },
        restoreTransport() {
          Transport = transport;
        },
        encode32BitSignedInteger,
        decode32BitSignedInteger,
        encodeCustomFloat,
        decodeCustomFloat,
        writeToTransport,
        symbols: {
          SYM_sendOneWireRequest,
          SYM_sendOneWireSearch
        }
      };
    }
    var bindTransport = function(transport) {
      Transport = transport;
      return Firmata;
    };
    bindTransport.Firmata = Firmata;
    module2.exports = bindTransport;
  }
});

// node_modules/firmata/lib/com.js
var require_com = __commonJS({
  "node_modules/firmata/lib/com.js"(exports, module2) {
    "use strict";
    var Emitter = require("events");
    var TransportStub = class extends Emitter {
      constructor(path) {
        super();
        this.isOpen = true;
        this.baudRate = 0;
        this.path = path;
      }
      write(buffer) {
        if (Buffer.isBuffer(buffer)) {
          buffer = Array.from(buffer);
        }
        this.lastWrite = buffer;
        this.emit("write", buffer);
      }
      static list() {
        return Promise.resolve([]);
      }
    };
    TransportStub.SerialPort = TransportStub;
    var com;
    var error;
    var SerialPort;
    try {
      if (process.env.IS_TEST_MODE) {
        com = TransportStub;
      } else {
        SerialPort = require_dist17().SerialPort;
        com = SerialPort;
      }
    } catch (err) {
      error = err;
    }
    if (com == null) {
      if (process.env.IS_TEST_MODE) {
        com = TransportStub;
      } else {
        console.log("It looks like serialport didn't install properly.");
        console.log("More information can be found here https://serialport.io/docs/guide-installation");
        console.log(`The result of requiring the package is: ${SerialPort}`);
        console.log(error);
        throw "Missing serialport dependency";
      }
    }
    module2.exports = com;
  }
});

// node_modules/firmata/lib/firmata.js
var require_firmata = __commonJS({
  "node_modules/firmata/lib/firmata.js"(exports, module2) {
    "use strict";
    module2.exports = require_firmata_io()(require_com());
  }
});

// node_modules/johnny-five/lib/sleep.js
var require_sleep = __commonJS({
  "node_modules/johnny-five/lib/sleep.js"(exports, module2) {
    var sleep = {
      micro(us) {
        const start = process.hrtime();
        let waited = 0;
        let delta;
        while (us > waited) {
          delta = process.hrtime(start);
          waited = (delta[0] * 1e9 + delta[1]) / 1e3;
        }
      },
      milli(ms) {
        sleep.micro(ms * 1e3);
      }
    };
    module2.exports = sleep;
  }
});

// node_modules/johnny-five/lib/expander.js
var require_expander = __commonJS({
  "node_modules/johnny-five/lib/expander.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var sleep = require_sleep();
    var Fn = require_fn();
    var priv = new Map();
    var active = new Map();
    var Base = class extends Emitter {
      constructor() {
        super();
        this.HIGH = 1;
        this.LOW = 0;
        this.isReady = false;
        this.MODES = {};
        this.pins = [];
        this.analogPins = [];
      }
    };
    var Controllers = {
      DEFAULT: {
        initialize: {
          value() {
            throw new Error("Expander expects a valid controller");
          }
        }
      },
      MCP23017: {
        ADDRESSES: {
          value: [32]
        },
        REGISTER: {
          value: {
            IODIRA: 0,
            GPPUA: 12,
            GPIOA: 18,
            OLATA: 20,
            IODIRB: 1,
            GPPUB: 13,
            GPIOB: 19,
            OLATB: 21
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.iodir = [255, 255];
            state.olat = [255, 255];
            state.gpio = [255, 255];
            state.gppu = [0, 0];
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            this.io.i2cWrite(this.address, [this.REGISTER.IODIRA, state.iodir[this.REGISTER.IODIRA]]);
            this.io.i2cWrite(this.address, [this.REGISTER.IODIRB, state.iodir[this.REGISTER.IODIRB]]);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 16; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.INPUT,
                  this.MODES.OUTPUT
                ],
                mode: 0,
                value: 0,
                report: 0,
                analogChannel: 127
              });
              this.pinMode(i, this.MODES.OUTPUT);
              this.digitalWrite(i, this.LOW);
            }
            this.name = "MCP23017";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const state = priv.get(this);
            const pinIndex = pin;
            let port = 0;
            let iodir = null;
            if (pin < 8) {
              port = this.REGISTER.IODIRA;
            } else {
              port = this.REGISTER.IODIRB;
              pin -= 8;
            }
            iodir = state.iodir[port];
            if (mode === this.io.MODES.INPUT) {
              iodir |= 1 << pin;
            } else {
              iodir &= ~(1 << pin);
            }
            this.pins[pinIndex].mode = mode;
            this.io.i2cWrite(this.address, [port, iodir]);
            state.iodir[port] = iodir;
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = pin;
            let port = 0;
            let gpio = 0;
            let gpioaddr = 0;
            if (pin < 8) {
              port = this.REGISTER.IODIRA;
              gpioaddr = this.REGISTER.GPIOA;
            } else {
              port = this.REGISTER.IODIRB;
              gpioaddr = this.REGISTER.GPIOB;
              pin -= 8;
            }
            gpio = state.olat[port];
            if (value === this.io.HIGH) {
              gpio |= 1 << pin;
            } else {
              gpio &= ~(1 << pin);
            }
            this.pins[pinIndex].report = 0;
            this.pins[pinIndex].value = value;
            this.io.i2cWrite(this.address, [gpioaddr, gpio]);
            state.olat[port] = gpio;
            state.gpio[port] = gpio;
          }
        },
        pullUp: {
          value(pin, value) {
            const state = priv.get(this);
            let port = 0;
            let gppu = 0;
            let gppuaddr = 0;
            if (pin < 8) {
              port = this.REGISTER.IODIRA;
              gppuaddr = this.REGISTER.GPPUA;
            } else {
              port = this.REGISTER.IODIRB;
              gppuaddr = this.REGISTER.GPPUB;
              pin -= 8;
            }
            gppu = state.gppu[port];
            if (value === this.io.HIGH) {
              gppu |= 1 << pin;
            } else {
              gppu &= ~(1 << pin);
            }
            this.io.i2cWrite(this.address, [gppuaddr, gppu]);
            state.gppu[port] = gppu;
          }
        },
        digitalRead: {
          value(pin, callback) {
            const pinIndex = pin;
            let gpioaddr = 0;
            if (pin < 8) {
              gpioaddr = this.REGISTER.GPIOA;
            } else {
              gpioaddr = this.REGISTER.GPIOB;
              pin -= 8;
            }
            this.pins[pinIndex].report = 1;
            this.on(`digital-read-${pinIndex}`, callback);
            this.io.i2cRead(this.address, gpioaddr, 1, (data) => {
              const byte = data[0];
              const value = byte >> pin & 1;
              this.pins[pinIndex].value = value;
              this.emit(`digital-read-${pinIndex}`, value);
            });
          }
        }
      },
      MCP23008: {
        ADDRESSES: {
          value: [32]
        },
        REGISTER: {
          value: {
            IODIR: 0,
            GPPU: 6,
            GPIO: 9,
            OLAT: 10
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.iodir = [255];
            state.olat = [255];
            state.gpio = [255];
            state.gppu = [0];
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            this.io.i2cWrite(this.address, [this.REGISTER.IODIR, state.iodir[this.REGISTER.IODIR]]);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 8; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.INPUT,
                  this.MODES.OUTPUT
                ],
                mode: 0,
                value: 0,
                report: 0,
                analogChannel: 127
              });
              this.pinMode(i, this.MODES.OUTPUT);
              this.digitalWrite(i, this.LOW);
            }
            this.name = "MCP23008";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const state = priv.get(this);
            const pinIndex = pin;
            const port = this.REGISTER.IODIR;
            let iodir = state.iodir[port];
            if (mode === this.io.MODES.INPUT) {
              iodir |= 1 << pin;
            } else {
              iodir &= ~(1 << pin);
            }
            this.pins[pinIndex].mode = mode;
            this.io.i2cWrite(this.address, [port, iodir]);
            state.iodir[port] = iodir;
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = pin;
            const port = this.REGISTER.IODIR;
            const gpioaddr = this.REGISTER.GPIO;
            let gpio = state.olat[port];
            if (value === this.io.HIGH) {
              gpio |= 1 << pin;
            } else {
              gpio &= ~(1 << pin);
            }
            this.pins[pinIndex].report = 0;
            this.pins[pinIndex].value = value;
            this.io.i2cWrite(this.address, [gpioaddr, gpio]);
            state.olat[port] = gpio;
            state.gpio[port] = gpio;
          }
        },
        pullUp: {
          value(pin, value) {
            const state = priv.get(this);
            const port = this.REGISTER.IODIR;
            const gppuaddr = this.REGISTER.GPPU;
            let gppu = state.gppu[port];
            if (value === this.io.HIGH) {
              gppu |= 1 << pin;
            } else {
              gppu &= ~(1 << pin);
            }
            this.io.i2cWrite(this.address, [gppuaddr, gppu]);
            state.gppu[port] = gppu;
          }
        },
        digitalRead: {
          value(pin, callback) {
            const pinIndex = pin;
            const gpioaddr = this.REGISTER.GPIO;
            this.pins[pinIndex].report = 1;
            this.on(`digital-read-${pin}`, callback);
            this.io.i2cRead(this.address, gpioaddr, 1, (data) => {
              const byte = data[0];
              const value = byte >> pin & 1;
              this.pins[pinIndex].value = value;
              this.emit(`digital-read-${pin}`, value);
            });
          }
        }
      },
      PCF8574: {
        ADDRESSES: {
          value: [32]
        },
        REGISTER: {},
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.port = 0;
            state.ddr = 0;
            state.pins = 0;
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 8; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.INPUT,
                  this.MODES.OUTPUT
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: 127
              });
              this.pinMode(i, this.MODES.OUTPUT);
              this.digitalWrite(i, this.LOW);
            }
            this.name = "PCF8574";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const state = priv.get(this);
            const pinIndex = pin;
            let port = state.port;
            let ddr = state.ddr;
            const pins = state.pins;
            if (mode === this.MODES.INPUT) {
              ddr &= ~(1 << pin);
              port &= ~(1 << pin);
            } else {
              ddr |= 1 << pin;
              port &= ~(1 << pin);
            }
            this.pins[pinIndex].mode = mode;
            state.port = port;
            state.ddr = ddr;
            this.io.i2cWrite(this.address, pins & ~ddr | port);
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = pin;
            let port = state.port;
            const ddr = state.ddr;
            const pins = state.pins;
            if (value) {
              port |= 1 << pin;
            } else {
              port &= ~(1 << pin);
            }
            this.pins[pinIndex].report = 0;
            this.pins[pinIndex].value = value;
            state.port = port;
            this.io.i2cWrite(this.address, pins & ~ddr | port);
          }
        },
        digitalRead: {
          value(pin, callback) {
            const state = priv.get(this);
            const pinIndex = pin;
            this.pins[pinIndex].report = 1;
            this.on(`digital-read-${pin}`, callback);
            this.io.i2cRead(this.address, 1, (data) => {
              const byte = data[0];
              const value = byte >> pin & 1;
              state.pins = byte;
              this.pins[pinIndex].value = value;
              this.emit(`digital-read-${pin}`, value);
            });
          }
        }
      },
      PCF8575: {
        ADDRESSES: {
          value: [32]
        },
        REGISTER: {},
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.port = [0, 1];
            state.gpio = [0, 0];
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 16; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.INPUT,
                  this.MODES.OUTPUT
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: 127
              });
              this.pinMode(i, this.MODES.OUTPUT);
              this.digitalWrite(i, this.LOW);
            }
            this.io.i2cWrite(this.address, state.gpio);
            this.name = "PCF8575";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const pinIndex = pin;
            this.pins[pinIndex].mode = mode;
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = pin;
            let port;
            if (pin < 8) {
              port = 0;
            } else {
              port = 1;
              pin -= 8;
            }
            if (value === this.io.HIGH) {
              state.gpio[port] |= 1 << pin;
            } else {
              state.gpio[port] &= ~(1 << pin);
            }
            this.pins[pinIndex].report = 0;
            this.pins[pinIndex].value = value;
            this.io.i2cWrite(this.address, state.gpio);
          }
        },
        digitalRead: {
          value(pin, callback) {
            const pinIndex = pin;
            let port;
            if (pin < 8) {
              port = 0;
            } else {
              port = 1;
              pin -= 8;
            }
            this.pins[pinIndex].report = 1;
            this.on(`digital-read-${pin}`, callback);
            this.io.i2cRead(this.address, 2, (data) => {
              const byte = data[port];
              const value = byte >> pin & 1;
              this.pins[pinIndex].value = value;
              this.emit(`digital-read-${pin}`, value);
            });
          }
        }
      },
      PCA9685: {
        ADDRESSES: {
          value: [64]
        },
        REGISTER: {
          value: {
            MODE1: 0,
            PRESCALE: 254,
            BASE: 6
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.frequency = Fn.constrain(options.frequency || 1526, 24, 1526);
            this.address = options.address || this.ADDRESSES[0];
            this.pwmRange = options.pwmRange || [0, 4095];
            Object.defineProperties(this, {
              prescale: {
                get() {
                  return Math.round(25e6 / (4096 * state.frequency)) - 1;
                }
              },
              frequency: {
                get() {
                  return state.frequency;
                }
              }
            });
            options.address = this.address;
            this.io.i2cConfig(options);
            this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0);
            this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 16);
            this.io.i2cWriteReg(this.address, this.REGISTER.PRESCALE, this.prescale);
            this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 0);
            sleep.micro(5);
            this.io.i2cWriteReg(this.address, this.REGISTER.MODE1, 160);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 16; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.OUTPUT,
                  this.MODES.PWM,
                  this.MODES.SERVO
                ],
                mode: 0,
                value: 0,
                report: 0,
                analogChannel: 127
              });
              this.pinMode(i, this.MODES.OUTPUT);
              this.digitalWrite(i, this.LOW);
            }
            this.name = "PCA9685";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return this.io.name.includes("Tessel 2") ? pin - 1 : pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            if (this.pins[pin] === void 0) {
              throw new RangeError(`Invalid PCA9685 pin: ${pin}`);
            }
            this.pins[pin].mode = mode;
          }
        },
        digitalWrite: {
          value(pin, value) {
            this.pwmWrite(pin, value ? 255 : 0);
          }
        },
        analogWrite: {
          value(pin, value) {
            this.pwmWrite(pin, value);
          }
        },
        servoWrite: {
          value(pin, value) {
            let off;
            if (value < 544) {
              value = Fn.constrain(value, 0, 180);
              off = Fn.map(value, 0, 180, this.pwmRange[0] / 4, this.pwmRange[1] / 4);
            } else {
              off = value / 4;
            }
            off |= 0;
            this.io.i2cWrite(this.address, [
              this.REGISTER.BASE + 4 * pin,
              0,
              0,
              off,
              off >> 8
            ]);
          }
        },
        pwmWrite: {
          value(pin, value) {
            if (this.pins[pin] === void 0) {
              throw new RangeError(`Invalid PCA9685 pin: ${pin}`);
            }
            value = Fn.constrain(value, 0, 255);
            let on = 0;
            let off = this.pwmRange[1] * value / 255;
            if (value === 0) {
              on = 0;
              off = 4096;
            }
            if (value === 255) {
              on = 4096;
              off = 0;
            }
            this.io.i2cWrite(this.address, [
              this.REGISTER.BASE + 4 * pin,
              on,
              on >> 8,
              off,
              off >> 8
            ]);
            this.pins[pin].value = value;
          }
        }
      },
      PCF8591: {
        ADDRESSES: {
          value: [72]
        },
        REGISTER: {},
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.control = 69;
            state.reading = false;
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 4; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.ANALOG
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: i
              });
            }
            this.analogPins.push(0, 1, 2, 3);
            this.io.i2cWrite(this.address, state.control);
            this.name = "PCF8591";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            if (typeof pin === "string" && pin[0] === "A") {
              return +pin.slice(1);
            }
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            this.pins[pin].mode = mode;
          }
        },
        analogRead: {
          value(pin, callback) {
            const state = priv.get(this);
            const pinIndex = pin;
            this.pins[pinIndex].report = 1;
            this.on(`analog-read-${pin}`, callback);
            if (!state.reading) {
              state.reading = true;
              this.io.i2cRead(this.address, 4, (data) => {
                let value;
                for (let i = 0; i < 4; i++) {
                  value = data[i] << 2;
                  this.pins[i].value = value;
                  if (this.pins[i].report) {
                    this.emit(`analog-read-${i}`, value);
                  }
                }
              });
            }
          }
        }
      },
      MUXSHIELD2: {
        initialize: {
          value() {
            const state = priv.get(this);
            state.select = [2, 4, 6, 7];
            state.ios = [null, 10, 11, 12];
            state.io = [null, 14, 15, 16];
            state.aio = [null, 0, 1, 2];
            state.outMode = 8;
            state.pinMap = {};
            state.rowReading = [false, false, false];
            state.rowMode = [null, null, null];
            state.rowValues = [0, 0, 0];
            Object.assign(this.MODES, {
              INPUT: 0,
              OUTPUT: 1,
              ANALOG: 2
            });
            this.io.pinMode(state.select[0], this.MODES.OUTPUT);
            this.io.pinMode(state.select[1], this.MODES.OUTPUT);
            this.io.pinMode(state.select[2], this.MODES.OUTPUT);
            this.io.pinMode(state.select[3], this.MODES.OUTPUT);
            this.io.pinMode(state.outMode, this.MODES.OUTPUT);
            this.io.digitalWrite(state.outMode, this.LOW);
            this.io.pinMode(state.ios[1], this.MODES.OUTPUT);
            this.io.pinMode(state.ios[2], this.MODES.OUTPUT);
            this.io.pinMode(state.ios[3], this.MODES.OUTPUT);
            let row = 1;
            let mask = 16;
            let index = 0;
            for (let i = 0; i < 48; i++) {
              const band = i & mask;
              if (band === mask) {
                row++;
                mask *= 2;
                index = 0;
              }
              state.pinMap[`IO${row}-${index}`] = i;
              this.pins.push({
                row,
                index,
                supportedModes: [
                  this.MODES.INPUT,
                  this.MODES.OUTPUT,
                  this.MODES.ANALOG
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: i
              });
              this.analogPins.push(i);
              index++;
            }
            this.name = "MUXSHIELD2";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            if (pinIndex === void 0) {
              throw new Error(`MUXSHIELD2: Invalid Pin number or name: ${pin}`);
            }
            const row = this.pins[pinIndex].row;
            const rowModeIndex = row - 1;
            const rowMode = state.rowMode[rowModeIndex];
            if (rowMode === mode) {
              return this;
            }
            if (rowMode !== null && rowMode !== mode) {
              throw new Error("MUXSHIELD2: Cannot set mixed modes per IO row.");
            }
            state.rowMode[rowModeIndex] = mode;
            for (let i = 0; i < 16; i++) {
              this.pins[rowModeIndex + i].mode = mode;
            }
            const IO = state.io[row];
            const IOS = state.ios[row];
            if (mode === this.MODES.INPUT) {
              this.io.pinMode(IO, this.MODES.INPUT);
            }
            if (mode === this.MODES.OUTPUT) {
              this.io.pinMode(IO, this.MODES.OUTPUT);
              this.io.digitalWrite(IOS, this.HIGH);
            }
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            if (pinIndex === void 0) {
              throw new Error(`MUXSHIELD2: Invalid Pin number or name: ${pin}`);
            }
            const row = this.pins[pinIndex].row;
            const rowValueIndex = row - 1;
            let rowValue = state.rowValues[rowValueIndex];
            const ioPin = row - 1;
            const offset = ioPin * 16;
            const channel = pinIndex - offset;
            if (value) {
              rowValue |= 1 << channel;
            } else {
              rowValue &= ~(1 << channel);
            }
            this.io.digitalWrite(state.select[3], this.LOW);
            this.io.digitalWrite(state.outMode, this.HIGH);
            const S = state.select[row - 1];
            const IO = state.io[row];
            for (let i = 15; i >= 0; i--) {
              this.io.digitalWrite(S, this.LOW);
              this.io.digitalWrite(IO, rowValue >> i & 1);
              this.io.digitalWrite(S, this.HIGH);
            }
            this.io.digitalWrite(state.select[3], this.HIGH);
            this.io.digitalWrite(state.outMode, this.LOW);
            this.pins[pinIndex].value = value;
            state.rowValues[rowValueIndex] = rowValue;
          }
        },
        digitalRead: {
          value(pin, callback) {
            this.ioRead("digital", pin, callback);
          }
        },
        analogRead: {
          value(pin, callback) {
            this.ioRead("analog", pin, callback);
          }
        },
        ioRead: {
          value(type, pin, callback) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            if (pinIndex === void 0) {
              throw new Error(`MUXSHIELD2: Invalid Pin number or name: ${pin}`);
            }
            this.on(`${type}-read-${pinIndex}`, callback);
            const isAnalog = type === "analog" ? true : false;
            const row = this.pins[pinIndex].row;
            const rowReadingIndex = row - 1;
            const offset = rowReadingIndex * 16;
            const channel = pinIndex - offset;
            this.pins[pinIndex].report = 1;
            this.pins[pinIndex].channel = channel;
            this.pins[pinIndex].ioPin = isAnalog ? rowReadingIndex : rowReadingIndex + 14;
            const nextPinIndex = () => {
              const startAt = nextPinIndex.lastPinIndex + 1;
              for (let i = startAt; i < this.pins.length; i++) {
                if (this.pins[i].report === 1) {
                  nextPinIndex.lastPinIndex = i;
                  return nextPinIndex.lastPinIndex;
                }
              }
              nextPinIndex.lastPinIndex = -1;
              return nextPinIndex();
            };
            nextPinIndex.lastPinIndex = -1;
            const handler = (value) => {
              const pinIndex2 = nextPinIndex.lastPinIndex;
              const pin2 = this.pins[pinIndex2];
              this.emit(`${type}-read-${pinIndex2}`, value);
              this.io.removeListener(`${type}-read-${pin2.ioPin}`, handler);
              setTimeout(read, 10);
            };
            var read = () => {
              const pinIndex2 = nextPinIndex();
              const pin2 = this.pins[pinIndex2];
              this.select(pin2.channel);
              if (isAnalog) {
                this.io.pinMode(pin2.ioPin, this.io.MODES.ANALOG);
                this.io.analogRead(pin2.ioPin, handler);
              } else {
                this.io.digitalRead(pin2.ioPin, handler);
              }
            };
            if (!state.rowReading[rowReadingIndex]) {
              state.rowReading[rowReadingIndex] = true;
              read();
            }
          }
        },
        select: {
          value(channel) {
            const state = priv.get(this);
            this.io.digitalWrite(state.outMode, this.LOW);
            this.io.digitalWrite(state.select[0], channel & 1);
            this.io.digitalWrite(state.select[1], (channel & 3) >> 1);
            this.io.digitalWrite(state.select[2], (channel & 7) >> 2);
            this.io.digitalWrite(state.select[3], (channel & 15) >> 3);
          }
        }
      },
      GROVEPI: {
        ADDRESSES: {
          value: [4]
        },
        REGISTER: {},
        COMMANDS: {
          value: {
            DIGITAL_READ: 1,
            DIGITAL_WRITE: 2,
            ANALOG_READ: 3,
            ANALOG_WRITE: 4,
            PIN_MODE: 5,
            PING_READ: 7
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.isReading = false;
            state.pinMap = {
              D2: 2,
              D3: 3,
              D4: 4,
              D5: 5,
              D6: 6,
              D7: 7,
              D8: 8,
              A0: 14,
              A1: 15,
              A2: 16
            };
            this.isPwm = (name) => {
              const number = typeof name === "number" ? name : parseInt(name[1]);
              return number === 3 || number === 5 || number === 6;
            };
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            let analogChannel;
            for (let i = 0; i < 17; i++) {
              analogChannel = 127;
              if (i <= 1 || i >= 9 && i < 14) {
                this.pins.push({
                  supportedModes: [],
                  mode: 0,
                  value: 0,
                  report: 0,
                  analogChannel
                });
              } else {
                this.pins.push({
                  supportedModes: [
                    this.MODES.INPUT,
                    this.MODES.OUTPUT
                  ],
                  mode: 0,
                  value: 0,
                  report: 0,
                  analogChannel
                });
                if (this.isPwm(i)) {
                  this.pins[i].supportedModes.push(this.MODES.PWM);
                }
                if (i >= 14 && i <= 17) {
                  this.pins[i].analogChannel = i - 14;
                  this.pins[i].supportedModes.push(this.MODES.ANALOG);
                  this.analogPins.push(i);
                  this.pinMode(`A${this.pins[i].analogChannel}`, this.MODES.ANALOG);
                } else {
                  this.pinMode(`D${i}`, this.MODES.OUTPUT);
                  this.digitalWrite(`D${i}`, this.LOW);
                }
              }
            }
            this.name = "GROVEPI";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            if (mode === this.io.MODES.INPUT || mode === this.io.MODES.ANALOG) {
              this.pins[pinIndex].mode = 0;
            } else {
              this.pins[pinIndex].mode = 1;
            }
            this.io.i2cWrite(this.address, [
              this.COMMANDS.PIN_MODE,
              pinIndex,
              this.pins[pinIndex].mode,
              0
            ]);
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            value = value ? 1 : 0;
            this.io.i2cWrite(this.address, [
              this.COMMANDS.DIGITAL_WRITE,
              pinIndex,
              value,
              0
            ]);
            this.pins[pinIndex].value = value;
          }
        },
        ioRead: {
          value(pin, type, callback) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            const isAnalog = type === "analog";
            const length = isAnalog ? 3 : 1;
            const command = isAnalog ? this.COMMANDS.ANALOG_READ : this.COMMANDS.DIGITAL_READ;
            this.on(`${type}-read-${pinIndex}`, callback);
            this.pins[pinIndex].report = 1;
            this.pins[pinIndex].command = command;
            this.pins[pinIndex].type = type;
            this.pins[pinIndex].length = length;
            const nextPinIndex = () => {
              const startAt = nextPinIndex.lastPinIndex + 1;
              for (let i = startAt; i < this.pins.length; i++) {
                if (this.pins[i].report === 1) {
                  nextPinIndex.lastPinIndex = i;
                  return nextPinIndex.lastPinIndex;
                }
              }
              nextPinIndex.lastPinIndex = -1;
              return nextPinIndex();
            };
            nextPinIndex.lastPinIndex = -1;
            const handler = (pinIndex2, value) => {
              const pin2 = this.pins[pinIndex2];
              let canEmit = true;
              if (pin2.type === "digital" && this.pins[pinIndex2].value === value) {
                canEmit = false;
              }
              this.pins[pinIndex2].value = value;
              if (canEmit) {
                this.emit(`${pin2.type}-read-${pinIndex2}`, value);
              }
              setTimeout(read, 1);
            };
            var read = () => {
              const pinIndex2 = nextPinIndex();
              const pin2 = this.pins[pinIndex2];
              const isAnalog2 = pin2.type === "analog";
              this.io.i2cWrite(this.address, [pin2.command, pinIndex2, 0, 0]);
              this.io.i2cReadOnce(this.address, pin2.length, (data) => {
                let value;
                if (isAnalog2) {
                  value = (data[1] << 8) + data[2];
                } else {
                  value = data[0];
                }
                handler(pinIndex2, value);
              });
            };
            if (!state.isReading) {
              state.isReading = true;
              read();
            }
          }
        },
        digitalRead: {
          value(pin, callback) {
            this.ioRead(pin, "digital", callback);
          }
        },
        analogRead: {
          value(pin, callback) {
            this.ioRead(pin, "analog", callback);
          }
        },
        pingRead: {
          value({ pin }, callback) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            this.io.i2cWrite(this.address, [
              this.COMMANDS.PING_READ,
              pinIndex,
              0,
              0
            ]);
            setTimeout(() => {
              this.once(`ping-read-${pin}`, callback);
              this.io.i2cReadOnce(this.address, 3, (data) => {
                const value = Math.round(((data[1] << 8) + data[2]) * 29 * 2);
                this.pins[pinIndex].value = value;
                this.emit(`ping-read-${pin}`, value);
              });
            }, 200);
          }
        },
        analogWrite: {
          value(pin, value) {
            this.pwmWrite(pin, value);
          }
        },
        pwmWrite: {
          writable: true,
          value(pin, value) {
            const state = priv.get(this);
            const pinIndex = state.pinMap[pin];
            value = Fn.constrain(value, 0, 255);
            this.io.i2cWrite(this.address, [
              this.COMMANDS.ANALOG_WRITE,
              pinIndex,
              value,
              0
            ]);
            this.pins[pinIndex].value = value;
          }
        }
      },
      "74HC595": {
        initialize: {
          value({ pins }) {
            const state = priv.get(this);
            if (!pins.data) {
              throw new Error("Expected pins.data");
            }
            if (!pins.clock) {
              throw new Error("Expected pins.clock");
            }
            if (!pins.latch) {
              throw new Error("Expected pins.latch");
            }
            state.data = pins.data;
            state.clock = pins.clock;
            state.latch = pins.latch;
            state.value = 0;
            Object.assign(this.MODES, this.io.MODES);
            this.pins = [];
            for (let i = 0; i < 8; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.OUTPUT
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: 127
              });
            }
            this.portWrite(0, state.value);
            this.name = "74HC595";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            this.pins[pin].mode = mode;
          }
        },
        digitalWrite: {
          value(pin, value) {
            const state = priv.get(this);
            if (value) {
              state.value |= 1 << pin;
            } else {
              state.value &= ~(1 << pin);
            }
            this.pins[pin].value = value;
            this.portWrite(0, state.value);
          }
        },
        portWrite: {
          writable: true,
          configurable: true,
          value(port, value) {
            const state = priv.get(this);
            state.value = value;
            this.board.digitalWrite(state.latch, this.io.LOW);
            this.board.shiftOut(state.data, state.clock, true, state.value);
            this.board.digitalWrite(state.latch, this.io.HIGH);
            for (let i = 0; i < 8; i++) {
              this.pins[i].value = state.value >> i & 1;
            }
          }
        }
      },
      CD74HC4067: {
        ADDRESSES: {
          value: [10, 11, 12, 13]
        },
        REGISTER: {},
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.reading = false;
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 16; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.ANALOG
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: i
              });
              this.analogPins.push(i);
            }
            this.name = "CD74HC4067";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            if (typeof pin === "string" && pin[0] === "A") {
              return +pin.slice(1);
            }
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            this.pins[pin].mode = mode;
          }
        },
        analogRead: {
          value(pin, callback) {
            const state = priv.get(this);
            const pinIndex = pin;
            this.pins[pinIndex].report = 1;
            this.on(`analog-read-${pin}`, callback);
            this.io.i2cWrite(this.address, pinIndex, 1);
            if (!state.reading) {
              state.reading = true;
              this.io.i2cRead(this.address, 32, (data) => {
                let value;
                for (let i = 0; i < 16; i++) {
                  const index = i * 2;
                  value = (data[index] << 8) + data[index + 1];
                  this.pins[i].value = value;
                  if (this.pins[i].report) {
                    this.emit(`analog-read-${i}`, value);
                  }
                }
              });
            }
          }
        }
      },
      LIS3DH: {
        ADDRESSES: {
          value: [24]
        },
        REGISTER: {
          value: {
            OUT_ADC1_L: 8,
            OUT_X_L: 40,
            CTRL_REG1: 32,
            CTRL_REG2: 33,
            CTRL_REG3: 34,
            CTRL_REG4: 35,
            CTRL_REG5: 36,
            TEMP_CFG_REG: 31
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.reading = false;
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            let ctrl1 = 7;
            ctrl1 = ctrl1 & ~240 | 7 << 4;
            this.io.i2cWrite(this.address, this.REGISTER.CTRL_REG1, ctrl1);
            this.io.i2cWrite(this.address, this.REGISTER.CTRL_REG4, 136);
            this.io.i2cWrite(this.address, this.REGISTER.CTRL_REG3, 16);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 4; i++) {
              if (i === 0) {
                this.pins.push({
                  supportedModes: [],
                  mode: 0,
                  value: 0,
                  report: 0,
                  analogChannel: 127
                });
              } else {
                this.pins.push({
                  supportedModes: [this.MODES.ANALOG],
                  mode: 1,
                  value: 0,
                  report: 0,
                  analogChannel: i
                });
                this.analogPins.push(i);
              }
            }
            this.name = "LIS3DH";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            if (typeof pin === "string" && pin[0] === "A") {
              return +pin.slice(1);
            }
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            this.pins[pin].mode = mode;
          }
        },
        analogRead: {
          value(pin, callback) {
            const state = priv.get(this);
            const pinIndex = pin;
            this.pins[pinIndex].report = 1;
            this.on(`analog-read-${pin}`, callback);
            if (!state.reading) {
              state.reading = true;
              this.io.i2cWrite(this.address, this.REGISTER.TEMP_CFG_REG, 128);
              this.io.i2cRead(this.address, this.REGISTER.OUT_ADC1_L | 128, 6, (data) => {
                this.pins[1].value = Fn.scale(Fn.int16(data[1], data[0]), -32512, 32512, 1023, 0);
                this.pins[2].value = Fn.scale(Fn.int16(data[3], data[2]), -32512, 32512, 1023, 0);
                this.pins[3].value = Fn.scale(Fn.int16(data[5], data[4]), -32512, 32512, 1023, 0);
                for (let i = 1; i < 4; i++) {
                  if (this.pins[i].report) {
                    this.emit(`analog-read-${i}`, this.pins[i].value);
                  }
                }
              });
            }
          }
        },
        i2cConfig: {
          value(...args) {
            return this.io.i2cConfig.apply(this.io, args);
          }
        },
        i2cWrite: {
          value(...args) {
            return this.io.i2cWrite.apply(this.io, args);
          }
        },
        i2cWriteReg: {
          value(...args) {
            return this.io.i2cWriteReg.apply(this.io, args);
          }
        },
        i2cRead: {
          value(...args) {
            return this.io.i2cRead.apply(this.io, args);
          }
        },
        i2cReadOnce: {
          value(...args) {
            return this.io.i2cReadOnce.apply(this.io, args);
          }
        }
      },
      ADS1115: {
        ADDRESSES: {
          value: [72, 73, 74, 75]
        },
        REGISTER: {
          value: {
            CONFIG: 1,
            READ: 0,
            PIN: [193, 209, 225, 241],
            PIN_DATA: 131
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.reading = false;
            this.address = options.address || this.ADDRESSES[0];
            options.address = this.address;
            this.io.i2cConfig(options);
            Object.assign(this.MODES, this.io.MODES);
            for (let i = 0; i < 4; i++) {
              this.pins.push({
                supportedModes: [
                  this.MODES.ANALOG
                ],
                mode: 1,
                value: 0,
                report: 0,
                analogChannel: i
              });
              this.analogPins.push(i);
            }
            this.name = "ADS1115";
            this.isReady = true;
            this.emit("connect");
            this.emit("ready");
          }
        },
        normalize: {
          value(pin) {
            if (typeof pin === "string" && pin[0] === "A") {
              return +pin.slice(1);
            }
            return pin;
          }
        },
        pinMode: {
          value(pin, mode) {
            this.pins[pin].mode = mode;
          }
        },
        analogRead: {
          value(pin, callback) {
            const state = priv.get(this);
            this.pins[pin].report = 1;
            let ready = false;
            this.on(`analog-read-${pin}`, callback);
            if (!state.reading) {
              state.reading = true;
              const delay = () => {
                setTimeout(() => {
                  ready = true;
                }, 8);
              };
              this.io.i2cWrite(this.address, this.REGISTER.CONFIG, [this.REGISTER.PIN[pin], this.REGISTER.PIN_DATA]);
              delay();
              this.io.i2cRead(this.address, this.REGISTER.READ, 2, (data) => {
                if (ready) {
                  ready = false;
                  const newPin = pin === this.pins.length - 1 ? 0 : pin + 1;
                  this.io.i2cWrite(this.address, this.REGISTER.CONFIG, [this.REGISTER.PIN[newPin], this.REGISTER.PIN_DATA]);
                  const value = (data[0] << 8) + data[1];
                  this.pins[pin].value = value;
                  if (this.pins[pin].report) {
                    this.emit(`analog-read-${pin}`, value);
                  }
                  pin = newPin;
                  delay();
                }
              });
            }
          }
        }
      }
    };
    Controllers["CD74HCT4067"] = Controllers.CD74HC4067;
    Controllers["74HC4067"] = Controllers.CD74HC4067;
    Controllers.PCF8574A = Object.assign({}, Controllers.PCF8574, {
      ADDRESSES: {
        value: [56]
      }
    });
    var methods = Object.keys(Board.prototype);
    Object.keys(Controllers).forEach((name) => {
      methods.forEach((key) => {
        if (Controllers[name][key] === void 0) {
          Controllers[name][key] = {
            writable: true,
            configurable: true,
            value() {
              throw new Error(`Expander:${name} does not support ${key}`);
            }
          };
        }
      });
    });
    var nonAddressable = [
      "74HC595"
    ];
    var Expander = class extends Base {
      constructor(options) {
        super();
        let addressError = "Expander cannot reuse an active address";
        let expander = null;
        let controllerValue;
        if (typeof options === "string") {
          controllerValue = options;
        }
        Board.Component.call(this, options = Board.Options(options), {
          normalizePin: false,
          requestPin: false
        });
        if (nonAddressable.includes(options.controller) && typeof this.address === "undefined") {
          this.address = Fn.uid();
        }
        expander = active.get(this.address);
        if (expander) {
          if (this.bus && (expander.bus !== void 0 && expander.bus === this.bus)) {
            addressError += " on this bus";
          }
          throw new Error(addressError);
        }
        if (typeof options.controller === "undefined" && controllerValue) {
          options.controller = controllerValue;
        }
        Board.Controller.call(this, Controllers, options);
        priv.set(this, {});
        if (typeof this.initialize === "function") {
          this.initialize(options);
        }
        active.set(this.address, this);
      }
    };
    Expander.get = (required) => {
      if (!required.address || !required.controller) {
        throw new Error("Expander.get(...) requires an address and controller");
      }
      if (required.address !== void 0) {
        required.address = Number(required.address);
      }
      if (Number.isNaN(required.address)) {
        throw new Error("Expander.get(...) expects address to be a number");
      }
      if (typeof required.controller !== "string") {
        throw new Error("Expander.get(...) expects controller name to be a string");
      }
      const expander = active.get(required.address);
      if (expander && expander.name === required.controller.toUpperCase()) {
        return expander;
      }
      return new Expander(required);
    };
    Expander.byAddress = (address) => active.get(address);
    Expander.byController = (name) => {
      let controller = null;
      active.forEach((value) => {
        if (value.name === name.toUpperCase()) {
          controller = value;
        }
      });
      return controller;
    };
    Expander.hasController = (key) => Controllers[key] !== void 0;
    if (!!process.env.IS_TEST_MODE) {
      Expander.Controllers = Controllers;
      Expander.purge = () => {
        priv.clear();
        active.clear();
      };
    }
    module2.exports = Expander;
  }
});

// node_modules/johnny-five/lib/board.js
var require_board = __commonJS({
  "node_modules/johnny-five/lib/board.js"(exports, module2) {
    var Emitter = require_emitter();
    var chalk = require_chalk();
    var Collection = require_collection();
    var Fn = require_fn();
    var Repl = require_repl();
    var Options = require_board_options();
    var Pins = require_board_pins();
    var IS_TEST_MODE = !!process.env.IS_TEST_MODE;
    var Expander;
    var boards = [];
    var rport = /usb|acm|^com/i;
    var UNDEFINED = "undefined";
    var Serial = {
      used: [],
      attempts: [],
      detect(callback) {
        const maxAttempts = 10;
        const retryDelay = 400;
        if (parseFloat(process.versions.nw) >= 0.13) {
          serialport = require_browser_serialport();
        } else {
          serialport = require_dist17().SerialPort;
        }
        serialport.list().then((results) => {
          const portPaths = results.reduce((accum, result) => {
            let available = true;
            if (!rport.test(result.path)) {
              available = false;
            }
            if (Serial.used.includes(result.path)) {
              available = false;
            }
            if (available) {
              accum.push(result.path);
            }
            return accum;
          }, []);
          if (!portPaths.length) {
            if (IS_TEST_MODE && this.abort) {
              return;
            }
            if (!Serial.attempts[Serial.used.length]) {
              Serial.attempts[Serial.used.length] = 0;
              this.info("Board", "Looking for connected device");
            }
            Serial.attempts[Serial.used.length]++;
            if (Serial.attempts[Serial.used.length] > maxAttempts) {
              this.fail("Board", "No connected device found");
              return;
            }
            setTimeout(() => {
              Serial.detect.call(this, callback);
            }, retryDelay);
            return;
          }
          this.info("Available", chalk.grey(portPaths));
          callback.call(this, portPaths[0]);
        });
      },
      connect(portOrPath, callback) {
        const IO = require_firmata().Board;
        let caught = null;
        let io2;
        let isConnected;
        let path;
        let type;
        if (typeof portOrPath === "object" && portOrPath.path) {
          path = portOrPath.path;
          this.info(portOrPath.transport || "SerialPort", chalk.grey(path));
        } else {
          path = portOrPath;
        }
        Serial.used.push(path);
        try {
          io2 = new IO(portOrPath, (error) => {
            if (error) {
              caught = error;
            }
            callback.call(this, caught, caught ? "error" : "ready", io2);
          });
          io2.name = "Firmata";
          io2.defaultLed = 13;
          io2.port = path;
          isConnected = true;
        } catch (error) {
          caught = error;
        }
        if (caught) {
          caught = caught.message || caught;
        }
        type = isConnected ? "connect" : "error";
        callback.call(this, caught, type, io2);
      }
    };
    var Board = class extends Emitter {
      constructor(options = {}) {
        super();
        const replContext = {};
        let isPostponed = false;
        Object.assign(this, options);
        this.timer = null;
        this.isConnected = false;
        this.isReady = false;
        this.io = this.io || null;
        this.register = [];
        this.occupied = [];
        this.Drivers = {};
        if (!this.id) {
          this.id = Fn.uid();
        }
        if (typeof this.debug === UNDEFINED) {
          this.debug = true;
        }
        if (typeof this.repl === UNDEFINED) {
          this.repl = true;
        }
        if (typeof this.sigint === UNDEFINED) {
          this.sigint = true;
        }
        this.pins = null;
        if (this.repl) {
          if (Repl.ref) {
            replContext[this.id] = this;
            Repl.ref.on("ready", function() {
              Repl.ref.inject(replContext);
            });
            this.repl = Repl.ref;
          } else {
            replContext[this.id] = replContext.board = this;
            this.repl = new Repl(replContext);
          }
        }
        if (options.io) {
          this.io = options.io;
          this.isReady = options.io.isReady;
          this.transport = this.io.transport || null;
          this.port = this.io.name;
          this.pins = Board.Pins(this);
          this.RESOLUTION = Object.assign({ ADC: 1023, DAC: null, PWM: 255 }, this.io.RESOLUTION || {});
        } else {
          if (this.port && options.port) {
            Serial.connect.call(this, this.port, finalizeAndBroadcast);
          } else {
            Serial.detect.call(this, function(path) {
              Serial.connect.call(this, path, finalizeAndBroadcast);
            });
          }
        }
        if (!options.port && this.io !== null) {
          this.info("Available", chalk.grey(this.io.name || "unknown"));
          ["connect", "ready"].forEach((type) => {
            this.io.once(type, () => {
              if (type === "ready" && !this.isConnected) {
                isPostponed = true;
              } else {
                finalizeAndBroadcast.call(this, null, type, this.io);
              }
              if (type === "connect" && isPostponed) {
                finalizeAndBroadcast.call(this, null, "ready", this.io);
              }
            });
            if (this.io.isReady) {
              process.nextTick(() => this.io.emit(type));
            }
          });
        }
        this.once("ready", () => {
          const hrstart = process.hrtime();
          this.millis = function() {
            const now = process.hrtime(hrstart);
            return now[1] / 1e6;
          };
          ["close", "disconnect", "error", "string"].forEach((type) => {
            this.io.on(type, (data) => this.emit(type, data));
          });
        });
        boards.push(this);
      }
    };
    function finalizeAndBroadcast(data, type, io2) {
      let hasBeenEmitted = false;
      if (!this.io) {
        this.io = io2;
      }
      if (type === "error") {
        if (data && data.message) {
          hasBeenEmitted = true;
          this.error("Error", data.message);
        }
      }
      if (type === "connect") {
        this.isConnected = true;
        this.port = io2.port || io2.name;
        this.info("Connected", chalk.grey(this.port));
        if (!IS_TEST_MODE) {
          this.timer = setTimeout(() => {
            this.error("Device or Firmware Error", "A timeout occurred while connecting to the Board. \n\nPlease check that you've properly flashed the board with the correct firmware.\nSee: https://github.com/rwaldron/johnny-five/wiki/Getting-Started#trouble-shooting\n\nIf connecting to a Leonardo or Leonardo clone, press the 'Reset' button on the board, wait approximately 11 seconds for complete reset, then run your program again.");
            this.emit("error", new Error("A timeout occurred while connecting to the Board."));
          }, this.timeout || 1e4);
        }
      }
      if (type === "ready") {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        this.isReady = true;
        this.pins = Board.Pins(this);
        this.MODES = this.io.MODES;
        if (typeof io2.debug !== UNDEFINED && io2.debug === false) {
          this.debug = false;
        }
        if (typeof io2.repl !== UNDEFINED && io2.repl === false) {
          this.repl = false;
        }
        if (this.repl) {
          this.repl.initialize(() => this.emit("ready"));
        }
        if (io2.name !== "Mock" && this.sigint) {
          process.on("SIGINT", () => {
            const failExitTimeout = 1e3;
            this.emit("exit");
            this.warn("Board", "Closing.");
            const timeout = setTimeout(() => {
              process.reallyExit();
            }, failExitTimeout);
            const interval = setInterval(() => {
              if (!this.io.pending) {
                clearInterval(interval);
                clearTimeout(timeout);
                process.nextTick(process.reallyExit);
              }
            }, 1);
          });
        }
        this.RESOLUTION = Object.assign({ ADC: 1023, DAC: null, PWM: 255 }, io2.RESOLUTION || {});
      }
      if (this.repl) {
        if (type === "connect") {
          this.emit(type, data);
        }
      } else {
        if (!hasBeenEmitted) {
          this.emit(type, data);
        }
      }
    }
    [
      "digitalWrite",
      "analogWrite",
      "analogRead",
      "digitalRead",
      "pinMode",
      "queryPinState",
      "stepperConfig",
      "stepperStep",
      "sendI2CConfig",
      "sendI2CWriteRequest",
      "sendI2CReadRequest",
      "i2cConfig",
      "i2cWrite",
      "i2cWriteReg",
      "i2cRead",
      "i2cReadOnce",
      "pwmWrite",
      "servoConfig",
      "servoWrite",
      "sysexCommand",
      "sysexResponse",
      "serialConfig",
      "serialWrite",
      "serialRead",
      "serialStop",
      "serialClose",
      "serialFlush",
      "serialListen"
    ].forEach(function(method) {
      Board.prototype[method] = function() {
        this.io[method].apply(this.io, arguments);
        return this;
      };
    });
    Board.prototype.snapshot = function(reducer) {
      const blacklist = this.snapshot.blacklist;
      const special = this.snapshot.special;
      const hasReducer = typeof reducer === "function";
      return this.register.reduce((cAccum, component) => {
        if (typeof component.components === UNDEFINED) {
          cAccum.push(Object.getOwnPropertyNames(component).reduce((pAccum, prop) => {
            const value = component[prop];
            if (!blacklist.includes(prop) && typeof value !== "function") {
              if (hasReducer) {
                const result = reducer(prop, value, component);
                if (result !== void 0) {
                  pAccum[prop] = result;
                }
              } else {
                pAccum[prop] = special[prop] ? special[prop](value) : value;
              }
            }
            return pAccum;
          }, Object.create(null)));
        }
        return cAccum;
      }, []);
    };
    Board.prototype.serialize = function(reducer) {
      return JSON.stringify(this.snapshot(reducer));
    };
    Board.prototype.snapshot.blacklist = [
      "board",
      "io",
      "_events",
      "_eventsCount",
      "state"
    ];
    Board.prototype.samplingInterval = function(ms) {
      if (this.io.setSamplingInterval) {
        this.io.setSamplingInterval(ms);
      } else {
        throw new Error("This IO plugin does not implement an interval adjustment method");
      }
      return this;
    };
    Board.prototype.snapshot.special = {
      mode: function(value) {
        return ["INPUT", "OUTPUT", "ANALOG", "PWM", "SERVO"][value] || "unknown";
      }
    };
    Board.prototype.shiftOut = function(dataPin, clockPin, isBigEndian, value) {
      if (arguments.length === 3) {
        value = isBigEndian;
        isBigEndian = true;
      }
      for (let i = 0; i < 8; i++) {
        this.io.digitalWrite(clockPin, 0);
        if (isBigEndian) {
          this.io.digitalWrite(dataPin, !!(value & 1 << 7 - i) | 0);
        } else {
          this.io.digitalWrite(dataPin, !!(value & 1 << i) | 0);
        }
        this.io.digitalWrite(clockPin, 1);
      }
    };
    var logging = {
      specials: ["error", "fail", "warn", "info"],
      colors: {
        log: "white",
        error: "red",
        fail: "inverse",
        warn: "yellow",
        info: "cyan"
      }
    };
    Board.prototype.log = function() {
      var args = Array.from(arguments);
      if (!logging.specials.includes(args[0])) {
        args.unshift("log");
      }
      var type = args.shift();
      var klass = args.shift();
      var message = args.shift();
      var color = logging.colors[type];
      var now = Date.now();
      var event = {
        type,
        timestamp: now,
        class: klass,
        message: "",
        data: null
      };
      if (typeof args[args.length - 1] === "object") {
        event.data = args.pop();
      }
      message += " " + args.join(", ");
      event.message = message.trim();
      if (this.debug) {
        console.log([
          chalk.grey(now),
          chalk.magenta(klass),
          chalk[color](message),
          args.join(", ")
        ].join(" "));
      }
      this.emit(type, event);
      this.emit("message", event);
    };
    logging.specials.forEach(function(type) {
      Board.prototype[type] = function() {
        var args = [].slice.call(arguments);
        args.unshift(type);
        this.log.apply(this, args);
      };
    });
    Board.prototype.wait = function(time, callback) {
      setTimeout(callback, time);
      return this;
    };
    Board.prototype.loop = function(time, callback) {
      var handler = function() {
        callback(function() {
          clearInterval(interval);
        });
      };
      var interval = setInterval(handler, time);
      return this;
    };
    Board.map = Fn.map;
    Board.fmap = Fn.fmap;
    Board.constrain = Fn.constrain;
    Board.range = Fn.range;
    Board.uid = Fn.uid;
    Board.mount = function(arg) {
      var index = typeof arg === "number" && arg, hardware;
      if (arg && arg.board) {
        return arg.board;
      }
      if (typeof index === "number") {
        hardware = boards[index];
        return hardware ? hardware : null;
      }
      if (boards.length) {
        return boards[0];
      }
      return null;
    };
    Board.Component = function(opts, componentOpts) {
      if (typeof opts === UNDEFINED) {
        opts = {};
      }
      if (typeof componentOpts === UNDEFINED) {
        componentOpts = {};
      }
      this.board = Board.mount(opts);
      this.io = this.board.io;
      this.id = opts.id || Board.uid();
      this.custom = opts.custom || {};
      var originalPins;
      if (typeof opts.pin === "number" || typeof opts.pin === "string") {
        originalPins = [opts.pin];
      } else {
        if (Array.isArray(opts.pins)) {
          originalPins = opts.pins.slice();
        } else {
          if (typeof opts.pins === "object" && opts.pins !== null) {
            var pinset = opts.pins || opts.pin;
            originalPins = [];
            for (var p in pinset) {
              originalPins.push(pinset[p]);
            }
          }
        }
      }
      if (opts.controller) {
        if (typeof opts.controller === "string") {
          opts.controller = opts.controller.replace(/-/g, "");
        }
        if (!Expander) {
          Expander = require_expander();
        }
        if (Expander.hasController(opts.controller)) {
          componentOpts = {
            normalizePin: false,
            requestPin: false
          };
        }
      }
      componentOpts = Board.Component.initialization(componentOpts);
      if (componentOpts.normalizePin) {
        opts = Board.Pins.normalize(opts, this.board);
      }
      if (typeof opts.pins !== UNDEFINED) {
        this.pins = opts.pins || [];
      }
      if (typeof opts.pin !== UNDEFINED) {
        this.pin = opts.pin;
      }
      if (typeof opts.emitter !== UNDEFINED) {
        this.emitter = opts.emitter;
      }
      if (typeof opts.address !== UNDEFINED) {
        this.address = opts.address;
      }
      if (typeof opts.controller !== UNDEFINED) {
        this.controller = opts.controller;
      }
      if (typeof opts.bus !== UNDEFINED) {
        this.bus = opts.bus;
      }
      this.board.register.push(this);
    };
    Board.Component.initialization = function(opts) {
      var defaults = {
        requestPin: true,
        normalizePin: true
      };
      return Object.assign({}, defaults, opts);
    };
    Board.Controller = function(controllers, options) {
      let controller;
      if (typeof options.controller === "string") {
        controller = controllers[options.controller] || controllers[options.controller.toUpperCase()];
      } else {
        controller = options.controller || controllers.DEFAULT || null;
      }
      if (controller === null) {
        throw new Error("No Valid Controller Found");
      }
      let requirements = controller.requirements && controller.requirements.value;
      if (requirements) {
        if (requirements.options) {
          Object.keys(requirements.options).forEach(function(key) {
            if (typeof options[key] === UNDEFINED || typeof options[key] !== requirements.options[key].typeof) {
              if (requirements.options[key].throws) {
                throw new Error(requirements.options[key].message);
              } else {
                this.board.warn(this.constructor.name, requirements.options[key].message);
              }
            }
          }, this);
        }
      }
      Object.defineProperties(this, controller);
    };
    Board.Pins = Pins;
    Board.Options = function(options) {
      return new Options(options);
    };
    Object.defineProperty(Board, "cache", {
      get() {
        return boards;
      }
    });
    Board.Event = function(event) {
      if (typeof event === UNDEFINED) {
        throw new Error("Board.Event missing Event object");
      }
      this.type = event.type || "data";
      this.target = event.target || null;
      Object.assign(this, event);
    };
    var Boards = class extends Collection {
      constructor(options) {
        let ports;
        if (Array.isArray(options)) {
          ports = options.slice();
          options = {
            ports
          };
        }
        if (!Array.isArray(options) && typeof options === "object" && options.ports !== void 0) {
          ports = options.ports;
        }
        if (!Array.isArray(ports)) {
          throw new Error("Expected ports to be an array");
        }
        if (typeof options.debug === UNDEFINED) {
          options.debug = true;
        }
        if (typeof options.repl === UNDEFINED) {
          options.repl = true;
        }
        const initialized = {};
        const noRepl = ports.some(({ repl }) => repl === false);
        const noDebug = ports.some(({ debug }) => debug === false);
        const boardObjects = ports.map((port) => {
          let portOpts;
          if (typeof port === "string") {
            portOpts = {};
            if (rport.test(port)) {
              portOpts.port = port;
            } else {
              portOpts.id = port;
            }
          } else {
            portOpts = port;
          }
          portOpts.repl = false;
          return new Board(portOpts);
        });
        super(boardObjects);
        this.debug = options.debug;
        this.repl = options.repl;
        if (noDebug) {
          this.debug = false;
        }
        if (noRepl) {
          this.repl = false;
        }
        const expecteds = this.map((board, index) => {
          initialized[board.id] = board;
          return new Promise((resolve) => {
            this[index].on("error", (error) => this.emit("error", error));
            this[index].on("fail", (event) => this.emit("fail", event));
            this[index].on("ready", () => resolve(this[index]));
          });
        });
        Promise.all(expecteds).then(() => {
          this.each((board) => {
            board.info("Board ID: ", chalk.green(board.id));
          });
          if (this.repl) {
            this.repl = new Repl(Object.assign({}, initialized, {
              board: this
            }));
            this.repl.initialize(() => this.emit("ready", initialized));
          } else {
            this.emit("ready", initialized);
          }
        }).catch((error) => {
          console.error(chalk.red(error));
        });
      }
      static get type() {
        return Board;
      }
    };
    Collection.installMethodForwarding(Boards.prototype, Board.prototype);
    Object.assign(Boards.prototype, Emitter.prototype);
    Boards.prototype.byId = function(id) {
      for (var i = 0; i < this.length; i++) {
        if (this[i].id === id) {
          return this[i];
        }
      }
      return null;
    };
    Boards.prototype.log = Board.prototype.log;
    logging.specials.forEach(function(type) {
      Boards.prototype[type] = function() {
        var args = [].slice.call(arguments);
        args.unshift(type);
        this.log.apply(this, args);
      };
    });
    if (IS_TEST_MODE) {
      Serial.purge = function() {
        Serial.used.length = 0;
      };
      Board.Serial = Serial;
      Board.purge = function() {
        Board.Pins.normalize.clear();
        Repl.isActive = false;
        Repl.isBlocked = true;
        Repl.ref = null;
        boards.length = 0;
      };
      Board.testMode = function(state) {
        if (!arguments.length) {
          return IS_TEST_MODE;
        } else {
          IS_TEST_MODE = state;
        }
      };
    }
    Board.Array = Boards;
    Board.Collection = Boards;
    module2.exports = Board;
  }
});

// node_modules/johnny-five/lib/pin.js
var require_pin = __commonJS({
  "node_modules/johnny-five/lib/pin.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Collection = require_collection();
    var priv = new Map();
    var modes = {
      INPUT: 0,
      OUTPUT: 1,
      ANALOG: 2,
      PWM: 3,
      SERVO: 4
    };
    var LOW = "low";
    var HIGH = "high";
    var ANALOG = "analog";
    var DIGITAL = "digital";
    var Pin = class extends Emitter {
      constructor(options) {
        super();
        if (options === void 0 || typeof options === "object" && options.addr === void 0 && options.pin === void 0) {
          throw new Error("Pins must have a pin number");
        }
        const pinValue = typeof options === "object" ? options.addr || options.pin || 0 : options;
        let isAnalogInput = Pin.isAnalog(options);
        let isDTOA = false;
        Board.Component.call(this, options = Board.Options(options));
        options.addr = options.addr || options.pin;
        if (this.io.analogPins.includes(pinValue)) {
          isAnalogInput = false;
          isDTOA = true;
        }
        const isPin = typeof options !== "object";
        const addr = isDTOA ? pinValue : isPin ? options : options.addr;
        const type = options.type || (isAnalogInput ? ANALOG : DIGITAL);
        const state = {
          mode: null,
          last: null,
          value: 0
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          type: {
            get() {
              return type;
            }
          },
          addr: {
            get() {
              return addr;
            }
          },
          value: {
            get() {
              return state.value;
            }
          },
          mode: {
            set(mode) {
              priv.get(this).mode = mode;
              this.io.pinMode(this.addr, mode);
            },
            get() {
              return priv.get(this).mode;
            }
          }
        });
        this.mode = typeof options.as !== "undefined" ? options.as : typeof options.mode !== "undefined" ? options.mode : isAnalogInput ? 2 : 1;
        this.freq = typeof options.freq !== "undefined" ? options.freq : 20;
        if (this.mode === 0 || this.mode === 2) {
          read(this);
        }
        if (type === DIGITAL) {
          Object.defineProperties(this, {
            isHigh: {
              get() {
                return !!state.value;
              }
            },
            isLow: {
              get() {
                return !state.value;
              }
            }
          });
        }
      }
      query(callback) {
        let index = this.addr;
        if (this.type === ANALOG) {
          index = this.io.analogPins[this.addr];
        }
        this.io.queryPinState(index, () => callback(this.io.pins[index]));
        return this;
      }
      high() {
        const value = this.type === ANALOG ? this.board.RESOLUTION.PWM : 1;
        Pin.write(this, value);
        this.emit(HIGH);
        return this;
      }
      low() {
        Pin.write(this, 0);
        this.emit(LOW);
        return this;
      }
    };
    function read(pin) {
      const state = priv.get(pin);
      pin.io[`${pin.type}Read`](pin.addr, (data) => state.value = data);
      setInterval(() => {
        let isNot;
        let emit;
        isNot = state.value ? LOW : HIGH;
        emit = state.value ? HIGH : LOW;
        if (state.mode === modes.INPUT) {
          if (state.last === null) {
            state.last = isNot;
          }
          if (state.last === isNot) {
            state.last = emit;
            pin.emit(emit, state.value);
            pin.emit("change", state.value);
          }
        }
        pin.emit("data", state.value);
      }, pin.freq);
    }
    Object.entries(modes).forEach(([mode, value]) => {
      Object.defineProperty(Pin, mode, { value });
    });
    Pin.isAnalog = (options) => {
      if (typeof options === "string" && Pin.isPrefixed(options, ["I", "A"])) {
        return true;
      }
      if (typeof options === "object") {
        return Pin.isAnalog(typeof options.addr !== "undefined" ? options.addr : options.pin);
      }
    };
    Pin.isPrefixed = (value, prefixes) => {
      value = value[0];
      return prefixes.reduce((resolution, prefix) => {
        if (!resolution) {
          return prefix === value;
        }
        return resolution;
      }, false);
    };
    Pin.write = (pin, val) => {
      const state = priv.get(pin);
      state.value = val;
      pin.mode = modes.OUTPUT;
      pin.io[`${pin.type}Write`](pin.addr, val);
      pin.emit("write", null, val);
    };
    Pin.read = (pin, callback) => {
      let isChanging = false;
      if (pin.type === DIGITAL && pin.mode !== 0) {
        isChanging = true;
        pin.mode = modes.INPUT;
      }
      if (pin.type === ANALOG && pin.mode !== 2) {
        isChanging = true;
        pin.mode = modes.ANALOG;
      }
      if (isChanging) {
        read(pin);
      }
      pin.on("data", () => {
        callback.call(pin, null, pin.value);
      });
    };
    ["read", "write"].forEach((operation) => {
      Pin.prototype[operation] = function(valOrCallback) {
        Pin[operation](this, valOrCallback);
        return this;
      };
    });
    var Pins = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Pin;
      }
    };
    Collection.installMethodForwarding(Pins.prototype, Pin.prototype);
    Pin.Collection = Pins;
    if (!!process.env.IS_TEST_MODE) {
      Pin.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Pin;
  }
});

// node_modules/johnny-five/lib/co2.js
var require_co2 = __commonJS({
  "node_modules/johnny-five/lib/co2.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require("events");
    var Pin = require_pin();
    var priv = new Map();
    var commandReadGas = Buffer.from([
      255,
      1,
      134,
      0,
      0,
      0,
      0,
      0,
      121
    ]);
    var CO2 = class extends Emitter {
      constructor(options) {
        super();
        if (Array.isArray(options)) {
          options = {
            pins: {
              rx: options[0],
              tx: options[1]
            }
          };
        }
        if (typeof options.pins === "undefined") {
          options.pins = {};
        }
        this.baud = 9600;
        this.maxBytesToRead = 9;
        Board.Component.call(this, options = Board.Options(options));
        let state = {
          temperature: 0,
          co2: 0
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          temperature: {
            get() {
              return state.temperature;
            }
          },
          co2: {
            get() {
              return state.co2;
            }
          }
        });
        if (this.initialize) {
          this.initialize(options);
        }
      }
      initialize(options) {
        const state = priv.get(this);
        state.portId = options.serialPort || options.portId || options.port || options.bus;
        if (typeof state.portId === "undefined" && this.io.SERIAL_PORT_IDs) {
          state.portId = this.io.SERIAL_PORT_IDs.SW_SERIAL0;
        }
        ["tx", "rx"].forEach((pin) => {
          if (this.pins[pin]) {
            this.io.pinMode(this.pins[pin], this.io.MODES.SERIAL);
          }
        });
        this.io.serialConfig({
          portId: state.portId,
          baud: this.baud,
          rxPin: this.pins.rx,
          txPin: this.pins.tx
        });
        this.listen(1e3);
      }
      sendCommand(commandByteArray) {
        const state = priv.get(this);
        this.io.serialWrite(state.portId, commandByteArray);
      }
      listen(intervalFrequency) {
        const state = priv.get(this);
        let received = [];
        this.io.serialRead(state.portId, this.maxBytesToRead, (data) => {
          received.push(...data);
          if (received.length >= this.maxBytesToRead) {
            const data2 = Buffer.from(received);
            if (calculateChecksum(data2) === data2[8]) {
              this.calculateGasConcentration(data2);
            }
            received = [];
          }
        });
        this.interval = setInterval(() => {
          this.io.serialWrite(state.portId, commandReadGas);
        }, intervalFrequency);
      }
      calculateGasConcentration(byteBuffer) {
        const state = priv.get(this);
        const last = { ...state };
        state.co2 = calculateGas(byteBuffer);
        state.temperature = calculateTemp(byteBuffer);
        this.emit("data", {
          temperature: state.temperature,
          co2: state.co2
        });
        if (last.temperature !== state.temperature || last.co2 !== state.co2) {
          this.emit("change", {
            temperature: state.temperature,
            co2: state.co2
          });
        }
      }
    };
    function calculateChecksum(buffer) {
      let checksum = 0;
      for (let i = 1; i < 8; i++) {
        checksum += buffer[i];
      }
      checksum = 255 - checksum % 256;
      checksum += 1;
      return checksum;
    }
    function calculateGas(buffer) {
      return buffer[2] * 256 + buffer[3];
    }
    function calculateTemp(buffer) {
      return buffer[4] - 40;
    }
    if (!!process.env.IS_TEST_MODE) {
      CO2.purge = () => {
        priv.clear();
      };
    }
    module2.exports = CO2;
  }
});

// node_modules/johnny-five/lib/accelerometer.js
var require_accelerometer = __commonJS({
  "node_modules/johnny-five/lib/accelerometer.js"(exports, module2) {
    var Board = require_board();
    var Expander = require_expander();
    var Emitter = require_emitter();
    var { constrain, fma, int16, sum, toFixed, RAD_TO_DEG } = require_fn();
    var priv = new Map();
    var calibrationSize = 10;
    var aX = "x";
    var aY = "y";
    var aZ = "z";
    var axes = [aX, aY, aZ];
    function analogInitialize({ zeroV, sensitivity }, callback) {
      const state = priv.get(this);
      const dataPoints = {};
      state.zeroV = zeroV || this.DEFAULTS.zeroV;
      state.sensitivity = sensitivity || this.DEFAULTS.sensitivity;
      this.pins.forEach(function(pin, index) {
        this.io.pinMode(pin, this.io.MODES.ANALOG);
        this.io.analogRead(pin, (data) => {
          const axis = axes[index];
          dataPoints[axis] = data;
          callback(dataPoints);
        });
      }, this);
    }
    function analogToGravity(value, axis) {
      const state = priv.get(this);
      let zeroV = state.zeroV;
      if (Array.isArray(zeroV) && zeroV.length > 0) {
        const axisIndex = axes.indexOf(axis);
        zeroV = zeroV[axisIndex || 0];
      }
      return (value - zeroV) / state.sensitivity;
    }
    var Controllers = {
      ANALOG: {
        DEFAULTS: {
          value: {
            zeroV: 478,
            sensitivity: 96
          }
        },
        initialize: {
          value: analogInitialize
        },
        toGravity: {
          value: analogToGravity
        }
      },
      MPU6050: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.sensitivity = options.sensitivity || 16384;
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MPU6050", options).on("data", ({ accelerometer }) => callback(accelerometer));
          }
        },
        toGravity: {
          value(value) {
            return toFixed(value / priv.get(this).sensitivity, 3);
          }
        }
      },
      BNO055: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.sensitivity = 100;
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BNO055", options).on("data", ({ accelerometer }) => callback(accelerometer));
          }
        },
        toGravity: {
          value(value) {
            return toFixed(value / priv.get(this).sensitivity, 2);
          }
        }
      },
      ADXL335: {
        DEFAULTS: {
          value: {
            zeroV: 330,
            sensitivity: 66.5
          }
        },
        initialize: {
          value: analogInitialize
        },
        toGravity: {
          value(value, axis) {
            return toFixed(analogToGravity.call(this, value, axis), 3);
          }
        }
      },
      ADXL345: {
        ADDRESSES: {
          value: [83]
        },
        REGISTER: {
          value: {
            POWER: 45,
            DATA_FORMAT: 49,
            DATAX0: 50
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const READLENGTH = 6;
            this.io.i2cConfig(options);
            this.io.i2cWrite(address, this.REGISTER.POWER, 0);
            this.io.i2cWrite(address, this.REGISTER.POWER, 8);
            const format = 8;
            const range = {
              2: 0,
              4: 1,
              8: 2,
              16: 3
            }[options.range || 2];
            this.io.i2cWrite(address, this.REGISTER.DATA_FORMAT, format | range);
            this.io.i2cRead(address, this.REGISTER.DATAX0, READLENGTH, (data) => {
              callback({
                x: int16(data[1], data[0]),
                y: int16(data[3], data[2]),
                z: int16(data[5], data[4])
              });
            });
          }
        },
        toGravity: {
          value(value) {
            return toFixed(value * 390625e-8, 8);
          }
        }
      },
      MMA7361: {
        DEFAULTS: {
          value: {
            zeroV: [372, 372, 287],
            sensitivity: 170
          }
        },
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (options.sleepPin !== void 0) {
              state.sleepPin = options.sleepPin;
              this.io.pinMode(state.sleepPin, 1);
              this.io.digitalWrite(state.sleepPin, 1);
            }
            analogInitialize.call(this, options, callback);
          }
        },
        toGravity: {
          value(value, axis) {
            return toFixed(analogToGravity.call(this, value, axis), 3);
          }
        },
        enabledChanged: {
          value(value) {
            const state = priv.get(this);
            if (state.sleepPin !== void 0) {
              this.io.digitalWrite(state.sleepPin, value ? 1 : 0);
            }
          }
        }
      },
      MMA8452: {
        ADDRESSES: {
          value: [29]
        },
        REGISTER: {
          value: {
            STATUS: 0,
            OUT_X_MSB: 1,
            XYZ_DATA_CFG: 14,
            PULSE_CFG: 33,
            PULSE_SRC: 34,
            PULSE_THSX: 35,
            PULSE_THSY: 36,
            PULSE_THSZ: 37,
            PULSE_TMLT: 38,
            PULSE_LTCY: 39,
            PULSE_WIND: 40,
            CTRL_REG1: 42,
            CTRL_REG4: 46,
            CTRL_REG5: 47
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            const rates = [800, 400, 200, 100, 50, 12, 6];
            const odr = rates.indexOf(options.odr || 800);
            const scale = options.range || 2;
            const fsr = {
              2: 0,
              4: 1,
              8: 2
            }[scale];
            options.taps = options.taps || {
              x: false,
              y: false,
              z: true
            };
            const taps = {
              x: options.taps.x ? 8 : 128,
              y: options.taps.y ? 8 : 128,
              z: options.taps.z ? 8 : 128
            };
            state.scale = scale;
            const computed = {
              x: null,
              y: null,
              z: null
            };
            this.io.i2cConfig(Object.assign(options, {
              settings: {
                stopTX: false
              }
            }));
            if (odr === -1) {
              throw new RangeError("Invalid odr. Expected one of: 800,  400,  200,  100,  50,  12,  6");
            }
            let config = 8;
            config |= odr << 3;
            this.io.i2cWriteReg(address, this.REGISTER.CTRL_REG1, config);
            this.io.i2cWriteReg(address, this.REGISTER.XYZ_DATA_CFG, fsr);
            let temp = 0;
            if (!(taps.x & 128)) {
              temp |= 3;
              this.io.i2cWriteReg(address, this.REGISTER.PULSE_THSX, taps.x);
            }
            if (!(taps.y & 128)) {
              temp |= 12;
              this.io.i2cWriteReg(address, this.REGISTER.PULSE_THSY, taps.y);
            }
            if (!(taps.z & 128)) {
              temp |= 48;
              this.io.i2cWriteReg(address, this.REGISTER.PULSE_THSZ, taps.z);
            }
            this.io.i2cWriteReg(address, this.REGISTER.PULSE_CFG, temp | 64);
            this.io.i2cWriteReg(address, this.REGISTER.PULSE_TMLT, 60 / (1e3 / rates[odr]));
            this.io.i2cWriteReg(address, this.REGISTER.PULSE_LTCY, 200 / (1e3 / rates[odr]));
            this.io.i2cWriteReg(address, this.REGISTER.PULSE_WIND, 255);
            config |= 1;
            this.io.i2cWriteReg(address, this.REGISTER.CTRL_REG1, config);
            this.io.i2cRead(address, this.REGISTER.STATUS, 7, (data) => {
              const status = (data.shift() & 8) >>> 3;
              if (status) {
                computed.x = int16(data[0], data[1]) >> 4;
                computed.y = int16(data[2], data[3]) >> 4;
                computed.z = int16(data[4], data[5]) >> 4;
                callback(computed);
              }
            });
            this.io.i2cRead(address, this.REGISTER.PULSE_SRC, 1, (data) => {
              const status = data[0];
              const tap = status & 127;
              if (status & 128) {
                this.emit("tap");
                if (tap >> 2 & 1) {
                  this.emit("tap:single");
                  if (tap >> 3 & 1) {
                    this.emit("tap:double");
                  }
                }
              }
            });
          }
        },
        toGravity: {
          value(value) {
            return toFixed(value / ((1 << 11) * priv.get(this).scale), 4);
          }
        }
      },
      MMA7660: {
        ADDRESSES: {
          value: [76]
        },
        REGISTER: {
          value: {
            XOUT: 0,
            MODE: 7,
            SR: 8
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const READLENGTH = 3;
            const state = priv.get(this);
            state.sensitivity = 21.33;
            this.io.i2cConfig(options);
            this.io.i2cWrite(address, this.REGISTER.MODE, 0);
            this.io.i2cWrite(address, this.REGISTER.SR, 7);
            this.io.i2cWrite(address, this.REGISTER.MODE, 1);
            this.io.i2cRead(address, this.REGISTER.XOUT, READLENGTH, (data) => {
              callback({
                x: data[0] & 63,
                y: data[1] & 63,
                z: data[2] & 63
              });
            });
          }
        },
        toGravity: {
          value(value) {
            return toFixed(value / priv.get(this).sensitivity, 3);
          }
        }
      },
      ESPLORA: {
        DEFAULTS: {
          value: {
            zeroV: [320, 330, 310],
            sensitivity: 170
          }
        },
        initialize: {
          value(options, callback) {
            this.pins = [5, 11, 6];
            analogInitialize.call(this, options, callback);
          }
        },
        toGravity: {
          value(value, axis) {
            return toFixed(analogToGravity.call(this, value, axis), 2);
          }
        }
      },
      LIS3DH: {
        ADDRESSES: {
          value: [24]
        },
        REGISTER: {
          value: {
            OUT_X_L: 40,
            CTRL_REG1: 32,
            CTRL_REG2: 33,
            CTRL_REG3: 34,
            CTRL_REG4: 35,
            CTRL_REG5: 36,
            TEMP_CFG_REG: 31,
            CLICK_CFG: 56,
            CLICK_SRC: 57,
            CLICK_THS: 58,
            TIME_LIMIT: 59,
            TIME_LATENCY: 60,
            TIME_WINDOW: 61
          }
        },
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            const address = options.address || 24;
            let range = {
              2: 0,
              4: 1,
              8: 2,
              16: 3
            }[options.range || 4];
            if (range === void 0) {
              range = 1;
            }
            let divider = [
              16380,
              8190,
              4096,
              1365
            ][range];
            if (divider === void 0) {
              divider = 1;
            }
            let threshold = [
              80,
              40,
              20,
              10
            ][range];
            if (threshold === void 0) {
              threshold = 10;
            }
            state.divider = divider;
            state.expander = Expander.get({
              address,
              controller: this.controller,
              bus: this.bus,
              board: options.board || this.board
            });
            const ctrl4 = 136 | range << 4;
            state.expander.i2cWrite(address, this.REGISTER.CTRL_REG4, ctrl4);
            state.expander.i2cReadOnce(address, this.REGISTER.CTRL_REG1, 1, (data) => {
              let ctrl1 = data[0];
              ctrl1 &= ~240;
              ctrl1 |= 6 << 4;
              state.expander.i2cWrite(address, this.REGISTER.CTRL_REG1, ctrl1);
              state.expander.i2cRead(address, this.REGISTER.OUT_X_L | 128, 6, (data2) => {
                callback({
                  x: int16(data2[1], data2[0]),
                  y: int16(data2[3], data2[2]),
                  z: int16(data2[5], data2[4])
                });
              });
              state.expander.i2cWrite(address, this.REGISTER.CTRL_REG3, 128);
              state.expander.i2cWrite(address, this.REGISTER.CTRL_REG5, 8);
              state.expander.i2cWrite(address, this.REGISTER.CLICK_CFG, 42);
              const timelimit = 10;
              const timelatency = 20;
              const timewindow = 255;
              state.expander.i2cWrite(address, this.REGISTER.CLICK_THS, threshold);
              state.expander.i2cWrite(address, this.REGISTER.TIME_LIMIT, timelimit);
              state.expander.i2cWrite(address, this.REGISTER.TIME_LATENCY, timelatency);
              state.expander.i2cWrite(address, this.REGISTER.TIME_WINDOW, timewindow);
              let lastEmitTime = null;
              state.expander.i2cRead(address, this.REGISTER.CLICK_SRC, 1, (data2) => {
                const status = data2[0];
                const thisEmitTime = Date.now();
                if (lastEmitTime === null) {
                  lastEmitTime = thisEmitTime - 101;
                }
                if (thisEmitTime < lastEmitTime + 100) {
                  return;
                }
                if (status === 0) {
                  return;
                }
                if (!(status & 48)) {
                  return;
                }
                lastEmitTime = thisEmitTime;
                this.emit("tap");
                if (status & 16) {
                  this.emit("tap:single");
                }
                if (status & 32) {
                  this.emit("tap:single");
                  this.emit("tap:double");
                }
              });
            });
          }
        },
        toGravity: {
          value(raw) {
            return toFixed(raw / priv.get(this).divider, 3);
          }
        }
      },
      LSM303C: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "LSM303C", options).on("data", ({ accelerometer }) => callback(accelerometer));
          }
        },
        toGravity: {
          value(raw) {
            return toFixed(raw, 2);
          }
        }
      }
    };
    Controllers.TINKERKIT = Controllers.ANALOG;
    Controllers.MMA8452Q = Controllers.MMA8452;
    Controllers.DEFAULT = Controllers.ANALOG;
    function magnitude(x, y, z) {
      let a;
      a = x * x;
      a = fma(y, y, a);
      a = fma(z, z, a);
      return Math.sqrt(a);
    }
    var Accelerometer = class extends Emitter {
      constructor(options) {
        super();
        const state = {
          enabled: true,
          x: {
            value: 0,
            previous: 0,
            stash: [],
            orientation: null,
            inclination: null,
            acceleration: null,
            calibration: []
          },
          y: {
            value: 0,
            previous: 0,
            stash: [],
            orientation: null,
            inclination: null,
            acceleration: null,
            calibration: []
          },
          z: {
            value: 0,
            previous: 0,
            stash: [],
            orientation: null,
            inclination: null,
            acceleration: null,
            calibration: []
          }
        };
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        if (!this.toGravity) {
          this.toGravity = options.toGravity || ((x) => x);
        }
        if (!this.enabledChanged) {
          this.enabledChanged = () => {
          };
        }
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            let isChange = false;
            if (!state.enabled) {
              return;
            }
            Object.keys(data).forEach((axis) => {
              const value = data[axis];
              const sensor = state[axis];
              if (options.autoCalibrate && sensor.calibration.length < calibrationSize) {
                const axisIndex = axes.indexOf(axis);
                sensor.calibration.push(value);
                if (!Array.isArray(state.zeroV)) {
                  state.zeroV = [];
                }
                state.zeroV[axisIndex] = sum(sensor.calibration) / sensor.calibration.length;
                if (axis === aZ) {
                  state.zeroV[axisIndex] -= state.sensitivity;
                }
              }
              if (sensor.stash.length === 0) {
                for (let i = 0; i < 5; i++) {
                  sensor.stash[i] = value;
                }
              }
              sensor.previous = sensor.value;
              sensor.stash.shift();
              sensor.stash.push(value);
              sensor.value = sum(sensor.stash) / 5 | 0;
              if (this.acceleration !== sensor.acceleration) {
                sensor.acceleration = this.acceleration;
                isChange = true;
                this.emit("acceleration", sensor.acceleration);
              }
              if (this.orientation !== sensor.orientation) {
                sensor.orientation = this.orientation;
                isChange = true;
                this.emit("orientation", sensor.orientation);
              }
              if (this.inclination !== sensor.inclination) {
                sensor.inclination = this.inclination;
                isChange = true;
                this.emit("inclination", sensor.inclination);
              }
            });
            this.emit("data", {
              x: state.x.value,
              y: state.y.value,
              z: state.z.value
            });
            if (isChange) {
              this.emit("change", {
                x: this.x,
                y: this.y,
                z: this.z
              });
            }
          });
        }
        Object.defineProperties(this, {
          hasAxis: {
            writable: true,
            value(axis) {
              return state[axis] ? state[axis].stash.length > 0 : false;
            }
          },
          enable: {
            value() {
              state.enabled = true;
              this.enabledChanged(true);
              return this;
            }
          },
          disable: {
            value() {
              state.enabled = false;
              this.enabledChanged(false);
              return this;
            }
          },
          zeroV: {
            get() {
              return state.zeroV;
            }
          },
          pitch: {
            get() {
              const x = this.x;
              const y = this.y;
              const z = this.z;
              const rads = this.hasAxis(aZ) ? Math.atan2(x, Math.hypot(y, z)) : Math.asin(constrain(x, -1, 1));
              return toFixed(rads * RAD_TO_DEG, 2);
            }
          },
          roll: {
            get() {
              const x = this.x;
              const y = this.y;
              const z = this.z;
              const rads = this.hasAxis(aZ) ? Math.atan2(y, Math.hypot(x, z)) : Math.asin(constrain(y, -1, 1));
              return toFixed(rads * RAD_TO_DEG, 2);
            }
          },
          x: {
            get() {
              return this.toGravity(state.x.value, aX);
            }
          },
          y: {
            get() {
              return this.toGravity(state.y.value, aY);
            }
          },
          z: {
            get() {
              return this.hasAxis(aZ) ? this.toGravity(state.z.value, aZ) : 0;
            }
          },
          acceleration: {
            get() {
              return magnitude(this.x, this.y, this.z);
            }
          },
          inclination: {
            get() {
              return Math.atan2(this.y, this.x) * RAD_TO_DEG;
            }
          },
          orientation: {
            get() {
              const abs = Math.abs;
              const x = this.x;
              const y = this.y;
              const z = this.hasAxis(aZ) ? this.z : 1;
              const absX = abs(x);
              const absY = abs(y);
              const absZ = abs(z);
              if (absX < absY && absX < absZ) {
                if (x > 0) {
                  return 1;
                }
                return -1;
              }
              if (absY < absX && absY < absZ) {
                if (y > 0) {
                  return 2;
                }
                return -2;
              }
              if (absZ < absX && absZ < absY) {
                if (z > 0) {
                  return 3;
                }
                return -3;
              }
              return 0;
            }
          }
        });
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Accelerometer.Controllers = Controllers;
      Accelerometer.purge = function() {
        priv.clear();
      };
    }
    module2.exports = Accelerometer;
  }
});

// node_modules/johnny-five/lib/altimeter.js
var require_altimeter = __commonJS({
  "node_modules/johnny-five/lib/altimeter.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var { toFixed } = require_fn();
    var priv = new Map();
    var Controllers = {
      MPL3115A2: {
        requirements: {
          value: {
            options: {
              elevation: {
                throws: false,
                message: "Missing `elevation` option. Without a specified base `elevation`, the altitude measurement will be inaccurate. Use the meters value shown on whatismyelevation.com",
                typeof: "number"
              }
            }
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MPL3115A2", options).on("data", ({ altitude }) => callback(altitude));
          }
        },
        toMeters: {
          writable: true,
          value(value) {
            return toFixed(value, 1);
          }
        }
      },
      MS5611: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MS5611", options).on("data", ({ altitude }) => callback(altitude));
          }
        },
        toMeters: {
          writable: true,
          value(value) {
            return toFixed(value, 2);
          }
        }
      },
      BMP180: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BMP180", options).on("data", ({ altitude }) => callback(altitude));
          }
        },
        toMeters: {
          writable: true,
          value(value) {
            return toFixed(value, 2);
          }
        }
      },
      BMP280: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BMP280", options).on("data", ({ altitude }) => callback(altitude));
          }
        },
        toMeters: {
          writable: true,
          value(value) {
            return toFixed(value, 3);
          }
        }
      },
      BME280: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BME280", options).on("data", ({ altitude }) => callback(altitude));
          }
        },
        toMeters: {
          writable: true,
          value(value) {
            return toFixed(value, 3);
          }
        }
      }
    };
    Controllers["BMP085"] = Controllers["BMP-085"] = Controllers.BMP180;
    var Altimeter = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {};
        const freq = options.freq || 25;
        let last = null;
        let value = null;
        if (!this.toMeters) {
          this.toMeters = options.toMeters || ((x) => x);
        }
        priv.set(this, state);
        const descriptors = {
          meters: {
            get() {
              return this.toMeters(value);
            }
          },
          feet: {
            get() {
              return toFixed(this.meters * 3.28084, 2);
            }
          }
        };
        descriptors.m = descriptors.meters;
        descriptors.ft = descriptors.feet;
        Object.defineProperties(this, descriptors);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => value = data);
        }
        setInterval(() => {
          if (value == null) {
            return;
          }
          const data = {};
          data.m = data.meters = this.meters;
          data.ft = data.feet = this.feet;
          this.emit("data", data);
          if (this.meters !== last) {
            last = this.meters;
            this.emit("change", data);
          }
        }, freq);
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Altimeter.Controllers = Controllers;
      Altimeter.purge = function() {
        priv.clear();
      };
    }
    module2.exports = Altimeter;
  }
});

// node_modules/johnny-five/lib/barometer.js
var require_barometer = __commonJS({
  "node_modules/johnny-five/lib/barometer.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var { toFixed } = require_fn();
    var Controllers = {
      MPL115A2: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MPL115A2", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            return toFixed(65 / 1023 * value + 50, 2);
          }
        }
      },
      MPL3115A2: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MPL3115A2", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            const inches = value / 4 / 3377;
            const output = inches * 3.39;
            return toFixed(output, 4);
          }
        }
      },
      BMP180: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BMP180", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            return toFixed(value / 1e3, 3);
          }
        }
      },
      BMP280: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BMP280", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            return toFixed(value / 1e3, 5);
          }
        }
      },
      BME280: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BME280", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            return toFixed(value / 1e3, 5);
          }
        }
      },
      MS5611: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "MS5611", options).on("data", ({ pressure }) => callback(pressure));
          }
        },
        toPressure: {
          value(value) {
            return toFixed(value / 1e3, 4);
          }
        }
      }
    };
    Controllers.BMP085 = Controllers.BMP180;
    var Barometer = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const freq = options.freq || 25;
        let last = null;
        let raw = null;
        if (!this.toPressure) {
          this.toPressure = options.toPressure || ((x) => x);
        }
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
          });
        }
        Object.defineProperties(this, {
          pressure: {
            get() {
              return this.toPressure(raw);
            }
          }
        });
        setInterval(() => {
          if (raw === null) {
            return;
          }
          const data = {
            pressure: this.pressure
          };
          this.emit("data", data);
          if (this.pressure !== last) {
            last = this.pressure;
            this.emit("change", data);
          }
        }, freq);
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Barometer.Controllers = Controllers;
      Barometer.purge = function() {
      };
    }
    module2.exports = Barometer;
  }
});

// node_modules/johnny-five/lib/gyro.js
var require_gyro = __commonJS({
  "node_modules/johnny-five/lib/gyro.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var sum = Fn.sum;
    var toFixed = Fn.toFixed;
    var priv = new Map();
    var axes = ["x", "y", "z"];
    var Controllers = {
      ANALOG: {
        initialize: {
          value(options, callback) {
            const pins = options.pins || [];
            let sensitivity;
            let resolution;
            const state = priv.get(this);
            const dataPoints = {};
            if (options.sensitivity === void 0) {
              throw new Error("Expected a Sensitivity");
            }
            sensitivity = options.sensitivity;
            resolution = options.resolution || 4.88;
            state.K = resolution / sensitivity;
            pins.forEach(function(pin, index) {
              this.io.pinMode(pin, this.io.MODES.ANALOG);
              this.io.analogRead(pin, (data) => {
                const axis = axes[index];
                dataPoints[axis] = data;
                callback(dataPoints);
              });
            }, this);
          }
        },
        toNormal: {
          value(raw) {
            return raw >> 2;
          }
        },
        toDegreesPerSecond: {
          value(raw, rawCenter) {
            const normal = this.toNormal(raw);
            const center = this.toNormal(rawCenter);
            const state = priv.get(this);
            return (normal - center) * state.K | 0;
          }
        }
      },
      MPU6050: {
        initialize: {
          value(options, callback) {
            const IMU = require_sip();
            const state = priv.get(this);
            const driver = IMU.Drivers.get(this.board, "MPU6050", options);
            state.sensitivity = options.sensitivity || 131;
            driver.on("data", ({ gyro }) => {
              callback(gyro);
            });
          }
        },
        toNormal: {
          value(raw) {
            return (raw >> 11) + 127;
          }
        },
        toDegreesPerSecond: {
          value(raw, rawCenter) {
            const state = priv.get(this);
            return toFixed((raw - rawCenter) / state.sensitivity, 4);
          }
        }
      },
      BNO055: {
        initialize: {
          value(options, callback) {
            const IMU = require_sip();
            const state = priv.get(this);
            const driver = IMU.Drivers.get(this.board, "BNO055", options);
            state.sensitivity = 16;
            driver.on("data", ({ gyro }) => {
              callback(gyro);
            });
          }
        },
        toNormal: {
          value(raw) {
            return raw;
          }
        },
        toDegreesPerSecond: {
          value(raw) {
            const state = priv.get(this);
            return toFixed(raw / state.sensitivity, 4);
          }
        }
      }
    };
    Controllers.DEFAULT = Controllers.ANALOG;
    var Gyro = class extends Emitter {
      constructor(options) {
        super();
        let isCalibrated = false;
        const sampleSize = 100;
        const state = {
          x: {
            angle: 0,
            value: 0,
            previous: 0,
            calibration: [],
            stash: [0, 0, 0, 0, 0],
            center: 0,
            hasValue: false
          },
          y: {
            angle: 0,
            value: 0,
            previous: 0,
            calibration: [],
            stash: [0, 0, 0, 0, 0],
            center: 0,
            hasValue: false
          },
          z: {
            angle: 0,
            value: 0,
            previous: 0,
            calibration: [],
            stash: [0, 0, 0, 0, 0],
            center: 0,
            hasValue: false
          }
        };
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        if (!this.toNormal) {
          this.toNormal = options.toNormal || ((raw) => raw);
        }
        if (!this.toDegreesPerSecond) {
          this.toDegreesPerSecond = options.toDegreesPerSecond || ((raw) => raw);
        }
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            let isChange = false;
            Object.keys(data).forEach((axis) => {
              const value = data[axis];
              const sensor = state[axis];
              sensor.previous = sensor.value;
              sensor.stash.shift();
              sensor.stash.push(value);
              sensor.hasValue = true;
              sensor.value = sum(sensor.stash) / 5 | 0;
              if (!isCalibrated && (state.x.calibration.length === sampleSize && state.y.calibration.length === sampleSize && (this.z === void 0 || state.z.calibration.length === sampleSize))) {
                isCalibrated = true;
                state.x.center = sum(state.x.calibration) / sampleSize | 0;
                state.y.center = sum(state.y.calibration) / sampleSize | 0;
                state.z.center = sum(state.z.calibration) / sampleSize | 0;
                state.x.calibration.length = 0;
                state.y.calibration.length = 0;
                state.z.calibration.length = 0;
              } else {
                if (sensor.calibration.length < sampleSize) {
                  sensor.calibration.push(value);
                }
              }
              if (sensor.previous !== sensor.value) {
                isChange = true;
              }
            });
            if (isCalibrated) {
              state.x.angle += this.rate.x / 100;
              state.y.angle += this.rate.y / 100;
              state.z.angle += this.rate.z / 100;
              this.emit("data", {
                x: this.x,
                y: this.y,
                z: this.z
              });
              if (isChange) {
                this.emit("change", {
                  x: this.x,
                  y: this.y,
                  z: this.z
                });
              }
            }
          });
        }
        Object.defineProperties(this, {
          isCalibrated: {
            get() {
              return isCalibrated;
            },
            set(value) {
              if (typeof value === "boolean") {
                isCalibrated = value;
              }
            }
          },
          pitch: {
            get() {
              return {
                rate: toFixed(this.rate.y, 2),
                angle: toFixed(state.y.angle, 2)
              };
            }
          },
          roll: {
            get() {
              return {
                rate: toFixed(this.rate.x, 2),
                angle: toFixed(state.x.angle, 2)
              };
            }
          },
          yaw: {
            get() {
              return {
                rate: this.z !== void 0 ? toFixed(this.rate.z, 2) : 0,
                angle: this.z !== void 0 ? toFixed(state.z.angle, 2) : 0
              };
            }
          },
          x: {
            get() {
              return toFixed(this.toNormal(state.x.value), 4);
            }
          },
          y: {
            get() {
              return toFixed(this.toNormal(state.y.value), 4);
            }
          },
          z: {
            get() {
              return state.z.hasValue ? toFixed(this.toNormal(state.z.value), 4) : void 0;
            }
          },
          rate: {
            get() {
              const x = this.toDegreesPerSecond(state.x.value, state.x.center);
              const y = this.toDegreesPerSecond(state.y.value, state.y.center);
              const z = state.z.hasValue ? this.toDegreesPerSecond(state.z.value, state.z.center) : 0;
              return {
                x,
                y,
                z
              };
            }
          }
        });
      }
      recalibrate() {
        this.isCalibrated = false;
      }
    };
    Object.defineProperties(Gyro, {
      TK_4X: {
        value: 0.67
      },
      TK_1X: {
        value: 0.167
      }
    });
    if (!!process.env.IS_TEST_MODE) {
      Gyro.Controllers = Controllers;
      Gyro.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Gyro;
  }
});

// node_modules/johnny-five/lib/hygrometer.js
var require_hygrometer = __commonJS({
  "node_modules/johnny-five/lib/hygrometer.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var priv = new Map();
    var {
      toFixed,
      POW_2_14,
      POW_2_16
    } = Fn;
    var writable = true;
    var Controllers = {
      SHT31D: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "SHT31D", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            return toFixed(100 * (value / (POW_2_16 - 1)), 2);
          }
        }
      },
      HTU21D: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "HTU21D", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            return toFixed(-6 + 125 * (value / POW_2_16), 2);
          }
        }
      },
      HIH6130: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "HIH6130", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            return toFixed(value / (POW_2_14 - 1) * 100, 2);
          }
        }
      },
      DHT_I2C_NANO_BACKPACK: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "DHT_I2C_NANO_BACKPACK", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(raw) {
            return toFixed(raw / 100, 1);
          }
        }
      },
      TH02: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "TH02", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            if (value > 100) {
              value = 0;
            }
            return toFixed(value || 0, 2);
          }
        }
      },
      SI7020: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "SI7020", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            return toFixed(125 * value / POW_2_16 - 6, 2);
          }
        }
      },
      BME280: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "BME280", options).on("data", ({ humidity }) => callback(humidity));
          }
        },
        toRelativeHumidity: {
          writable,
          value(value) {
            return toFixed(value / 1024, 3);
          }
        }
      }
    };
    Controllers.DHT11_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT21_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT22_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.SI7021 = Controllers.SI7020;
    var Hygrometer = class extends Emitter {
      constructor(options) {
        super();
        const freq = options.freq || 25;
        let last = null;
        let raw = null;
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        priv.set(this, {});
        if (!this.toRelativeHumidity) {
          this.toRelativeHumidity = options.toRelativeHumidity || ((x) => x);
        }
        const propDescriptors = {
          relativeHumidity: {
            get() {
              return this.toRelativeHumidity(raw);
            }
          }
        };
        propDescriptors.RH = propDescriptors.relativeHumidity;
        Object.defineProperties(this, propDescriptors);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
          });
        }
        setInterval(() => {
          if (raw == null) {
            return;
          }
          if (Number.isNaN(this.relativeHumidity)) {
            return;
          }
          const data = {};
          data.RH = data.relativeHumidity = this.relativeHumidity;
          this.emit("data", data);
          if (this.relativeHumidity !== last) {
            last = this.relativeHumidity;
            this.emit("change", data);
          }
        }, freq);
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Hygrometer.Controllers = Controllers;
      Hygrometer.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Hygrometer;
  }
});

// node_modules/johnny-five/lib/compass.js
var require_compass = __commonJS({
  "node_modules/johnny-five/lib/compass.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var { int16, RAD_TO_DEG, TAU } = require_fn();
    var priv = new Map();
    var Controllers = {
      HMC5883L: {
        REGISTER: {
          value: {
            CRA: 0,
            CRB: 1,
            MODE: 2,
            READ: 3
          }
        },
        initialize: {
          value(opts, dataHandler) {
            const state = priv.get(this);
            const address = opts.address || 30;
            const READLENGTH = 6;
            state.scale = 1;
            Object.assign(state, new Compass.Scale(opts.gauss || 0.88));
            opts.address = address;
            this.io.i2cConfig(opts);
            this.io.i2cWrite(address, this.REGISTER.CRA, 112);
            this.io.i2cWrite(address, this.REGISTER.CRB, 64);
            this.io.i2cWrite(address, this.REGISTER.MODE, 0);
            this.io.i2cRead(address, this.REGISTER.READ, READLENGTH, (bytes) => {
              dataHandler({
                x: int16(bytes[0], bytes[1]),
                y: int16(bytes[4], bytes[5]),
                z: int16(bytes[2], bytes[3])
              });
            });
          }
        },
        toScaledHeading: {
          value({ x, y }) {
            const state = priv.get(this);
            return ToHeading(x * state.scale, y * state.scale);
          }
        }
      },
      HMC6352: {
        REGISTER: {
          value: {
            READ: 65
          }
        },
        initialize: {
          value(opts, dataHandler) {
            const state = priv.get(this);
            const address = opts.address || 33;
            const READLENGTH = 2;
            state.scale = 1;
            opts.delay = 10;
            opts.address = address;
            this.io.i2cConfig(opts);
            this.io.i2cWrite(address, this.REGISTER.READ);
            this.io.i2cRead(address, this.REGISTER.READ, READLENGTH, (bytes) => {
              dataHandler({
                x: ((bytes[0] << 8) + bytes[1]) / 10 | 0,
                y: null,
                z: null
              });
            });
          }
        },
        toScaledHeading: {
          value({ x }) {
            const state = priv.get(this);
            return x * state.scale;
          }
        }
      },
      BNO055: {
        initialize: {
          value(opts, dataHandler) {
            const IMU = require_sip();
            const driver = IMU.Drivers.get(this.board, "BNO055", opts);
            const state = priv.get(this);
            state.sensitivity = 16;
            driver.on("data", ({ magnetometer }) => {
              dataHandler(magnetometer);
            });
          }
        },
        toScaledHeading: {
          value(raw) {
            const state = priv.get(this);
            const x = raw.x / state.sensitivity;
            const y = raw.y / state.sensitivity;
            return ToHeading(x, y);
          }
        }
      },
      MAG3110: {
        REGISTER: {
          value: {
            STATUS: 0,
            READ: 1,
            OFFSETS: 9,
            CTRL_REG1: 16,
            CTRL_REG2: 17
          }
        },
        initialize: {
          value(opts, dataHandler) {
            const state = priv.get(this);
            const address = 14;
            let isDataPending = false;
            let temp;
            state.isCalibrated = false;
            state.isPreCalibrated = false;
            state.hasEmittedCalibration = false;
            state.measurements = 20;
            state.offsets = {
              x: 0,
              y: 0,
              z: 0
            };
            state.accum = {
              x: { offset: null, high: 0, low: 0 },
              y: { offset: null, high: 0, low: 0 },
              z: { offset: null, high: 0, low: 0 }
            };
            opts.delay = 2;
            opts.address = address;
            if (opts.offsets) {
              state.isCalibrated = true;
              state.isPreCalibrated = true;
              if (Array.isArray(opts.offsets)) {
                temp = opts.offsets.slice();
                opts.offsets = {
                  x: temp[0],
                  y: temp[1],
                  z: temp[2]
                };
              }
              state.accum.x.low = opts.offsets.x[0];
              state.accum.x.high = opts.offsets.x[1];
              state.accum.x.offset = (state.accum.x.low + state.accum.x.high) / 2;
              state.accum.y.low = opts.offsets.y[0];
              state.accum.y.high = opts.offsets.y[1];
              state.accum.y.offset = (state.accum.y.low + state.accum.y.high) / 2;
              state.accum.z.low = opts.offsets.z[0];
              state.accum.z.high = opts.offsets.z[1];
              state.accum.z.offset = (state.accum.z.low + state.accum.z.high) / 2;
            }
            this.io.i2cConfig(opts);
            this.io.i2cWrite(address, this.REGISTER.CTRL_REG2, 128);
            this.io.i2cWrite(address, this.REGISTER.CTRL_REG1, 1);
            const measured = {
              x: 0,
              y: 0,
              z: 0
            };
            const readCycle = () => {
              this.io.i2cReadOnce(address, this.REGISTER.STATUS, 1, (data) => {
                if (!isDataPending && (data[0] === 15 || data[0] === 255)) {
                  isDataPending = true;
                  this.io.i2cReadOnce(address, this.REGISTER.READ, 6, (bytes) => {
                    let timeout = 0;
                    isDataPending = false;
                    measured.x = int16(bytes[0], bytes[1]);
                    measured.y = int16(bytes[2], bytes[3]);
                    measured.z = int16(bytes[4], bytes[5]);
                    if (!state.isCalibrated) {
                      if (state.accum.x.offset === null) {
                        state.accum.x.offset = measured.x;
                        state.accum.x.low = measured.x;
                        state.accum.x.high = measured.x;
                      }
                      if (state.accum.y.offset === null) {
                        state.accum.y.offset = measured.y;
                        state.accum.y.low = measured.y;
                        state.accum.y.high = measured.y;
                      }
                      state.accum.x.low = Math.min(state.accum.x.low, measured.x);
                      state.accum.x.high = Math.max(state.accum.x.high, measured.x);
                      state.accum.x.offset = Math.trunc((state.accum.x.low + state.accum.x.high) / 2);
                      state.accum.y.low = Math.min(state.accum.y.low, measured.y);
                      state.accum.y.high = Math.max(state.accum.y.high, measured.y);
                      state.accum.y.offset = Math.trunc((state.accum.y.low + state.accum.y.high) / 2);
                      state.accum.z.low = Math.min(state.accum.z.low, measured.z);
                      state.accum.z.high = Math.max(state.accum.z.high, measured.z);
                      state.accum.z.offset = Math.trunc((state.accum.z.low + state.accum.z.high) / 2);
                      --state.measurements;
                      if (!state.measurements) {
                        state.isCalibrated = true;
                      }
                    }
                    if (state.isCalibrated) {
                      if (!state.hasEmittedCalibration) {
                        state.hasEmittedCalibration = true;
                        state.offsets.x = state.accum.x.offset;
                        state.offsets.y = state.accum.y.offset;
                        state.offsets.z = state.accum.z.offset;
                        this.io.i2cWrite(address, this.REGISTER.OFFSETS, [
                          state.offsets.x >> 7,
                          state.offsets.x << 1 & 255,
                          state.offsets.y >> 7,
                          state.offsets.y << 1 & 255,
                          state.offsets.z >> 7,
                          state.offsets.z << 1 & 255
                        ]);
                        this.emit("calibrated", {
                          x: [state.accum.x.low, state.accum.x.high],
                          y: [state.accum.y.low, state.accum.y.high],
                          z: [state.accum.z.low, state.accum.z.high]
                        });
                      }
                      timeout = Math.floor(1e3 / 80);
                      dataHandler(measured);
                    }
                    setTimeout(readCycle, timeout);
                  });
                } else {
                  readCycle();
                }
              });
            };
            readCycle();
          }
        },
        calibrate: {
          value(measurements) {
            const state = priv.get(this);
            state.isCalibrated = false;
            state.measurements = measurements;
          }
        },
        toScaledHeading: {
          value({ y, x }) {
            const state = priv.get(this);
            const scale = {
              x: 1 / (state.accum.x.high - state.accum.x.low),
              y: 1 / (state.accum.y.high - state.accum.y.low)
            };
            let heading = Math.atan2(-y * scale.y, x * scale.x);
            if (heading < 0) {
              heading += TAU;
            }
            return Math.trunc(heading * RAD_TO_DEG);
          }
        }
      },
      LSM303C: {
        initialize: {
          value(opts, dataHandler) {
            const IMU = require_sip();
            const driver = IMU.Drivers.get(this.board, "LSM303C", opts);
            driver.on("data", ({ magnetometer }) => {
              dataHandler(magnetometer);
            });
          }
        },
        toScaledHeading: {
          value({ x, y }) {
            return ToHeading(x, y);
          }
        }
      }
    };
    var Compass = class extends Emitter {
      constructor(opts) {
        super();
        Board.Component.call(this, opts = Board.Options(opts));
        const freq = opts.freq || 25;
        let raw = {
          x: null,
          y: null,
          z: null
        };
        const state = {
          x: 0,
          y: 0,
          z: 0,
          scale: 0,
          register: 0,
          heading: 0
        };
        Board.Controller.call(this, Controllers, opts);
        if (!this.toScaledHeading) {
          this.toScaledHeading = opts.toScaledHeading || ((raw2) => raw2);
        }
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(opts, (data) => raw = data);
        }
        setInterval(() => {
          if (raw.x === null) {
            return;
          }
          let isChange = false;
          state.x = raw.x;
          state.y = raw.y;
          state.z = raw.z;
          const heading = this.heading;
          if (heading !== state.heading) {
            state.heading = heading;
            isChange = true;
          }
          this.emit("data", { heading });
          if (isChange) {
            this.emit("change", { heading });
          }
        }, freq);
        Object.defineProperties(this, {
          bearing: {
            get() {
              const length = Compass.Points.length;
              const heading = this.heading;
              let point;
              for (let i = 0; i < length; i++) {
                point = Compass.Points[i];
                if (heading >= point.low && heading <= point.high) {
                  return {
                    name: point.name,
                    abbr: point.abbr,
                    low: point.low,
                    high: point.high,
                    heading
                  };
                }
              }
            }
          },
          raw: {
            get() {
              return {
                x: raw.x,
                y: raw.y,
                z: raw.z
              };
            }
          },
          heading: {
            get() {
              return this.toScaledHeading(raw);
            }
          }
        });
      }
    };
    Compass.Scale = class {
      constructor(gauss) {
        if (gauss === 0.88) {
          this.register = 0;
          this.scale = 0.73;
        } else if (gauss === 1.3) {
          this.register = 1;
          this.scale = 0.92;
        } else if (gauss === 1.9) {
          this.register = 2;
          this.scale = 1.22;
        } else if (gauss === 2.5) {
          this.register = 3;
          this.scale = 1.52;
        } else if (gauss === 4) {
          this.register = 4;
          this.scale = 2.27;
        } else if (gauss === 4.7) {
          this.register = 5;
          this.scale = 2.56;
        } else if (gauss === 5.6) {
          this.register = 6;
          this.scale = 3.03;
        } else if (gauss === 8.1) {
          this.register = 7;
          this.scale = 4.35;
        } else {
          this.register = 0;
          this.scale = 1;
        }
        this.register = this.register << 5;
      }
    };
    function ToHeading(x, y) {
      let radians = Math.atan2(y, x);
      if (radians < 0) {
        radians += TAU;
      }
      if (radians > TAU) {
        radians -= TAU;
      }
      return radians * RAD_TO_DEG;
    }
    Compass.Points = [{
      name: "North",
      abbr: "N",
      low: 354.38,
      high: 360
    }, {
      name: "North",
      abbr: "N",
      low: 0,
      high: 5.62
    }, {
      name: "North by East",
      abbr: "NbE",
      low: 5.63,
      high: 16.87
    }, {
      name: "North-NorthEast",
      abbr: "NNE",
      low: 16.88,
      high: 28.12
    }, {
      name: "NorthEast by North",
      abbr: "NEbN",
      low: 28.13,
      high: 39.37
    }, {
      name: "NorthEast",
      abbr: "NE",
      low: 39.38,
      high: 50.62
    }, {
      name: "NorthEast by East",
      abbr: "NEbE",
      low: 50.63,
      high: 61.87
    }, {
      name: "East-NorthEast",
      abbr: "ENE",
      low: 61.88,
      high: 73.12
    }, {
      name: "East by North",
      abbr: "EbN",
      low: 73.13,
      high: 84.37
    }, {
      name: "East",
      abbr: "E",
      low: 84.38,
      high: 95.62
    }, {
      name: "East by South",
      abbr: "EbS",
      low: 95.63,
      high: 106.87
    }, {
      name: "East-SouthEast",
      abbr: "ESE",
      low: 106.88,
      high: 118.12
    }, {
      name: "SouthEast by East",
      abbr: "SEbE",
      low: 118.13,
      high: 129.37
    }, {
      name: "SouthEast",
      abbr: "SE",
      low: 129.38,
      high: 140.62
    }, {
      name: "SouthEast by South",
      abbr: "SEbS",
      low: 140.63,
      high: 151.87
    }, {
      name: "South-SouthEast",
      abbr: "SSE",
      low: 151.88,
      high: 163.12
    }, {
      name: "South by East",
      abbr: "SbE",
      low: 163.13,
      high: 174.37
    }, {
      name: "South",
      abbr: "S",
      low: 174.38,
      high: 185.62
    }, {
      name: "South by West",
      abbr: "SbW",
      low: 185.63,
      high: 196.87
    }, {
      name: "South-SouthWest",
      abbr: "SSW",
      low: 196.88,
      high: 208.12
    }, {
      name: "SouthWest by South",
      abbr: "SWbS",
      low: 208.13,
      high: 219.37
    }, {
      name: "SouthWest",
      abbr: "SW",
      low: 219.38,
      high: 230.62
    }, {
      name: "SouthWest by West",
      abbr: "SWbW",
      low: 230.63,
      high: 241.87
    }, {
      name: "West-SouthWest",
      abbr: "WSW",
      low: 241.88,
      high: 253.12
    }, {
      name: "West by South",
      abbr: "WbS",
      low: 253.13,
      high: 264.37
    }, {
      name: "West",
      abbr: "W",
      low: 264.38,
      high: 275.62
    }, {
      name: "West by North",
      abbr: "WbN",
      low: 275.63,
      high: 286.87
    }, {
      name: "West-NorthWest",
      abbr: "WNW",
      low: 286.88,
      high: 298.12
    }, {
      name: "NorthWest by West",
      abbr: "NWbW",
      low: 298.13,
      high: 309.37
    }, {
      name: "NorthWest",
      abbr: "NW",
      low: 309.38,
      high: 320.62
    }, {
      name: "NorthWest by North",
      abbr: "NWbN",
      low: 320.63,
      high: 331.87
    }, {
      name: "North-NorthWest",
      abbr: "NNW",
      low: 331.88,
      high: 343.12
    }, {
      name: "North by West",
      abbr: "NbW",
      low: 343.13,
      high: 354.37
    }];
    Object.freeze(Compass.Points);
    if (!!process.env.IS_TEST_MODE) {
      Compass.Controllers = Controllers;
      Compass.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Compass;
  }
});

// node_modules/johnny-five/lib/orientation.js
var require_orientation = __commonJS({
  "node_modules/johnny-five/lib/orientation.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var priv = new Map();
    var Controllers = {
      BNO055: {
        initialize: {
          value(options, dataHandler) {
            const IMU = require_sip();
            const driver = IMU.Drivers.get(this.board, "BNO055", options);
            driver.on("data", (data) => {
              dataHandler(data);
            });
          }
        },
        toScaledEuler: {
          value({ euler }) {
            return {
              heading: euler.heading / 16,
              roll: euler.roll / 16,
              pitch: euler.pitch / 16
            };
          }
        },
        toScaledQuarternion: {
          value({ quarternion }) {
            return {
              w: quarternion.w * (1 / (1 << 14)),
              x: quarternion.x * (1 / (1 << 14)),
              y: quarternion.y * (1 / (1 << 14)),
              z: quarternion.z * (1 / (1 << 14))
            };
          }
        },
        calibration: {
          get() {
            return priv.get(this).calibration;
          }
        },
        isCalibrated: {
          get() {
            return (this.calibration >> 6 & 3) === 3;
          }
        }
      }
    };
    var Orientation = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const freq = options.freq || 25;
        const state = {
          euler: {
            heading: 0,
            roll: 0,
            pitch: 0
          },
          quarternion: {
            w: 0,
            x: 0,
            y: 0,
            z: 0
          },
          calibration: 0
        };
        let raw = null;
        priv.set(this, state);
        if (!this.toScaledQuarternion) {
          this.toScaledQuarternion = options.toScaledQuarternion || ((x) => x);
        }
        if (!this.toScaledEuler) {
          this.toScaledEuler = options.toScaledEuler || ((x) => x);
        }
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => raw = data);
        }
        setInterval(() => {
          if (raw === null) {
            return;
          }
          let didOrientationChange = false;
          let didCalibrationChange = false;
          ["heading", "roll", "pitch"].forEach((el) => {
            if (state.euler[el] !== raw.orientation.euler[el]) {
              didOrientationChange = true;
            }
            state.euler[el] = raw.orientation.euler[el];
          });
          ["w", "x", "y", "z"].forEach((el) => {
            if (state.quarternion[el] !== raw.orientation.quarternion[el]) {
              didOrientationChange = true;
            }
            state.quarternion[el] = raw.orientation.quarternion[el];
          });
          if (raw.calibration) {
            if (state.calibration !== raw.calibration) {
              didCalibrationChange = true;
            }
            state.calibration = raw.calibration;
          }
          const data = {
            euler: this.euler,
            quarternion: this.quarternion,
            calibration: this.calibration
          };
          this.emit("data", data);
          if (didOrientationChange) {
            this.emit("change", data);
          }
          if (didCalibrationChange) {
            this.emit("calibration", this.calibration);
          }
        }, freq);
      }
      get euler() {
        return this.toScaledEuler(priv.get(this));
      }
      get quarternion() {
        return this.toScaledQuarternion(priv.get(this));
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Orientation.Controllers = Controllers;
      Orientation.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Orientation;
  }
});

// node_modules/johnny-five/lib/mixins/withinable.js
var require_withinable = __commonJS({
  "node_modules/johnny-five/lib/mixins/withinable.js"(exports, module2) {
    var Emitter = require_emitter();
    var Withinable = class extends Emitter {
      constructor() {
        super();
      }
      within(range, unit, callback) {
        let upper;
        if (typeof range === "number") {
          upper = range;
          range = [0, upper];
        }
        if (!Array.isArray(range)) {
          throw new Error("within expected a range array");
        }
        if (typeof unit === "function") {
          callback = unit;
          unit = "value";
        }
        if (typeof this[unit] === "undefined") {
          return this;
        }
        this.on("data", () => {
          const value = this[unit];
          if (value >= range[0] && value <= range[1]) {
            callback.call(this, null, value);
          }
        });
        return this;
      }
    };
    module2.exports = Withinable;
  }
});

// node_modules/johnny-five/lib/thermometer.js
var require_thermometer = __commonJS({
  "node_modules/johnny-five/lib/thermometer.js"(exports, module2) {
    var Board = require_board();
    var EventEmitter10 = require("events");
    var Withinable = require_withinable();
    var {
      toFixed,
      POW_2_16
    } = require_fn();
    var {
      log,
      round,
      trunc
    } = Math;
    var CELSIUS_TO_KELVIN = 273.15;
    function analogHandler(options, callback) {
      const pin = options.pin;
      this.io.pinMode(pin, this.io.MODES.ANALOG);
      this.io.analogRead(pin, (data) => {
        callback.call(this, data);
      });
    }
    var activeDrivers = new Map();
    var Drivers = {
      MAX31850K: {
        initialize: {
          value(board, options) {
            const CONSTANTS = {
              TEMPERATURE_FAMILY: 59,
              CONVERT_TEMPERATURE_COMMAND: 68,
              READ_SCRATCHPAD_COMMAND: 190,
              READ_COUNT: 9
            };
            const pin = options.pin;
            const freq = options.freq || 100;
            const getAddress = (device) => {
              let result = 0;
              for (let i = 6; i > 0; i--) {
                result = result * 256 + device[i];
              }
              return result;
            };
            board.io.sendOneWireConfig(pin, true);
            board.io.sendOneWireSearch(pin, (err, devices) => {
              if (err) {
                this.emit("error", err);
                return;
              }
              this.devices = devices.filter((device) => device[0] === CONSTANTS.TEMPERATURE_FAMILY, this);
              if (devices.length === 0) {
                this.emit("error", new Error("FAILED TO FIND TEMPERATURE DEVICE"));
                return;
              }
              this.devices.forEach((device) => {
                this.emit("initialized", getAddress(device));
              });
              let getAddresses = () => {
                if (this.addresses) {
                  return this.devices.filter(function(device) {
                    const address = getAddress(device);
                    return this.addresses.includes(address);
                  }, this);
                } else {
                  return [this.devices[0]];
                }
              };
              let readTemperature = () => {
                let result;
                let devicesToWait = getAddresses();
                let devicesToRead = getAddresses();
                devicesToRead.forEach((device) => {
                  board.io.sendOneWireReset(pin);
                  board.io.sendOneWireWrite(pin, device, CONSTANTS.CONVERT_TEMPERATURE_COMMAND);
                });
                let isConversionAvailable = (done) => {
                  let nextDevice;
                  if (devicesToWait.length === 0) {
                    return done();
                  }
                  nextDevice = devicesToWait.pop();
                  board.io.sendOneWireReset(pin);
                  board.io.sendOneWireWriteAndRead(pin, nextDevice, CONSTANTS.READ_SCRATCHPAD_COMMAND, CONSTANTS.READ_COUNT, (err2, data) => {
                    if (!data[0]) {
                      devicesToWait.push(nextDevice);
                      if (data[1] !== 0) {
                        return done();
                      }
                    }
                    isConversionAvailable(done);
                  });
                };
                let readOne = () => {
                  let device;
                  if (devicesToRead.length === 0) {
                    setTimeout(readTemperature, freq);
                    return;
                  }
                  device = devicesToRead.pop();
                  board.io.sendOneWireReset(pin);
                  board.io.sendOneWireWriteAndRead(pin, device, CONSTANTS.READ_SCRATCHPAD_COMMAND, CONSTANTS.READ_COUNT, (error, data) => {
                    if (error) {
                      this.emit("error", error);
                      return;
                    }
                    result = data[1] << 8 | data[0];
                    this.emit("data", getAddress(device), result);
                    readOne();
                  });
                };
                isConversionAvailable(readOne);
              };
              readTemperature();
            });
          }
        },
        register: {
          value(address) {
            if (!this.addresses) {
              this.addresses = [];
            }
            this.addresses.push(address);
          }
        }
      },
      DS18B20: {
        initialize: {
          value(board, options) {
            const CONSTANTS = {
              TEMPERATURE_FAMILY: 40,
              CONVERT_TEMPERATURE_COMMAND: 68,
              READ_SCRATCHPAD_COMMAND: 190,
              READ_COUNT: 2
            };
            const pin = options.pin;
            const freq = options.freq || 100;
            let getAddress;
            let readThermometer;
            let readOne;
            getAddress = (device) => {
              let i;
              let result = 0;
              for (i = 6; i > 0; i--) {
                result = result * 256 + device[i];
              }
              return result;
            };
            board.io.sendOneWireConfig(pin, true);
            board.io.sendOneWireSearch(pin, (err, devices) => {
              if (err) {
                this.emit("error", err);
                return;
              }
              this.devices = devices.filter((device) => device[0] === CONSTANTS.TEMPERATURE_FAMILY, this);
              if (devices.length === 0) {
                this.emit("error", new Error("FAILED TO FIND TEMPERATURE DEVICE"));
                return;
              }
              this.devices.forEach((device) => {
                this.emit("initialized", getAddress(device));
              });
              readThermometer = () => {
                let devicesToRead;
                let result;
                if (this.addresses) {
                  devicesToRead = this.devices.filter(function(device) {
                    const address = getAddress(device);
                    return this.addresses.includes(address);
                  }, this);
                } else {
                  devicesToRead = [this.devices[0]];
                }
                devicesToRead.forEach((device) => {
                  board.io.sendOneWireReset(pin);
                  board.io.sendOneWireWrite(pin, device, CONSTANTS.CONVERT_TEMPERATURE_COMMAND);
                });
                board.io.sendOneWireDelay(pin, 1);
                readOne = () => {
                  let device;
                  if (devicesToRead.length === 0) {
                    setTimeout(readThermometer, freq);
                    return;
                  }
                  device = devicesToRead.pop();
                  board.io.sendOneWireReset(pin);
                  board.io.sendOneWireWriteAndRead(pin, device, CONSTANTS.READ_SCRATCHPAD_COMMAND, CONSTANTS.READ_COUNT, (err2, data) => {
                    if (err2) {
                      this.emit("error", err2);
                      return;
                    }
                    result = data[1] << 8 | data[0];
                    this.emit("data", getAddress(device), result);
                    readOne();
                  });
                };
                readOne();
              };
              readThermometer();
            });
          }
        },
        register: {
          value(address) {
            if (!this.addresses) {
              this.addresses = [];
            }
            this.addresses.push(address);
          }
        }
      }
    };
    Drivers.get = (board, driverName, options) => {
      let drivers;
      let driver;
      if (!activeDrivers.has(board)) {
        activeDrivers.set(board, {});
      }
      drivers = activeDrivers.get(board);
      const key = `${driverName}_${options.pin}`;
      if (!drivers[key]) {
        driver = new EventEmitter10();
        Object.defineProperties(driver, Drivers[driverName]);
        driver.initialize(board, options);
        drivers[key] = driver;
      }
      return drivers[key];
    };
    Drivers.clear = () => {
      activeDrivers.clear();
    };
    var Controllers = {
      ANALOG: {
        initialize: {
          value: analogHandler
        }
      },
      LM35: {
        initialize: {
          value: analogHandler
        },
        toCelsius: {
          value(raw) {
            const mV = this.aref * 1e3 * raw / 1023;
            return round(mV / 10);
          }
        }
      },
      LM335: {
        initialize: {
          value: analogHandler
        },
        toCelsius: {
          value(raw) {
            const mV = this.aref * 1e3 * raw / 1023;
            return round(mV / 10 - CELSIUS_TO_KELVIN);
          }
        }
      },
      TMP36: {
        initialize: {
          value: analogHandler
        },
        toCelsius: {
          value(raw) {
            const mV = this.aref * 1e3 * raw / 1023;
            return round(mV / 10 - 50);
          }
        }
      },
      TMP102: {
        ADDRESSES: {
          value: [72]
        },
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            const address = Drivers2.addressResolver(this, options);
            this.io.i2cConfig(options);
            this.io.i2cRead(address, 0, 2, (data) => {
              let raw = (data[0] << 8 | data[1]) >> 4;
              if (raw & 1 << 11) {
                raw |= 63488;
              }
              raw = raw >> 15 ? ((raw ^ 65535) + 1) * -1 : raw;
              callback(raw);
            });
          }
        },
        toCelsius: {
          value(raw) {
            return toFixed(raw / 16, 1);
          }
        }
      },
      MAX31850K: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            const address = options.address;
            const driver = Drivers.get(this.board, "MAX31850K", options);
            if (address) {
              state.address = address;
              driver.register(address);
            } else {
              if (driver.addressless) {
                this.emit("error", "You cannot have more than one MAX31850K without an address");
              }
              driver.addressless = true;
            }
            driver.once("initialized", (dataAddress) => {
              if (!state.address) {
                state.address = dataAddress;
              }
            });
            driver.on("data", (dataAddress, data) => {
              if (!address || dataAddress === address) {
                callback(data);
              }
            });
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value / 16, 2);
          }
        },
        address: {
          get() {
            return priv.get(this).address || 0;
          }
        }
      },
      DS18B20: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            const address = options.address;
            const driver = Drivers.get(this.board, "DS18B20", options);
            if (address) {
              state.address = address;
              driver.register(address);
            } else {
              if (driver.addressless) {
                this.emit("error", "You cannot have more than one DS18B20 without an address");
              }
              driver.addressless = true;
            }
            driver.once("initialized", (dataAddress) => {
              if (!state.address) {
                state.address = dataAddress;
              }
            });
            driver.on("data", (dataAddress, data) => {
              if (!address || dataAddress === address) {
                callback(data);
              }
            });
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value / 16, 4);
          }
        },
        address: {
          get() {
            return priv.get(this).address || 0;
          }
        }
      },
      SHT31D: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "SHT31D", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(-45 + 175 * (value / (POW_2_16 - 1)), 3);
          }
        }
      },
      HTU21D: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "HTU21D", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(-46.85 + 175.72 * (value / POW_2_16), 2);
          }
        }
      },
      HIH6130: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "HIH6130", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return round(raw / 1e3);
          }
        }
      },
      DHT_I2C_NANO_BACKPACK: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "DHT_I2C_NANO_BACKPACK", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return round(raw / 100);
          }
        }
      },
      TH02: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "TH02", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return toFixed(raw, 1);
          }
        }
      },
      MPU6050: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "MPU6050", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return round(raw / 340 + 36.53);
          }
        }
      },
      BNO055: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "BNO055", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return trunc(raw);
          }
        }
      },
      MPL115A2: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "MPL115A2", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return trunc((raw - 498) / -5.35 + 25);
          }
        }
      },
      MPL3115A2: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "MPL3115A2", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return round(raw / 16);
          }
        }
      },
      MS5611: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "MS5611", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(raw) {
            return toFixed(raw, 2);
          }
        }
      },
      GROVE: {
        initialize: {
          value: analogHandler
        },
        toCelsius: {
          value(raw) {
            const adcres = 1023;
            const beta = 3975;
            const rb = 1e4;
            const tempr = 298.15;
            const rthermistor = (adcres - raw) * rb / raw;
            const tempc = 1 / (log(rthermistor / rb) / beta + 1 / tempr) - CELSIUS_TO_KELVIN;
            return round(tempc);
          }
        }
      },
      TINKERKIT: {
        initialize: {
          value: analogHandler
        },
        toCelsius: {
          value(value) {
            const adcres = 1023;
            const beta = 3950;
            const rb = 1e4;
            const ginf = 120.6685;
            const rthermistor = rb * (adcres / value - 1);
            const tempc = beta / log(rthermistor * ginf);
            return round(tempc - CELSIUS_TO_KELVIN);
          }
        }
      },
      BMP180: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "BMP180", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value, 1);
          }
        }
      },
      BMP280: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "BMP280", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value, 2);
          }
        }
      },
      BME280: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "BME280", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value, 2);
          }
        }
      },
      SI7020: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "SI7020", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(175.72 * value / 65536 - 46.85, 1);
          }
        }
      },
      MCP9808: {
        ADDRESSES: {
          value: [24]
        },
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            const address = Drivers2.addressResolver(this, options);
            this.io.i2cConfig(options);
            this.io.i2cRead(address, 5, 2, (data) => {
              let value = ((data[0] << 8 | data[1]) & 4095) / 16;
              if (value & 4096) {
                value -= 256;
              }
              callback(value);
            });
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value, 2);
          }
        }
      },
      LSM303C: {
        initialize: {
          value(options, callback) {
            const { Drivers: Drivers2 } = require_sip();
            Drivers2.get(this.board, "LSM303C", options).on("data", ({ temperature }) => callback(temperature));
          }
        },
        toCelsius: {
          value(value) {
            return toFixed(value / 8 + 25, 1);
          }
        }
      }
    };
    Controllers.BMP085 = Controllers.BMP180;
    Controllers.GY521 = Controllers.MPU6050;
    Controllers.SI7021 = Controllers.SI7020;
    Controllers.DHT11_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT21_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT22_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DEFAULT = Controllers.ANALOG;
    var priv = new Map();
    var Thermometer = class extends Withinable {
      constructor(options) {
        super();
        let last = null;
        let raw = null;
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {
          enabled: typeof options.enabled === "undefined" ? true : options.enabled,
          intervalId: null,
          freq: options.freq || 25,
          previousFreq: options.freq || 25
        };
        priv.set(this, state);
        this.aref = options.aref || this.io.aref || 5;
        if (!this.toCelsius) {
          this.toCelsius = options.toCelsius || ((x) => x);
        }
        const eventProcessing = () => {
          if (raw == null) {
            return;
          }
          const data = {};
          data.C = data.celsius = this.celsius;
          data.F = data.fahrenheit = this.fahrenheit;
          data.K = data.kelvin = this.kelvin;
          this.emit("data", data);
          if (this.celsius !== last) {
            last = this.celsius;
            this.emit("change", data);
          }
        };
        const descriptors = {
          celsius: {
            get() {
              return this.toCelsius(raw);
            }
          },
          fahrenheit: {
            get() {
              return toFixed(this.celsius * 9 / 5 + 32, 2);
            }
          },
          kelvin: {
            get() {
              return toFixed(this.celsius + CELSIUS_TO_KELVIN, 2);
            }
          },
          freq: {
            get() {
              return state.freq;
            },
            set(newFreq) {
              state.freq = newFreq;
              if (state.intervalId) {
                clearInterval(state.intervalId);
              }
              if (state.freq !== null) {
                state.intervalId = setInterval(eventProcessing, newFreq);
              }
            }
          }
        };
        descriptors.C = descriptors.celsius;
        descriptors.F = descriptors.fahrenheit;
        descriptors.K = descriptors.kelvin;
        Object.defineProperties(this, descriptors);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => raw = data);
        }
        if (state.enabled) {
          this.freq = state.freq;
        }
      }
      enable() {
        const state = priv.get(this);
        if (!state.enabled) {
          this.freq = state.freq || state.previousFreq;
        }
        return this;
      }
      disable() {
        const state = priv.get(this);
        if (state.enabled) {
          state.enabled = false;
          state.previousFreq = state.freq;
          this.freq = null;
        }
        return this;
      }
    };
    Thermometer.Drivers = Drivers;
    if (!!process.env.IS_TEST_MODE) {
      Thermometer.Controllers = Controllers;
      Thermometer.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Thermometer;
  }
});

// node_modules/johnny-five/lib/sip.js
var require_sip = __commonJS({
  "node_modules/johnny-five/lib/sip.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var priv = new Map();
    var activeDrivers = new Map();
    var {
      int16,
      uint16,
      uint24,
      s32,
      u32
    } = Fn;
    var ACCELEROMETER = "accelerometer";
    var ALTIMETER = "altimeter";
    var BAROMETER = "barometer";
    var GYRO = "gyro";
    var HYGROMETER = "hygrometer";
    var MAGNETOMETER = "magnetometer";
    var ORIENTATION = "orientation";
    var THERMOMETER = "thermometer";
    function Components(controller, options) {
      const state = priv.get(this);
      const descriptors = Object.create(null);
      for (const component of this.components) {
        state[component] = new Components[component](Object.assign({
          controller: options.controller || controller,
          freq: options.freq,
          board: this.board
        }, options));
        descriptors[component] = {
          get() {
            return state[component];
          }
        };
        if (backwardCompatibilityGarbageHacks[component]) {
          descriptors[backwardCompatibilityGarbageHacks[component]] = descriptors[component];
        }
      }
      Object.defineProperties(this, descriptors);
    }
    Components.accelerometer = require_accelerometer();
    Components.altimeter = require_altimeter();
    Components.barometer = require_barometer();
    Components.gyro = require_gyro();
    Components.hygrometer = require_hygrometer();
    Components.magnetometer = require_compass();
    Components.orientation = require_orientation();
    Components.thermometer = require_thermometer();
    Components.sunlight = require_blokdots_sunlight();
    var backwardCompatibilityGarbageHacks = {
      thermometer: "temperature"
    };
    var Drivers = {
      SI1145: {
        ADDRESSES: {
          value: [96]
        },
        REGISTER: {
          value: {
            ALS_VIS: 34,
            ALS_IR: 36,
            AUX_UV: 44,
            INT_CFG: 3,
            IRQ_ENABLE: 4,
            IRQMODE1: 5,
            IRQMODE2: 6,
            HW_KEY: 7,
            MEAS_RATE0: 8,
            MEAS_RATE1: 9,
            PSALS_AUTO: 15,
            UCOEF0: 19,
            UCOEF1: 20,
            UCOEF2: 21,
            UCOEF3: 22,
            COMMAND: 24,
            RESPONSE: 32,
            IRQ_STATUS: 33,
            PARAM_WR: 23,
            PARAM_RD: 46,
            PARAM_SET: 160,
            PSLED21: 15
          }
        },
        COMMANDS: {
          value: {
            RESET: 1
          }
        },
        PARAMS: {
          value: {
            CHLIST: 1,
            CHLIST_ENUV: 128,
            CHLIST_ENALSIR: 32,
            CHLIST_ENALSVIS: 16,
            CHLIST_ENPS1: 1,
            PS1ADCMUX: 7,
            ADCMUX_LARGEIR: 3,
            PSLED12SEL: 2,
            PSLED12SEL_PS1LED1: 16,
            PSADCGAIN: 11,
            PSADCOUNTER: 10,
            PSADCMISC: 12,
            PSADCMISC_RANGE: 32,
            PSADCMISC_PSMODE: 4,
            ALSIRADCMUX: 14,
            ADCMUX_SMALLIR: 0,
            ALSIRADCGAIN: 30,
            ALSIRADCOUNTER: 29,
            ALSIRADCMISC: 31,
            ALSIRADCMISC_RANGE: 32,
            ALSVISADCGAIN: 17,
            ALSVISADCOUNTER: 16,
            ADCCOUNTER_511CLK: 112,
            ALSVISADCMISC: 18,
            ALSVISADCMISC_VISRANGE: 32
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            const computed = {
              ir: null,
              uv: null,
              vis: null
            };
            io2.i2cConfig(options);
            const reset = () => {
              io2.i2cWriteReg(address, this.REGISTER.MEASRATE0, 0);
              io2.i2cWriteReg(address, this.REGISTER.MEASRATE1, 0);
              io2.i2cWriteReg(address, this.REGISTER.IRQ_ENABLE, 0);
              io2.i2cWriteReg(address, this.REGISTER.IRQMODE1, 0);
              io2.i2cWriteReg(address, this.REGISTER.IRQMODE2, 0);
              io2.i2cWriteReg(address, this.REGISTER.INT_CFG, 0);
              io2.i2cWriteReg(address, this.REGISTER.IRQ_STATUS, 255);
              io2.i2cWriteReg(address, this.REGISTER.COMMAND, this.COMMANDS.RESET);
              setTimeout(() => {
                io2.i2cWriteReg(address, this.REGISTER.HW_KEY, 23);
              }, 50);
            };
            reset();
            const writeParam = (p, v) => {
              io2.i2cWriteReg(address, this.REGISTER.PARAM_WR, v);
              io2.i2cWriteReg(address, this.REGISTER.COMMAND, p | this.REGISTER.PARAM_SET);
            };
            setTimeout(() => {
              io2.i2cWriteReg(address, this.REGISTER.UCOEF0, 41);
              io2.i2cWriteReg(address, this.REGISTER.UCOEF1, 137);
              io2.i2cWriteReg(address, this.REGISTER.UCOEF2, 2);
              io2.i2cWriteReg(address, this.REGISTER.UCOEF3, 0);
              writeParam(this.PARAMS.CHLIST, this.PARAMS.CHLIST_ENUV | this.PARAMS.CHLIST_ENALSIR | this.PARAMS.CHLIST_ENALSVIS | this.PARAMS.CHLIST_ENPS1);
              io2.i2cWriteReg(address, this.REGISTER.INTCFG, this.REGISTER.INTCFG_INTOE);
              io2.i2cWriteReg(address, this.REGISTER.IRQEN, this.REGISTER.IRQEN_ALSEVERYSAMPLE);
              io2.i2cWriteReg(address, this.REGISTER.PSLED21, 3);
              writeParam(this.PARAMS.PS1ADCMUX, this.PARAMS.ADCMUX_LARGEIR);
              writeParam(this.PARAMS.PSLED12SEL, this.PARAMS.PSLED12SEL_PS1LED1);
              writeParam(this.PARAMS.PSADCGAIN, 0);
              writeParam(this.PARAMS.PSADCOUNTER, this.PARAMS.ADCCOUNTER_511CLK);
              writeParam(this.PARAMS.PSADCMISC, this.PARAMS.PSADCMISC_RANGE | this.PARAMS.PSADCMISC_PSMODE);
              writeParam(this.PARAMS.ALSIRADCMUX, this.PARAMS.ADCMUX_SMALLIR);
              writeParam(this.PARAMS.ALSIRADCGAIN, 0);
              writeParam(this.PARAMS.ALSIRADCOUNTER, this.PARAMS.ADCCOUNTER_511CLK);
              writeParam(this.PARAMS.ALSIRADCMISC, this.PARAMS.ALSIRADCMISC_RANGE);
              writeParam(this.PARAMS.ALSVISADCGAIN, 0);
              writeParam(this.PARAMS.ALSVISADCOUNTER, this.PARAMS.ADCCOUNTER_511CLK);
              writeParam(this.PARAMS.ALSVISADCMISC, this.PARAMS.ALSVISADCMISC_VISRANGE);
              io2.i2cWriteReg(address, this.REGISTER.MEAS_RATE0, 255);
              io2.i2cWriteReg(address, this.REGISTER.COMMAND, this.REGISTER.PSALS_AUTO);
              readCycle();
            }, 500);
            const handler = (data, type) => {
              const compVal = uint16(data[1], data[0]);
              switch (type) {
                case "uv":
                  computed.uv = compVal;
                  break;
                case "ir":
                  computed.ir = compVal;
                  break;
                case "vis":
                  computed.vis = compVal;
                  break;
              }
            };
            const readCycle = () => {
              io2.i2cReadOnce(address, this.REGISTER.AUX_UV, 2, (arr) => handler(arr, "uv"));
              io2.i2cReadOnce(address, this.REGISTER.ALS_IR, 2, (arr) => handler(arr, "ir"));
              io2.i2cReadOnce(address, this.REGISTER.ALS_VIS, 2, (arr) => handler(arr, "vis"));
              this.emit("data", computed);
              setTimeout(readCycle, 500);
            };
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.SI1145, options);
            return `SI1145-${address}`;
          }
        }
      },
      SHT31D: {
        ADDRESSES: {
          value: [68]
        },
        REGISTER: {
          value: {
            SOFT_RESET: 34,
            MEASURE_HIGH_REPEATABILITY: 9216
          }
        },
        initialize: {
          value(board, options) {
            const READLENGTH = 6;
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            io2.i2cConfig(options);
            io2.i2cWrite(address, [
              this.REGISTER.SOFT_RESET >> 8,
              this.REGISTER.SOFT_RESET & 255
            ]);
            const computed = {
              temperature: null,
              humidity: null
            };
            const readCycle = () => {
              io2.i2cWrite(address, [
                this.REGISTER.MEASURE_HIGH_REPEATABILITY >> 8,
                this.REGISTER.MEASURE_HIGH_REPEATABILITY & 255
              ]);
              setTimeout(() => {
                io2.i2cReadOnce(address, READLENGTH, (data) => {
                  computed.temperature = uint16(data[0], data[1]);
                  computed.humidity = uint16(data[3], data[4]);
                  this.emit("data", computed);
                  readCycle();
                });
              }, 16);
            };
            readCycle();
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.SHT31D, options);
            return `sht-31d-${address}`;
          }
        }
      },
      HTU21D: {
        ADDRESSES: {
          value: [64]
        },
        REGISTER: {
          value: {
            HUMIDITY: 229,
            TEMPERATURE: 227,
            SOFT_RESET: 254
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            options.delay = 5e4;
            io2.i2cConfig(options);
            io2.i2cWrite(address, this.REGISTER.SOFT_RESET);
            const computed = {
              temperature: null,
              humidity: null
            };
            let cycle = 0;
            const readCycle = () => {
              const isTemperatureCycle = cycle === 0;
              const register = isTemperatureCycle ? this.REGISTER.TEMPERATURE : this.REGISTER.HUMIDITY;
              io2.i2cReadOnce(address, register, 2, (data) => {
                if (isTemperatureCycle) {
                  computed.temperature = uint16(data[0], data[1]);
                } else {
                  computed.humidity = uint16(data[0], data[1]);
                }
                if (++cycle === 2) {
                  cycle = 0;
                  this.emit("data", computed);
                }
                readCycle();
              });
            };
            readCycle();
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.HTU21D, options);
            return `htu-s1d-${address}`;
          }
        }
      },
      HIH6130: {
        ADDRESSES: {
          value: [39]
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            io2.i2cConfig(options);
            const computed = {
              humidity: null,
              temperature: null
            };
            let delay = 36.65;
            const measureCycle = () => {
              io2.i2cWrite(address, 160, [0, 0]);
              setTimeout(() => {
                io2.i2cWrite(address, 128, [0, 0]);
                io2.i2cReadOnce(address, 4, (data) => {
                  const status = data[0] >> 6;
                  computed.humidity = int16(data[0] & 63, data[1]);
                  computed.temperature = int16(data[2], data[3] >> 2);
                  if (status === 0) {
                    delay--;
                  }
                  if (status === 1) {
                    delay++;
                  }
                  this.emit("data", computed);
                  measureCycle();
                });
              }, delay);
            };
            measureCycle();
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.HIH6130, options);
            return `hih6130-${address}`;
          }
        }
      },
      DHT_I2C_NANO_BACKPACK: {
        ADDRESSES: {
          value: [10]
        },
        REGISTER: {
          value: {
            READ: 0
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const dhtPin = 2;
            let dhtType = 11;
            const address = Drivers.addressResolver(this, options);
            io2.i2cConfig(options);
            const dhtVariantExec = /(\d{2})/.exec(options.controller);
            const dhtVariant = dhtVariantExec && dhtVariantExec.length && dhtVariantExec[0];
            if (dhtVariant) {
              dhtType = +dhtVariant;
              if (Number.isNaN(dhtType)) {
                dhtType = 11;
              }
            }
            const computed = {
              temperature: null,
              humidity: null
            };
            io2.i2cWrite(address, [dhtPin, dhtType]);
            io2.i2cRead(address, 4, (data) => {
              computed.humidity = int16(data[0], data[1]);
              computed.temperature = int16(data[2], data[3]);
              this.emit("data", computed);
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.DHT_I2C_NANO_BACKPACK, options);
            return `dht_i2c_nano_backpack-${address}`;
          }
        }
      },
      MPU6050: {
        ADDRESSES: {
          value: [104, 105]
        },
        REGISTER: {
          value: {
            SETUP: [107, 0],
            READ: 59
          }
        },
        initialize: {
          value(board, options) {
            const READLENGTH = 14;
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            const computed = {
              accelerometer: {},
              temperature: {},
              gyro: {}
            };
            io2.i2cConfig(options);
            io2.i2cWrite(address, this.REGISTER.SETUP);
            io2.i2cRead(address, this.REGISTER.READ, READLENGTH, (data) => {
              computed.accelerometer = {
                x: int16(data[0], data[1]),
                y: int16(data[2], data[3]),
                z: int16(data[4], data[5])
              };
              computed.temperature = int16(data[6], data[7]);
              computed.gyro = {
                x: int16(data[8], data[9]),
                y: int16(data[10], data[11]),
                z: int16(data[12], data[13])
              };
              this.emit("data", computed);
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.MPU6050, options);
            return `mpu-6050-${address}`;
          }
        }
      },
      BNO055: {
        ADDRESSES: {
          value: [40, 41]
        },
        REGISTER: {
          value: {
            READ: {
              ACCEL: 8,
              MAG: 14,
              GYRO: 20,
              EULER: 26,
              QUARTERNION: 32,
              TEMP: 52
            },
            LENGTH: {
              ACCEL: 6,
              MAG: 6,
              GYRO: 6,
              EULER: 6,
              QUARTERNION: 8,
              TEMP: 1
            },
            OPR_MODE_ADDR: 61,
            OPR_MODES: {
              CONFIG: 0,
              ACCONLY: 1,
              MAGONLY: 2,
              GYRONLY: 3,
              ACCMAG: 4,
              ACCGYRO: 5,
              MAGGYRO: 6,
              AMG: 7,
              IMUPLUS: 8,
              COMPASS: 9,
              M4G: 10,
              NDOF_FMC_OFF: 11,
              NDOF: 12
            },
            PWR_MODE_ADDR: 62,
            PWR_MODES: {
              NORMAL: 0,
              LOW: 1,
              SUSPEND: 2
            },
            PAGE_ID_ADDR: 7,
            PAGE_STATES: {
              ZERO: 0
            },
            CALIBRATION: 53,
            SYS_TRIGGER: 63,
            UNIT_SEL_ADDR: 59,
            AXIS_MAP_CONFIG_ADDR: 65,
            AXIS_MAP_SIGN_ADDR: 66
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const calibrationMask = options.calibrationMask || 192;
            const address = Drivers.addressResolver(this, options);
            const computed = {
              accelerometer: {
                x: null,
                y: null,
                z: null
              },
              gyro: {
                x: null,
                y: null,
                z: null
              },
              magnetometer: {
                x: null,
                y: null,
                z: null
              },
              orientation: {
                euler: {
                  heading: null,
                  roll: null,
                  pitch: null
                },
                quarternion: {
                  w: null,
                  x: null,
                  y: null,
                  z: null
                }
              },
              temperature: null,
              calibration: null
            };
            io2.i2cConfig(options);
            io2.i2cWriteReg(address, this.REGISTER.OPR_MODE_ADDR, this.REGISTER.OPR_MODES.CONFIG);
            io2.i2cWriteReg(address, this.REGISTER.PAGE_ID_ADDR, this.REGISTER.PAGE_STATES.ZERO);
            io2.i2cWriteReg(address, this.REGISTER.SYS_TRIGGER, 32);
            const por = new Promise((resolve) => {
              setTimeout(() => {
                io2.i2cWriteReg(address, this.REGISTER.PWR_MODE_ADDR, this.REGISTER.PWR_MODES.NORMAL);
                io2.i2cWriteReg(address, this.REGISTER.SYS_TRIGGER, options.enableExternalCrystal ? 128 : 0);
                const axisMap = options.axisMap || 36;
                io2.i2cWriteReg(address, this.REGISTER.AXIS_MAP_CONFIG_ADDR, axisMap);
                const axisSign = options.axisSign || 0;
                io2.i2cWriteReg(address, this.REGISTER.AXIS_MAP_SIGN_ADDR, axisSign);
                setTimeout(() => {
                  io2.i2cWriteReg(address, this.REGISTER.OPR_MODE_ADDR, this.REGISTER.OPR_MODES.NDOF);
                  resolve();
                }, 10);
              }, 650);
            });
            por.then(() => new Promise((resolve) => {
              const readCalibration = () => {
                io2.i2cReadOnce(address, this.REGISTER.CALIBRATION, 1, (data) => {
                  const calibration = data[0];
                  const didCalibrationChange = computed.calibration !== calibration;
                  computed.calibration = calibration;
                  if (didCalibrationChange) {
                    this.emit("calibration", computed.calibration);
                  }
                  if ((calibration & calibrationMask) === calibrationMask) {
                    this.emit("calibrated");
                    resolve();
                  } else {
                    readCalibration();
                  }
                });
              };
              readCalibration();
            })).then(() => {
              io2.i2cRead(address, this.REGISTER.READ.TEMP, 2, (data) => {
                computed.temperature = data[0];
                const didCalibrationChange = computed.calibration !== data[1];
                computed.calibration = data[1];
                this.emit("data", computed);
                if (didCalibrationChange) {
                  this.emit("calibration", computed.calibration);
                }
              });
              io2.i2cRead(address, this.REGISTER.READ.ACCEL, 18, (data) => {
                computed.accelerometer = {
                  x: int16(data[1], data[0]),
                  y: int16(data[3], data[2]),
                  z: int16(data[5], data[4])
                };
                computed.magnetometer = {
                  x: int16(data[7], data[6]),
                  y: int16(data[9], data[8]),
                  z: int16(data[11], data[10])
                };
                computed.gyro = {
                  x: int16(data[13], data[12]),
                  y: int16(data[15], data[14]),
                  z: int16(data[17], data[16])
                };
                this.emit("data", computed);
              });
              io2.i2cRead(address, this.REGISTER.READ.EULER, 14, (data) => {
                computed.orientation.euler = {
                  heading: int16(data[1], data[0]),
                  roll: int16(data[3], data[2]),
                  pitch: int16(data[5], data[4])
                };
                computed.orientation.quarternion = {
                  w: int16(data[7], data[6]),
                  x: int16(data[9], data[8]),
                  y: int16(data[11], data[10]),
                  z: int16(data[13], data[12])
                };
                this.emit("data", computed);
              });
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.BNO055, options);
            return `bno055-${address}`;
          }
        }
      },
      MPL115A2: {
        ADDRESSES: {
          value: [96]
        },
        REGISTER: {
          value: {
            COEFFICIENTS: 4,
            PADC_MSB: 0,
            CONVERT: 18
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            io2.i2cConfig(options);
            const computed = {
              pressure: null,
              temperature: null
            };
            const cof = {
              a0: null,
              b1: null,
              b2: null,
              c12: null
            };
            const handler = (data) => {
              const Padc = uint16(data[0], data[1]) >> 6;
              const Tadc = uint16(data[2], data[3]) >> 6;
              computed.pressure = cof.a0 + (cof.b1 + cof.c12 * Tadc) * Padc + cof.b2 * Tadc;
              computed.temperature = Tadc;
              this.emit("data", computed);
              readCycle();
            };
            var readCycle = () => {
              io2.i2cWriteReg(address, this.REGISTER.CONVERT, 0);
              io2.i2cReadOnce(address, this.REGISTER.PADC_MSB, 4, handler);
            };
            const pCoefficients = new Promise((resolve) => {
              io2.i2cReadOnce(address, this.REGISTER.COEFFICIENTS, 8, (data) => {
                const A0 = int16(data[0], data[1]);
                const B1 = int16(data[2], data[3]);
                const B2 = int16(data[4], data[5]);
                const C12 = int16(data[6], data[7]) >> 2;
                cof.a0 = A0 / 8;
                cof.b1 = B1 / 8192;
                cof.b2 = B2 / 16384;
                cof.c12 = C12 / 4194304;
                resolve();
              });
            });
            pCoefficients.then(readCycle);
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.MPL115A2, options);
            return `mpl115a2-${address}`;
          }
        }
      },
      MPL3115A2: {
        ADDRESSES: {
          value: [96]
        },
        REGISTER: {
          value: {
            STATUS: 0,
            PRESSURE: 1,
            CONFIG: 19,
            BAR_IN_MSB: 20,
            BAR_IN_LSB: 21,
            CONTROL: 38
          }
        },
        MASK: {
          value: {
            STATUS: {
              PRESSURE_DATA_READ: 4
            },
            CONTROL: {
              SBYB: 1,
              OS128: 56,
              ALTIMETER: 128,
              PRESSURE: 0
            },
            CONFIG: {
              TDEFE: 1,
              PDEFE: 2,
              DREM: 4
            }
          }
        },
        initialize: {
          value(board, options) {
            const READLENGTH = 6;
            const io2 = board.io;
            let isPressure = false;
            let elevation = null;
            let offset = 0;
            const address = Drivers.addressResolver(this, options);
            let altNow = 0;
            const computed = {
              pressure: 0,
              altitude: 0,
              temperature: 0
            };
            if (typeof options.elevation !== "undefined") {
              elevation = options.elevation;
            }
            if (elevation !== null && elevation <= 0) {
              offset = Math.abs(elevation) + 1;
              elevation = 1;
            }
            const waitForReady = (next) => {
              io2.i2cReadOnce(address, this.REGISTER.STATUS, 1, (data) => {
                if (data[0] & this.MASK.STATUS.PRESSURE_DATA_READ) {
                  next();
                } else {
                  setTimeout(() => {
                    waitForReady(next);
                  }, 100);
                }
              });
            };
            const readValues = () => {
              const modeMask = isPressure ? this.MASK.CONTROL.PRESSURE : this.MASK.CONTROL.ALTIMETER;
              const mode = this.MASK.CONTROL.SBYB | this.MASK.CONTROL.OS128 | modeMask;
              io2.i2cWrite(address, this.REGISTER.CONTROL, mode);
              waitForReady(() => {
                io2.i2cReadOnce(address, this.REGISTER.PRESSURE, READLENGTH, (data) => {
                  const value = uint24(data[1], data[2], data[3]) >> 4;
                  const temperature = uint16(data[4], data[5]) >> 4;
                  let altVal;
                  computed.temperature = temperature;
                  if (isPressure) {
                    computed.pressure = value;
                    this.emit("data", computed);
                  } else {
                    const m = data[1];
                    const c = data[2];
                    const l = data[3];
                    const fl = (l >> 4) / 16;
                    altVal = (m << 8 | c) + fl;
                    altNow = (altNow * 3 + altVal) / 4;
                    computed.altitude = altNow - offset;
                  }
                  isPressure = !isPressure;
                  readValues();
                });
              });
            };
            const reads = [];
            const calibrate = () => {
              io2.i2cWrite(address, this.REGISTER.CONTROL, 59);
              io2.i2cWrite(address, this.REGISTER.CONTROL, 57);
              setTimeout(() => {
                io2.i2cReadOnce(address, this.REGISTER.PRESSURE, READLENGTH, (data) => {
                  const m = data[1];
                  const c = data[2];
                  const l = data[3];
                  const fl = (l >> 4) / 4;
                  reads.push((m << 10 | c << 2) + fl);
                  if (reads.length === 4) {
                    const curpress = (reads[0] + reads[1] + reads[2] + reads[3]) / 4;
                    const seapress = curpress / (1 - elevation * 225577e-10) ** 5.255;
                    io2.i2cWrite(address, this.REGISTER.BAR_IN_MSB, seapress / 2 >> 8);
                    io2.i2cWrite(address, this.REGISTER.BAR_IN_LSB, seapress / 2 & 255);
                    io2.i2cWrite(address, this.REGISTER.CONTROL, 187);
                    io2.i2cWrite(address, this.REGISTER.CONTROL, 185);
                    setTimeout(() => {
                      io2.i2cReadOnce(address, this.REGISTER.PRESSURE, READLENGTH, (data2) => {
                        const m2 = data2[1];
                        const c2 = data2[2];
                        const l2 = data2[3];
                        const fl2 = (l2 >> 4) / 16;
                        altNow = (m2 << 8 | c2) + fl2;
                        readValues(false);
                      });
                    }, 550);
                  } else {
                    calibrate();
                  }
                });
              }, 500);
            };
            io2.i2cConfig(Object.assign(options, {
              settings: {
                stopTX: true
              }
            }));
            io2.i2cWriteReg(address, 45, 0);
            io2.i2cWriteReg(address, this.REGISTER.BAR_IN_MSB, 0);
            io2.i2cWriteReg(address, this.REGISTER.BAR_IN_LSB, 0);
            io2.i2cWriteReg(address, this.REGISTER.CONFIG, this.MASK.CONFIG.TDEFE | this.MASK.CONFIG.PDEFE | this.MASK.CONFIG.DREM);
            if (elevation !== null) {
              calibrate();
            } else {
              readValues();
            }
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.MPL3115A2, options);
            return `mpl3115a2-${address}`;
          }
        }
      },
      BMP180: {
        ADDRESSES: {
          value: [119]
        },
        REGISTER: {
          value: {
            COEFFICIENTS: 170,
            READ: 0,
            READ_START: 244,
            READ_RESULT: 246
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            let elevation = null;
            let offset = 0;
            if (typeof options.elevation !== "undefined") {
              elevation = options.elevation;
            }
            if (elevation != null && elevation <= 0 || elevation == null) {
              offset = Math.abs(elevation) + 1;
              elevation = 1;
            }
            const address = Drivers.addressResolver(this, options);
            const mode = options.mode || 3;
            const kpDelay = [5, 8, 14, 26][mode];
            const oss = Fn.constrain(mode, 0, 3);
            const cof = {
              a1: null,
              a2: null,
              a3: null,
              a4: null,
              a5: null,
              a6: null,
              b1: null,
              b2: null,
              b5: null,
              mb: null,
              mc: null,
              md: null
            };
            io2.i2cConfig(options);
            const pCoefficients = new Promise((resolve) => {
              io2.i2cReadOnce(address, this.REGISTER.COEFFICIENTS, 22, (data) => {
                cof.a1 = int16(data[0], data[1]);
                cof.a2 = int16(data[2], data[3]);
                cof.a3 = int16(data[4], data[5]);
                cof.a4 = uint16(data[6], data[7]);
                cof.a5 = uint16(data[8], data[9]);
                cof.a6 = uint16(data[10], data[11]);
                cof.b1 = int16(data[12], data[13]);
                cof.b2 = int16(data[14], data[15]);
                cof.mb = int16(data[16], data[17]);
                cof.mc = int16(data[18], data[19]);
                cof.md = int16(data[20], data[21]);
                resolve();
              });
            });
            pCoefficients.then(() => {
              const computed = {
                altitude: null,
                pressure: null,
                temperature: null
              };
              let cycle = 0;
              const readCycle = () => {
                const isTemperatureCycle = cycle === 0;
                const component = isTemperatureCycle ? 46 : 52 + (oss << 6);
                const numBytes = isTemperatureCycle ? 2 : 3;
                const delay = isTemperatureCycle ? 5 : kpDelay;
                io2.i2cWriteReg(address, this.REGISTER.READ_START, component);
                setTimeout(() => {
                  io2.i2cReadOnce(address, this.REGISTER.READ_RESULT, numBytes, (data) => {
                    let compensated;
                    let uncompensated;
                    let x1;
                    let x2;
                    let x3;
                    let b3;
                    let b4;
                    let b6;
                    let b7;
                    let b6s;
                    let bx;
                    if (isTemperatureCycle) {
                      uncompensated = int16(data[0], data[1]);
                      x1 = (uncompensated - cof.a6) * cof.a5 >> 15;
                      x2 = (cof.mc << 11) / (x1 + cof.md) >> 0;
                      cof.b5 = x1 + x2 | 0;
                      computed.temperature = (cof.b5 + 8 >> 4) / 10;
                    } else {
                      uncompensated = uint24(data[0], data[1], data[2]) >> 8 - oss;
                      b6 = cof.b5 - 4e3;
                      b6s = b6 * b6;
                      bx = b6s >> 12;
                      x1 = cof.b2 * bx >> 11;
                      x2 = cof.a2 * b6 >> 11;
                      x3 = x1 + x2;
                      b3 = ((cof.a1 * 4 + x3 << oss) + 2) / 4 >> 0;
                      x1 = cof.a3 * b6 >> 13;
                      x2 = cof.b1 * bx >> 16;
                      x3 = x1 + x2 + 2 >> 2;
                      b4 = cof.a4 * (x3 + 32768) >> 15;
                      b7 = (uncompensated - b3) * (5e4 >> oss);
                      if (b7 < Fn.POW_2_31) {
                        compensated = b7 * 2 / b4;
                      } else {
                        compensated = b7 / b4 * 2;
                      }
                      compensated >>= 0;
                      x1 = (compensated >> 8) * (compensated >> 8);
                      x1 = x1 * 3038 >> 16;
                      x2 = -7357 * compensated >> 16;
                      compensated += x1 + x2 + 3791 >> 4;
                      computed.pressure = compensated;
                      const seapress = compensated / (1 - elevation * 225577e-10) ** 5.255;
                      const altitude = 44330 * (1 - compensated / seapress ** (1 / 5.255));
                      computed.altitude = Math.round(altitude - offset);
                    }
                    if (++cycle === 2) {
                      cycle = 0;
                      this.emit("data", computed);
                    }
                    readCycle();
                  });
                }, delay);
              };
              readCycle();
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.BMP180, options);
            return `bmp180-${address}`;
          }
        }
      },
      BMP280: {
        ADDRESSES: {
          value: [119]
        },
        REGISTER: {
          value: {
            COEFFICIENTS: 136,
            CONFIG: 245,
            MEASURE: 244,
            PRESSURE: 247,
            TEMPERATURE: 250,
            RESET: 224
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            let elevation = null;
            let offset = 0;
            if (typeof options.elevation !== "undefined") {
              elevation = options.elevation;
            }
            if (elevation != null && elevation <= 0 || elevation == null) {
              offset = Math.abs(elevation) + 1;
              elevation = 1;
            }
            const address = Drivers.addressResolver(this, options);
            const dig = {
              T1: null,
              T2: null,
              T3: null,
              P1: null,
              P2: null,
              P3: null,
              P4: null,
              P5: null,
              P6: null,
              P7: null,
              P8: null,
              P9: null
            };
            io2.i2cConfig(options);
            io2.i2cWrite(address, this.REGISTER.RESET, 182);
            const pCoefficients = new Promise((resolve) => {
              io2.i2cReadOnce(address, this.REGISTER.COEFFICIENTS, 24, (data) => {
                dig.T1 = uint16(data[1], data[0]);
                dig.T2 = int16(data[3], data[2]);
                dig.T3 = int16(data[5], data[4]);
                dig.P1 = uint16(data[7], data[6]);
                dig.P2 = int16(data[9], data[8]);
                dig.P3 = int16(data[11], data[10]);
                dig.P4 = int16(data[13], data[12]);
                dig.P5 = int16(data[15], data[14]);
                dig.P6 = int16(data[17], data[16]);
                dig.P7 = int16(data[19], data[18]);
                dig.P8 = int16(data[21], data[20]);
                dig.P9 = int16(data[23], data[22]);
                resolve();
              });
            });
            pCoefficients.then(() => {
              io2.i2cWrite(address, this.REGISTER.MEASURE, 63);
              const computed = {
                altitude: null,
                pressure: null,
                temperature: null
              };
              io2.i2cRead(address, this.REGISTER.PRESSURE, 6, (data) => {
                let compensated = 0;
                let fine;
                let v1;
                let v2;
                let P = s32(uint24(data[0], data[1], data[2]));
                let T = s32(uint24(data[3], data[4], data[5]));
                P >>= 4;
                T >>= 4;
                const adc16 = T >> 4;
                const adc16subT1 = adc16 - dig.T1;
                v1 = ((T >> 3) - (dig.T1 << 1)) * dig.T2 >> 11;
                v2 = (adc16subT1 * adc16subT1 >> 12) * dig.T3 >> 14;
                fine = v1 + v2;
                computed.temperature = (fine * 5 + 128 >> 8) / 100;
                v1 = void 0;
                v2 = void 0;
                v1 = s32(fine >> 1) - 64e3;
                v2 = ((v1 >> 2) * (v1 >> 2) >> 11) * s32(dig.P6);
                v2 += v1 * s32(dig.P5) << 1;
                v2 = (v2 >> 2) + (s32(dig.P4) << 16);
                v1 = (dig.P3 * ((v1 >> 2) * (v1 >> 2) >> 13) >> 3) + (s32(dig.P2) * v1 >> 1) >> 18;
                v1 = (Fn.POW_2_15 + v1) * s32(dig.P1) >> 15;
                if (v1 === 0) {
                  return 0;
                }
                compensated = u32(s32(Fn.POW_2_20) - P - (v2 >> 12)) * 3125;
                if (compensated < Fn.POW_2_31) {
                  compensated = (compensated << 1 >>> 0) / u32(v1);
                } else {
                  compensated = (compensated / u32(v1) >>> 0) * 2;
                }
                compensated = u32(compensated) >>> 0;
                const compshift3r = compensated >> 3;
                v1 = s32(dig.P9) * s32(compshift3r * compshift3r >> 13) >> 12;
                v2 = s32(compensated >> 2) * s32(dig.P8) >> 13;
                compensated = u32(s32(compensated) + (v1 + v2 + dig.P7 >> 4));
                computed.pressure = compensated;
                const seapress = compensated / (1 - elevation * 225577e-10) ** 5.255;
                const altitude = 44330 * (1 - compensated / seapress ** (1 / 5.255));
                computed.altitude = Math.round(altitude - offset);
                this.emit("data", computed);
              });
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.BMP280, options);
            return `bmp280-${address}`;
          }
        }
      },
      BME280: {
        ADDRESSES: {
          value: [119]
        },
        REGISTER: {
          value: {
            COEFFICIENTS_TP: 136,
            COEFFICIENTS_H: 225,
            CONFIG: 245,
            MEASURE_H: 242,
            MEASURE_TP: 244,
            PRESSURE: 247,
            TEMPERATURE: 250,
            HUMIDITY: 253,
            RESET: 224
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            let elevation = null;
            let offset = 0;
            if (typeof options.elevation !== "undefined") {
              elevation = options.elevation;
            }
            if (elevation != null && elevation <= 0 || elevation == null) {
              offset = Math.abs(elevation) + 1;
              elevation = 1;
            }
            const address = Drivers.addressResolver(this, options);
            const dig = {
              T1: null,
              T2: null,
              T3: null,
              P1: null,
              P2: null,
              P3: null,
              P4: null,
              P5: null,
              P6: null,
              P7: null,
              P8: null,
              P9: null,
              H1: null,
              H2: null,
              H3: null,
              H4: null,
              H5: null,
              H6: null
            };
            io2.i2cConfig(options);
            io2.i2cWrite(address, this.REGISTER.RESET, 182);
            const pCoefficients = new Promise((resolveCoeffs) => {
              Promise.all([
                new Promise((resolve) => {
                  io2.i2cReadOnce(address, 136, 24, (data) => {
                    dig.T1 = uint16(data[1], data[0]);
                    dig.T2 = int16(data[3], data[2]);
                    dig.T3 = int16(data[5], data[4]);
                    dig.P1 = uint16(data[7], data[6]);
                    dig.P2 = int16(data[9], data[8]);
                    dig.P3 = int16(data[11], data[10]);
                    dig.P4 = int16(data[13], data[12]);
                    dig.P5 = int16(data[15], data[14]);
                    dig.P6 = int16(data[17], data[16]);
                    dig.P7 = int16(data[19], data[18]);
                    dig.P8 = s32(int16(data[21], data[20]));
                    dig.P9 = s32(int16(data[23], data[22]));
                    resolve();
                  });
                }),
                new Promise((resolve) => {
                  io2.i2cReadOnce(address, 161, 1, (data) => {
                    dig.H1 = Fn.u8(data[0]);
                    resolve();
                  });
                }),
                new Promise((resolve) => {
                  io2.i2cReadOnce(address, 225, 8, (data) => {
                    dig.H2 = s32(int16(data[1], data[0]));
                    dig.H3 = s32(data[2]);
                    dig.H4 = s32(data[3] << 4 | data[4] & 15);
                    dig.H5 = s32(data[5] << 4 | data[4] >> 4);
                    dig.H6 = Fn.s8(data[6]);
                    resolve();
                  });
                })
              ]).then(resolveCoeffs);
            });
            pCoefficients.then(() => {
              io2.i2cWrite(address, this.REGISTER.MEASURE_H, 5);
              io2.i2cWrite(address, this.REGISTER.MEASURE_TP, 183);
              const computed = {
                altitude: null,
                pressure: null,
                humidity: null,
                temperature: null
              };
              const standby = Date.now();
              io2.i2cRead(address, this.REGISTER.PRESSURE, 8, (data) => {
                if (!process.env.IS_TEST_MODE) {
                  if (standby + 1e3 > Date.now()) {
                    return;
                  }
                }
                let compensated = 0;
                let fine;
                let v1;
                let v2;
                let vx;
                let P = s32(uint24(data[0], data[1], data[2]));
                let T = s32(uint24(data[3], data[4], data[5]));
                const H = s32(uint16(data[6], data[7]));
                P >>= 4;
                T >>= 4;
                const adc16 = T >> 4;
                const adc16subT1 = adc16 - dig.T1;
                v1 = ((T >> 3) - (dig.T1 << 1)) * dig.T2 >> 11;
                v2 = (adc16subT1 * adc16subT1 >> 12) * dig.T3 >> 14;
                fine = v1 + v2;
                computed.temperature = (fine * 5 + 128 >> 8) / 100;
                v1 = void 0;
                v2 = void 0;
                v1 = s32(fine >> 1) - 64e3;
                v2 = ((v1 >> 2) * (v1 >> 2) >> 11) * s32(dig.P6);
                v2 += v1 * s32(dig.P5) << 1;
                v2 = (v2 >> 2) + (s32(dig.P4) << 16);
                v1 = (dig.P3 * ((v1 >> 2) * (v1 >> 2) >> 13) >> 3) + (s32(dig.P2) * v1 >> 1) >> 18;
                v1 = (Fn.POW_2_15 + v1) * s32(dig.P1) >> 15;
                if (v1 === 0) {
                  return 0;
                }
                compensated = u32(s32(Fn.POW_2_20) - P - (v2 >> 12)) * 3125;
                if (compensated < Fn.POW_2_31) {
                  compensated = (compensated << 1 >>> 0) / u32(v1);
                } else {
                  compensated = (compensated / u32(v1) >>> 0) * 2;
                }
                compensated = u32(compensated) >>> 0;
                const compshift3r = compensated >> 3;
                v1 = s32(dig.P9) * s32(compshift3r * compshift3r >> 13) >> 12;
                v2 = s32(compensated >> 2) * dig.P8 >> 13;
                compensated = u32(s32(compensated) + (v1 + v2 + dig.P7 >> 4));
                computed.pressure = compensated;
                const seapress = compensated / (1 - elevation * 225577e-10) ** 5.255;
                const altitude = 44330 * (1 - compensated / seapress ** (1 / 5.255));
                computed.altitude = Math.round(altitude - offset);
                vx = s32(fine - 76800);
                vx = ((H << 14) - s32(dig.H4 << 20) - dig.H5 * vx + Fn.POW_2_14 >> 15) * ((((vx * dig.H6 >> 10) * ((vx * dig.H3 >> 11) + Fn.POW_2_15) >> 10) + Fn.POW_2_21) * dig.H2 + Fn.POW_2_13 >> 14);
                vx -= ((vx >> 15) * (vx >> 15) >> 7) * s32(dig.H1) >> 4;
                vx = Fn.constrain(vx, 0, 419430400);
                computed.humidity = u32(vx >> 12);
                this.emit("data", computed);
              });
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.BME280, options);
            return `bme280-${address}`;
          }
        }
      },
      SI7020: {
        ADDRESSES: {
          value: [64]
        },
        REGISTER: {
          value: {
            HUMIDITY: 229,
            TEMPERATURE: 224
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            options.delay = 5e4;
            io2.i2cConfig(options);
            const computed = {
              temperature: null,
              humidity: null
            };
            io2.i2cRead(address, this.REGISTER.TEMPERATURE, 2, (data) => {
              computed.temperature = uint16(data[0], data[1]);
              this.emit("data", computed);
            });
            io2.i2cRead(address, this.REGISTER.HUMIDITY, 2, (data) => {
              computed.humidity = uint16(data[0], data[1]);
              this.emit("data", computed);
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.SI7020, options);
            return `si7020-${address}`;
          }
        }
      },
      MS5611: {
        ADDRESSES: {
          value: [119]
        },
        REGISTER: {
          value: {
            COEFFICIENTS: 162,
            READ: 0,
            PRESSURE: 64,
            TEMPERATURE: 80,
            RESET: 30
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            let elevation = null;
            let offset = 0;
            if (typeof options.elevation !== "undefined") {
              elevation = options.elevation;
            }
            if (elevation != null && elevation <= 0 || elevation == null) {
              offset = Math.abs(elevation) + 1;
              elevation = 1;
            }
            const address = Drivers.addressResolver(this, options);
            const computed = {
              altitude: null,
              pressure: null,
              temperature: null
            };
            const mode = options.mode || 5;
            const kpDelay = [1, 2, 3, 4, 5, 10][mode];
            const cof = {
              C1: null,
              C2: null,
              C3: null,
              C4: null,
              C5: null,
              C6: null
            };
            const cKeys = Object.keys(cof);
            options.delay = kpDelay * 1e3;
            io2.i2cConfig(options);
            io2.i2cWrite(address, this.REGISTER.RESET);
            const pCoefficients = new Promise((resolve) => {
              setTimeout(() => {
                const cofs = cKeys.map((key, index) => {
                  const register = this.REGISTER.COEFFICIENTS + index * 2;
                  return new Promise((resolve2) => {
                    io2.i2cReadOnce(address, register, 2, (data) => {
                      cof[key] = uint16(data[0], data[1]);
                      resolve2();
                    });
                  });
                });
                Promise.all(cofs).then(resolve);
              }, 50);
            });
            pCoefficients.then(() => {
              let cycle = 0;
              let D1;
              let D2;
              let dT;
              let TEMP;
              let OFF;
              let SENS;
              let P;
              let TEMP2;
              let OFF2;
              let SENS2;
              const readCycle = () => {
                const isTemperatureCycle = cycle === 0;
                const component = (isTemperatureCycle ? 80 : 64) + mode;
                io2.i2cWrite(address, component);
                if (isTemperatureCycle) {
                  D2 = 0;
                  dT = 0;
                  TEMP = 0;
                  TEMP2 = 0;
                  OFF2 = 0;
                  SENS2 = 0;
                } else {
                  D1 = 0;
                  OFF = 0;
                  SENS = 0;
                  P = 0;
                }
                setTimeout(() => {
                  io2.i2cReadOnce(address, this.REGISTER.READ, 3, (data) => {
                    if (isTemperatureCycle) {
                      D2 = uint24(data[0], data[1], data[2]);
                      dT = D2 - cof.C5 * Fn.POW_2_8;
                      TEMP = 2e3 + dT * cof.C6 / Fn.POW_2_23;
                      if (TEMP < 2e3) {
                        TEMP2 = dT ** 2 / Fn.POW_2_31;
                        OFF2 = 5 * (TEMP - 2e3) ** 2 / 2;
                        SENS2 = 5 * (TEMP - 2e3) ** 2 / Fn.POW_2_2;
                        if (TEMP < -1500) {
                          OFF2 = OFF2 + 7 * (TEMP + 1500) ** 2;
                          SENS2 = SENS2 + 11 * (TEMP + 1500) ** 2 / 2;
                        }
                      }
                      TEMP -= TEMP2;
                      computed.temperature = TEMP / 100;
                    } else {
                      D1 = uint24(data[0], data[1], data[2]);
                      OFF = cof.C2 * Fn.POW_2_16 + cof.C4 * dT / Fn.POW_2_7;
                      SENS = cof.C1 * Fn.POW_2_15 + cof.C3 * dT / Fn.POW_2_8;
                      OFF -= OFF2;
                      SENS -= SENS2;
                      P = (D1 * SENS / Fn.POW_2_21 - OFF) / Fn.POW_2_15;
                      computed.pressure = P;
                      const seapress = P / (1 - elevation * 225577e-10) ** 5.255;
                      const altitude = 44330 * (1 - P / seapress ** (1 / 5.255));
                      computed.altitude = altitude - offset;
                    }
                    if (++cycle === 2) {
                      cycle = 0;
                      this.emit("data", computed);
                    }
                    readCycle();
                  });
                }, kpDelay);
              };
              readCycle();
            });
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.MS5611, options);
            return `ms5611-${address}`;
          }
        }
      },
      TH02: {
        ADDRESSES: {
          value: [64]
        },
        COMMAND: {
          value: {
            MEASURE_HUMIDITY: 1,
            MEASURE_TEMPERATURE: 17
          }
        },
        REGISTER: {
          value: {
            STATUS: 0,
            READ: 1,
            CONFIG: 3
          }
        },
        initialize: {
          value(board, options) {
            const io2 = board.io;
            const address = Drivers.addressResolver(this, options);
            const computed = {
              temperature: null,
              humidity: null
            };
            let cycle = 0;
            io2.i2cConfig(Object.assign(options, {
              settings: {
                stopTX: true
              }
            }));
            const readCycle = () => {
              const isTemperatureCycle = cycle === 0;
              const command = isTemperatureCycle ? this.COMMAND.MEASURE_TEMPERATURE : this.COMMAND.MEASURE_HUMIDITY;
              const conversion = new Promise((resolve) => {
                io2.i2cWrite(address, this.REGISTER.CONFIG, command);
                const requestStatus = () => {
                  io2.i2cReadOnce(address, this.REGISTER.STATUS, 1, (data) => {
                    const status = data[0];
                    if (!(status & 1)) {
                      resolve();
                    } else {
                      requestStatus();
                    }
                  });
                };
                requestStatus();
              });
              conversion.then(() => {
                Promise.all([
                  new Promise((resolve) => {
                    io2.i2cReadOnce(address, 1, 1, (data) => {
                      resolve(data[0]);
                    });
                  }),
                  new Promise((resolve) => {
                    io2.i2cReadOnce(address, 2, 1, (data) => {
                      resolve(data[0]);
                    });
                  })
                ]).then((data) => {
                  if (isTemperatureCycle) {
                    computed.temperature = (uint16(data[0], data[1]) >> 2) / 32 - 50;
                  } else {
                    computed.humidity = (uint16(data[0], data[1]) >> 4) / 16 - 24;
                  }
                  if (++cycle === 2) {
                    cycle = 0;
                    this.emit("data", computed);
                  }
                  readCycle();
                });
              });
            };
            readCycle();
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.TH02, options);
            return `th02-${address}`;
          }
        }
      },
      LSM303C: {
        ADDRESSES: {
          value: [
            29,
            30
          ]
        },
        COMMAND: {
          value: {
            ACC_SETUP: [4, 63, 63, 63],
            MAG_SETUP: [216, 96, 64, 216, 8, 0]
          }
        },
        REGISTER: {
          value: {
            ACC_CTRL_SEQ: [35, 32, 32, 32],
            ACC_STATUS: 39,
            ACC_OUTX_L: 40,
            ACC_OUTX_H: 41,
            ACC_OUTY_L: 42,
            ACC_OUTY_H: 43,
            ACC_OUTZ_L: 44,
            ACC_OUTZ_H: 45,
            MAG_CTRL_SEQ: [32, 33, 36, 32, 35, 34],
            MAG_STATUS: 39,
            MAG_OUTX_L: 40,
            MAG_OUTX_H: 41,
            MAG_OUTY_L: 42,
            MAG_OUTY_H: 43,
            MAG_OUTZ_L: 44,
            MAG_OUTZ_H: 45,
            MAG_TEMP_OUT_L: 46,
            MAG_TEMP_OUT_H: 47
          }
        },
        initialize: {
          value(board, options) {
            const ACC_SENSITIVITY = 0.06103515625;
            const MAG_SENSITIVITY = 48828125e-11;
            const io2 = board.io;
            const frequency = this.freq || 40;
            const [ACC_ADDRESS, MAG_ADDRESS] = this.ADDRESSES;
            const accelerometer = {};
            const magnetometer = {};
            const computed = {
              temperature: 0,
              magnetometer,
              accelerometer
            };
            const initializeAccelerometer = () => {
              io2.i2cConfig(Object.assign({}, options, { address: ACC_ADDRESS }));
              this.REGISTER.ACC_CTRL_SEQ.forEach((ctrlReg, i) => {
                io2.i2cWrite(ACC_ADDRESS, ctrlReg, this.COMMAND.ACC_SETUP[i]);
              });
            };
            const initializeMagnetometer = () => {
              io2.i2cConfig(Object.assign({}, options, { address: MAG_ADDRESS }));
              this.REGISTER.MAG_CTRL_SEQ.forEach((ctrlReg, i) => {
                io2.i2cWrite(MAG_ADDRESS, ctrlReg, this.COMMAND.MAG_SETUP[i]);
              });
            };
            const readAccelerometer = (done) => {
              io2.i2cReadOnce(ACC_ADDRESS, this.REGISTER.ACC_OUTX_L, 6, (data) => {
                accelerometer.x = int16(data[1], data[0]) * ACC_SENSITIVITY;
                accelerometer.y = int16(data[3], data[2]) * ACC_SENSITIVITY;
                accelerometer.z = int16(data[5], data[4]) * ACC_SENSITIVITY;
                done();
              });
            };
            const readMagnetometer = (done) => {
              io2.i2cReadOnce(MAG_ADDRESS, this.REGISTER.MAG_OUTX_L, 6, (data) => {
                magnetometer.x = int16(data[1], data[0]) * MAG_SENSITIVITY;
                magnetometer.y = int16(data[3], data[2]) * MAG_SENSITIVITY;
                magnetometer.z = int16(data[5], data[4]) * MAG_SENSITIVITY;
                done();
              });
            };
            const readTemperature = (done) => {
              io2.i2cReadOnce(MAG_ADDRESS, this.REGISTER.MAG_TEMP_OUT_L, 2, (data) => {
                computed.temperature = int16(data[1], data[0]);
                done();
              });
            };
            const readCycle = () => {
              Promise.all([
                new Promise(readAccelerometer),
                new Promise(readMagnetometer),
                new Promise(readTemperature)
              ]).then(() => {
                this.emit("data", computed);
                setTimeout(readCycle, frequency);
              });
            };
            initializeAccelerometer();
            initializeMagnetometer();
            readCycle();
          }
        },
        identifier: {
          value(options) {
            const address = Drivers.addressResolver(Drivers.LSM303C, options);
            return `lsm303c-${address}`;
          }
        }
      }
    };
    Drivers.BMP085 = Drivers.BMP180;
    Drivers.GY521 = Drivers.MPU6050;
    Drivers.SI7021 = Drivers.SI7020;
    Drivers.DHT11_I2C_NANO_BACKPACK = Drivers.DHT_I2C_NANO_BACKPACK;
    Drivers.DHT21_I2C_NANO_BACKPACK = Drivers.DHT_I2C_NANO_BACKPACK;
    Drivers.DHT22_I2C_NANO_BACKPACK = Drivers.DHT_I2C_NANO_BACKPACK;
    Drivers.get = (board, driverName, options = {}) => {
      let drivers;
      let driverKey;
      let driver;
      if (!activeDrivers.has(board)) {
        activeDrivers.set(board, {});
      }
      drivers = activeDrivers.get(board);
      driverKey = Drivers[driverName].identifier.value(options);
      if (!drivers[driverKey]) {
        driver = new Emitter();
        Object.defineProperties(driver, Drivers[driverName]);
        driver.initialize(board, options);
        drivers[driverKey] = driver;
      }
      return drivers[driverKey];
    };
    Drivers.addressResolver = (driver, options) => {
      const addresses = driver.ADDRESSES;
      const address = options.address || (Array.isArray(addresses) ? addresses[0] : addresses.value[0]);
      options.address = address;
      return address;
    };
    Drivers.clear = () => {
      activeDrivers.clear();
    };
    var Controllers = {
      MPU6050: {
        initialize: {
          value(options) {
            Components.call(this, "MPU6050", options);
          }
        },
        components: {
          value: [ACCELEROMETER, GYRO, THERMOMETER]
        }
      },
      BNO055: {
        initialize: {
          value(options) {
            const state = priv.get(this);
            const CONTROLLER = "BNO055";
            state.calibrationMask = options.calibrationMask || 192;
            Drivers.get(this.board, CONTROLLER, options).on("calibrated", () => this.emit("calibrated")).on("calibration", (state2) => this.emit("calibration", state2));
            Components.call(this, CONTROLLER, options);
          }
        },
        components: {
          value: [ACCELEROMETER, GYRO, MAGNETOMETER, ORIENTATION, THERMOMETER]
        },
        calibration: {
          get() {
            return this.orientation.calibration;
          }
        },
        isCalibrated: {
          get() {
            const { calibrationMask } = priv.get(this);
            return (this.orientation.calibration & calibrationMask) === calibrationMask;
          }
        }
      },
      MPL115A2: {
        initialize: {
          value(options) {
            Components.call(this, "MPL115A2", options);
          }
        },
        components: {
          value: [BAROMETER, THERMOMETER]
        }
      },
      SHT31D: {
        initialize: {
          value(options) {
            Components.call(this, "SHT31D", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      HTU21D: {
        initialize: {
          value(options) {
            Components.call(this, "HTU21D", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      HIH6130: {
        initialize: {
          value(options) {
            Components.call(this, "HIH6130", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      DHT_I2C_NANO_BACKPACK: {
        initialize: {
          value(options) {
            Components.call(this, "DHT_I2C_NANO_BACKPACK", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      MPL3115A2: {
        initialize: {
          value(options) {
            Components.call(this, "MPL3115A2", options);
          }
        },
        components: {
          value: [ALTIMETER, BAROMETER, THERMOMETER]
        }
      },
      BMP180: {
        initialize: {
          value(options) {
            Components.call(this, "BMP180", options);
          }
        },
        components: {
          value: [ALTIMETER, BAROMETER, THERMOMETER]
        }
      },
      BMP280: {
        initialize: {
          value(options) {
            Components.call(this, "BMP280", options);
          }
        },
        components: {
          value: [ALTIMETER, BAROMETER, THERMOMETER]
        }
      },
      BME280: {
        initialize: {
          value(options) {
            Components.call(this, "BME280", options);
          }
        },
        components: {
          value: [ALTIMETER, BAROMETER, HYGROMETER, THERMOMETER]
        }
      },
      SI7020: {
        initialize: {
          value(options) {
            Components.call(this, "SI7020", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      MS5611: {
        initialize: {
          value(options) {
            Components.call(this, "MS5611", options);
          }
        },
        components: {
          value: [ALTIMETER, BAROMETER, THERMOMETER]
        }
      },
      TH02: {
        initialize: {
          value(options) {
            Components.call(this, "TH02", options);
          }
        },
        components: {
          value: [HYGROMETER, THERMOMETER]
        }
      },
      LSM303C: {
        initialize: {
          value(options) {
            Components.call(this, "LSM303C", options);
          }
        },
        components: {
          value: [MAGNETOMETER, THERMOMETER, ACCELEROMETER]
        }
      }
    };
    Controllers.BMP085 = Controllers.BMP180;
    Controllers.GY521 = Controllers.MPU6050;
    Controllers.SI7021 = Controllers.SI7020;
    Controllers.DHT11_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT21_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    Controllers.DHT22_I2C_NANO_BACKPACK = Controllers.DHT_I2C_NANO_BACKPACK;
    var IMU = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        let state = {};
        priv.set(this, state);
        this.freq = options.freq || 20;
        if (typeof this.initialize === "function") {
          this.initialize(options);
        }
        this.isReady = false;
        setInterval(() => {
          if (this.isReady) {
            this.emit("data", this);
          }
        }, this.freq);
        const awaiting = this.components.slice();
        if (this.components && this.components.length > 0) {
          this.components.forEach((component) => {
            if (!(this[component] instanceof Emitter)) {
              return;
            }
            this[component].on("change", () => {
              if (awaiting.length) {
                const index = awaiting.indexOf(component);
                if (index !== -1) {
                  awaiting.splice(index, 1);
                }
              }
              if (!awaiting.length && !this.isReady) {
                this.isReady = true;
              }
              if (this.isReady) {
                this.emit("change", this, component);
              }
            });
          });
        }
      }
    };
    IMU.Drivers = Drivers;
    if (!!process.env.IS_TEST_MODE) {
      IMU.Controllers = Controllers;
      IMU.purge = () => {
        priv.clear();
      };
    }
    module2.exports = IMU;
  }
});

// node_modules/johnny-five/lib/blokdots_sunlight.js
var require_blokdots_sunlight = __commonJS({
  "node_modules/johnny-five/lib/blokdots_sunlight.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require("events");
    var { toFixed } = require_fn();
    var Controllers = {
      SI1145: {
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            Drivers.get(this.board, "SI1145", options).on("data", (data) => callback(data));
          }
        },
        toUVindex: {
          value(value) {
            return toFixed(value / 100, 2);
          }
        }
      }
    };
    var Sunlight = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const freq = options.freq || 250;
        let last = null;
        let raw = null;
        if (!this.toUVindex) {
          this.toUVindex = options.toUVindex || ((x) => x);
        }
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
          });
        }
        Object.defineProperties(this, {
          uv: {
            get() {
              return this.toUVindex(raw.uv);
            }
          },
          ir: {
            get() {
              return raw.ir;
            }
          },
          vis: {
            get() {
              return raw.vis;
            }
          }
        });
        setInterval(() => {
          if (raw === null) {
            return;
          }
          const data = {
            uv: this.uv,
            ir: this.ir,
            vis: this.vis
          };
          this.emit("data", data);
          if (last === null || this.vis !== last.vis || this.ir !== last.ir || this.uv !== last.uv) {
            if (last !== null) {
              this.emit("change", data);
            }
            last = { ...data };
          }
        }, freq);
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Sunlight.Controllers = Controllers;
      Sunlight.purge = function() {
      };
    }
    module2.exports = Sunlight;
  }
});

// node_modules/johnny-five/lib/easing.js
var require_easing = __commonJS({
  "node_modules/johnny-five/lib/easing.js"(exports, module2) {
    var SI = 1.70158;
    var SIO = 1.70158 * 1.525;
    var SB = 7.5625;
    var HALF = 0.5;
    var {
      PI,
      cos,
      sin,
      sqrt
    } = Math;
    var ease = {};
    ease.linear = (n) => n;
    ease.inQuad = (n) => n * n;
    ease.outQuad = (n) => n * (2 - n);
    ease.inOutQuad = (n) => {
      n *= 2;
      return n < 1 ? HALF * n * n : -HALF * (--n * (n - 2) - 1);
    };
    ease.inCube = (n) => n * n * n;
    ease.outCube = (n) => --n * n * n + 1;
    ease.inOutCube = (n) => {
      n *= 2;
      return n < 1 ? HALF * (n * n * n) : HALF * ((n -= 2) * n * n + 2);
    };
    ease.inQuart = (n) => n * n * n * n;
    ease.outQuart = (n) => 1 - --n * (n * n * n);
    ease.inOutQuart = (n) => {
      n *= 2;
      return n < 1 ? HALF * (n * n * n * n) : -HALF * ((n -= 2) * (n * n * n) - 2);
    };
    ease.inQuint = (n) => n * n * n * n * n;
    ease.outQuint = (n) => --n * (n * n * n * n) + 1;
    ease.inOutQuint = (n) => {
      n *= 2;
      return n < 1 ? HALF * (n * n * n * n * n) : HALF * ((n -= 2) * (n * n * n * n) + 2);
    };
    ease.inSine = (n) => 1 - cos(n * PI / 2);
    ease.outSine = (n) => sin(n * PI / 2);
    ease.inOutSine = (n) => HALF * (1 - cos(PI * n));
    ease.inExpo = (n) => n === 0 ? 0 : Math.pow(1024, n - 1);
    ease.outExpo = (n) => n === 1 ? n : 1 - Math.pow(2, -10 * n);
    ease.inOutExpo = (n) => {
      if (n === 0) {
        return 0;
      }
      if (n === 1) {
        return 1;
      }
      return (n *= 2) < 1 ? HALF * Math.pow(1024, n - 1) : HALF * (-Math.pow(2, -10 * (n - 1)) + 2);
    };
    ease.inCirc = (n) => 1 - sqrt(1 - n * n);
    ease.outCirc = (n) => sqrt(1 - --n * n);
    ease.inOutCirc = (n) => {
      n *= 2;
      return n < 1 ? -HALF * (sqrt(1 - n * n) - 1) : HALF * (sqrt(1 - (n -= 2) * n) + 1);
    };
    ease.inBack = (n) => n * n * ((SI + 1) * n - SI);
    ease.outBack = (n) => --n * n * ((SI + 1) * n + SI) + 1;
    ease.inOutBack = (n) => {
      return (n *= 2) < 1 ? HALF * (n * n * ((SIO + 1) * n - SIO)) : HALF * ((n -= 2) * n * ((SIO + 1) * n + SIO) + 2);
    };
    ease.outBounce = (n) => {
      if (n < 1 / 2.75) {
        return SB * n * n;
      } else if (n < 2 / 2.75) {
        return SB * (n -= 1.5 / 2.75) * n + 0.75;
      } else if (n < 2.5 / 2.75) {
        return SB * (n -= 2.25 / 2.75) * n + 0.9375;
      } else {
        return SB * (n -= 2.625 / 2.75) * n + 0.984375;
      }
    };
    ease.inBounce = (n) => 1 - ease.outBounce(1 - n);
    ease.inOutBounce = (n) => {
      return n < HALF ? ease.inBounce(n * 2) * HALF : ease.outBounce(n * 2 - 1) * HALF + HALF;
    };
    var exportables = {};
    Object.keys(ease).forEach((key) => {
      exportables[key.toLowerCase()] = ease[key];
    });
    module2.exports = new Proxy({}, {
      get(target, property) {
        return exportables[property.replace(/([a-z])([A-Z])/g, "$1$2").toLowerCase()];
      }
    });
  }
});

// node_modules/temporal/lib/temporal.js
var require_temporal = __commonJS({
  "node_modules/temporal/lib/temporal.js"(exports, module2) {
    var Emitter = require("events").EventEmitter;
    var util = require("util");
    var resolutionDivisor = 1e6;
    var exportable = new Emitter();
    var queue = {};
    var gLast = Date.now();
    var isProcessing = false;
    var tick = global.setImmediate || process.nextTick;
    var hrTime = function() {
      var hrtime = process.hrtime();
      return Math.floor((hrtime[0] * 1e9 + hrtime[1]) / resolutionDivisor);
    };
    var time = function() {
      return Date.now();
    };
    var getTime = time;
    function Task(entry) {
      if (!(this instanceof Task)) {
        return new Task(entry);
      }
      this.called = 0;
      this.now = this.calledAt = getTime();
      if (resolutionDivisor !== 1e6) {
        entry.time = ~~(entry.time * (1e6 / resolutionDivisor));
      }
      this.isRunnable = true;
      this.later = this.now + entry.time;
      this.task = entry.task;
      this.type = entry.type;
      this.time = entry.time;
      if (this.later > gLast) {
        gLast = this.later;
      }
      if (!queue[this.later]) {
        queue[this.later] = [];
      }
      queue[this.later].push(this);
    }
    util.inherits(Task, Emitter);
    Task.deriveOp = function(p, v) {
      return v !== "task" ? v : p;
    };
    Task.prototype.stop = function() {
      this.isRunnable = false;
      this.emit("stop");
    };
    function Queue(tasks) {
      this.refs = [];
      this.add(tasks);
    }
    util.inherits(Queue, Emitter);
    Queue.prototype.stop = function() {
      this.refs.forEach(function(ref) {
        ref.stop();
      });
      this.emit("stop");
    };
    Queue.prototype.add = function(tasks) {
      var op, item, task, ref;
      this.cumulative = this.cumulative || 0;
      while (tasks.length) {
        item = tasks.shift();
        op = Object.keys(item).reduce(Task.deriveOp, "");
        this.cumulative += item[op];
        if (tasks.length === 0) {
          task = item.task;
          item.task = (temporald) => {
            task.call(this, temporald);
            this.emit("end", temporald);
            this.cumulative = 0;
          };
        }
        if (op === "loop" && tasks.length === 0) {
          ref = exportable.delay(this.cumulative - item[op], () => {
            ref = exportable.loop(item[op], item.task);
            this.refs.push(ref);
          });
        } else {
          ref = exportable[op](this.cumulative, item.task);
        }
        this.refs.push(ref);
      }
    };
    exportable.queue = function(tasks) {
      var queue2 = new Queue(tasks);
      processQueue();
      return queue2;
    };
    var previousTime = getTime();
    function processQueue() {
      if (!isProcessing) {
        isProcessing = true;
        exportable.emit("busy");
      }
      var now = getTime();
      var entries = [];
      var callProcessQueue = true;
      var entry, i;
      if (gLast <= now) {
        callProcessQueue = false;
      }
      for (i = previousTime; i <= now; i++) {
        [].push.apply(entries, queue[i] || []);
      }
      if (entries.length) {
        while (entries.length) {
          entry = entries.shift();
          if (entry.isRunnable) {
            entry.called++;
            entry.calledAt = now;
            entry.task.call(entry, entry);
          }
          if (entry.type === "loop" && entry.isRunnable) {
            callProcessQueue = true;
            entry.later = now + entry.time;
            if (entry.later > gLast) {
              gLast = entry.later;
            }
            if (!queue[entry.later]) {
              queue[entry.later] = [];
            }
            if (entry.isRunnable) {
              queue[entry.later].push(entry);
            }
          }
        }
        for (i = previousTime; i <= now; i++) {
          delete queue[i];
        }
        entries.length = 0;
      }
      previousTime = now;
      if (callProcessQueue) {
        tick(processQueue);
      } else {
        isProcessing = false;
        exportable.emit("idle");
      }
    }
    ["loop", "delay"].forEach(function(type) {
      exportable[type] = function(time2, operation) {
        if (typeof time2 === "function") {
          operation = time2;
          time2 = 10;
        }
        var task = new Task({
          time: time2,
          type,
          task: operation
        });
        if (!isProcessing) {
          processQueue();
        }
        return task;
      };
    });
    exportable.wait = exportable.defer = exportable.delay;
    exportable.repeat = function(n, ms, callback) {
      return exportable.loop(ms, function(context) {
        callback(context);
        if (context.called === n) {
          this.stop();
        }
      });
    };
    exportable.clear = function() {
      isProcessing = false;
      exportable.removeAllListeners();
      queue = {};
    };
    exportable.resolution = function(value) {
      if (value === 0.1 || value === 0.01) {
        resolutionDivisor = 1e6 * value;
        getTime = hrTime;
      } else {
        resolutionDivisor = 1e6;
        getTime = time;
      }
      previousTime = getTime();
    };
    module2.exports = exportable;
  }
});

// node_modules/johnny-five/lib/animation.js
var require_animation = __commonJS({
  "node_modules/johnny-five/lib/animation.js"(exports, module2) {
    var Emitter = require_emitter();
    var ease = require_easing();
    var { cloneDeep, constrain } = require_fn();
    var temporal;
    var temporalTTL = 5e3;
    var Animation = class extends Emitter {
      constructor(target) {
        super();
        if (!temporal) {
          temporal = require_temporal();
        }
        Object.assign(this, new Animation.Segment());
        this.defaultTarget = target || {};
      }
      enqueue(options = {}) {
        if (typeof options.target === "undefined") {
          options.target = this.defaultTarget;
        }
        this.segments.push(options);
        if (!this.paused && !this.isRunning) {
          this.next();
        }
        return this;
      }
      next() {
        if (this.isRunning) {
          return this;
        } else {
          this.isRunning = true;
        }
        if (this.segments.length > 0) {
          Object.assign(this, new Animation.Segment(this.segments.shift()));
          this.paused = this.currentSpeed === 0 ? true : false;
          if (this.onstart) {
            this.onstart();
          }
          this.normalizeKeyframes();
          if (this.reverse) {
            this.currentSpeed *= -1;
          }
          if (this.currentSpeed !== 0) {
            this.play();
          } else {
            this.paused = true;
          }
        } else {
          this.playLoop.stop();
        }
        return this;
      }
      pause() {
        this.emit("animation:pause");
        if (this.playLoop) {
          this.playLoop.stop();
        }
        this.paused = true;
        if (this.onpause) {
          this.onpause();
        }
      }
      stop() {
        this.emit("animation:stop");
        this.segments = [];
        this.isRunning = false;
        if (this.playLoop) {
          this.playLoop.stop();
        }
        if (this.onstop) {
          this.onstop();
        }
      }
      speed(speed) {
        if (typeof speed === "undefined") {
          return this.currentSpeed;
        } else {
          this.currentSpeed = speed;
          this.scaledDuration = this.duration / Math.abs(this.currentSpeed);
          this.startTime = Date.now() - this.scaledDuration * this.progress;
          this.endTime = this.startTime + this.scaledDuration;
          if (!this.paused) {
            this.play();
          }
          return this;
        }
      }
      loopFunction({ calledAt }) {
        const progress = this.calculateProgress(calledAt);
        const indices = this.findIndices(progress);
        this.target[Animation.render](this.tweenedValue(indices, progress));
        if (calledAt > this.fallBackTime) {
          this.fallBackTime = Infinity;
          if (this.playLoop) {
            this.playLoop.stop();
          }
          this.playLoop = new Animation.TemporalFallback(this);
        }
        if (this.progress === 1 && !this.reverse || progress === this.loopback && this.reverse) {
          if (this.loop || this.metronomic && !this.reverse) {
            if (this.onloop) {
              this.onloop();
            }
            if (this.metronomic) {
              this.reverse = this.reverse ? false : true;
            }
            this.normalizeKeyframes();
            this.progress = this.loopback;
            this.startTime = Date.now() - this.scaledDuration * this.progress;
            this.endTime = this.startTime + this.scaledDuration;
          } else {
            this.isRunning = false;
            if (this.oncomplete) {
              process.nextTick(() => this.oncomplete());
            }
            if (this.segments.length > 0) {
              process.nextTick(() => this.next());
            } else {
              this.stop();
            }
          }
        }
      }
      play() {
        const now = Date.now();
        if (this.playLoop) {
          this.playLoop.stop();
        }
        this.paused = false;
        this.isRunning = true;
        this.scaledDuration = this.duration / Math.abs(this.currentSpeed);
        this.startTime = now - this.scaledDuration * this.progress;
        this.endTime = this.startTime + this.scaledDuration;
        this.fallBackTime = now + temporalTTL;
        this.frameCount = 0;
        if (this.fps) {
          this.rate = 1e3 / this.fps;
        }
        this.rate = this.rate | 0;
        this.playLoop = temporal.loop(this.rate, (data) => this.loopFunction(data));
      }
      findIndices(progress) {
        const indices = {
          left: null,
          right: null
        };
        indices.right = this.cuePoints.findIndex((point) => point >= progress);
        indices.left = indices.right === 0 ? 0 : indices.right - 1;
        return indices;
      }
      calculateProgress(calledAt) {
        let progress = (calledAt - this.startTime) / this.scaledDuration;
        if (progress > 1) {
          progress = 1;
        }
        this.progress = progress;
        if (this.reverse) {
          progress = 1 - progress;
        }
        return constrain(ease[this.easing](progress), 0, 1);
      }
      tweenedValue(indices, progress) {
        const tween = {
          duration: null,
          progress: null
        };
        const result = this.normalizedKeyFrames.map((keyFrame) => {
          const kIndices = {
            left: null,
            right: null
          };
          for (kIndices.left = indices.left; kIndices.left > -1; kIndices.left--) {
            if (keyFrame[kIndices.left] !== null) {
              break;
            }
          }
          kIndices.right = keyFrame.findIndex((frame, index) => index >= indices.right && frame !== null);
          tween.duration = this.cuePoints[kIndices.right] - this.cuePoints[kIndices.left];
          tween.progress = (progress - this.cuePoints[kIndices.left]) / tween.duration;
          if (!Number.isFinite(tween.progress)) {
            tween.progress = this.reverse ? 0 : 1;
          }
          const left = keyFrame[kIndices.left];
          const right = keyFrame[kIndices.right];
          tween.progress = ease[right.easing](tween.progress);
          let calcValue;
          if (right.position) {
            calcValue = right.position.map((value, index) => (value - left.position[index]) * tween.progress + left.position[index]);
          } else {
            if (typeof right.value === "number" && typeof left.value === "number") {
              calcValue = (right.value - left.value) * tween.progress + left.value;
            } else {
              calcValue = this.target[Animation.keys].reduce((accum, key) => {
                accum[key] = (right.value[key] - left.value[key]) * tween.progress + left.value[key];
                return accum;
              }, {});
            }
          }
          return calcValue;
        });
        return result;
      }
      normalizeKeyframes() {
        let previousVal;
        let keyFrameSet = cloneDeep(this.keyFrames);
        const cuePoints = this.cuePoints;
        keyFrameSet = this.target[Animation.normalize](keyFrameSet);
        if (!Array.isArray(keyFrameSet[0])) {
          keyFrameSet = [keyFrameSet];
        }
        keyFrameSet.forEach(function(keyFrames) {
          for (let i = keyFrames.length; i < cuePoints.length; i++) {
            keyFrames.push(null);
          }
          keyFrames.forEach((keyFrame, i, source) => {
            if (keyFrame !== null) {
              if (typeof keyFrame !== "object") {
                keyFrame = {
                  step: keyFrame,
                  easing: "linear"
                };
              }
              if (typeof keyFrame.step !== "undefined") {
                keyFrame.value = keyFrame.step === false ? previousVal : previousVal + keyFrame.step;
              }
              if (!keyFrame.easing) {
                keyFrame.easing = "linear";
              }
              if (typeof keyFrame.copyValue !== "undefined") {
                keyFrame.value = source[keyFrame.copyValue].value;
              }
              if (keyFrame.copyFrame) {
                keyFrame = source[keyFrame.copyFrame];
              }
              previousVal = keyFrame.value;
            } else {
              if (i === source.length - 1) {
                keyFrame = {
                  value: previousVal,
                  easing: "linear"
                };
              } else {
                keyFrame = null;
              }
            }
            source[i] = keyFrame;
          }, this);
        });
        this.normalizedKeyFrames = keyFrameSet;
        return this;
      }
    };
    Animation.keys = "@@keys";
    Animation.normalize = "@@normalize";
    Animation.render = "@@render";
    Animation.TemporalFallback = class {
      constructor(animation) {
        this.interval = setInterval(() => {
          animation.loopFunction({
            calledAt: Date.now()
          });
        }, animation.rate);
      }
      stop() {
        if (this.interval) {
          clearInterval(this.interval);
        }
      }
    };
    Animation.Segment = class {
      constructor(options) {
        this.cuePoints = [0, 1];
        this.duration = 1e3;
        this.easing = "linear";
        this.loop = false;
        this.loopback = 0;
        this.metronomic = false;
        this.currentSpeed = 1;
        this.progress = 0;
        this.fps = 60;
        this.rate = 1e3 / 60;
        this.paused = false;
        this.isRunning = false;
        this.segments = [];
        this.onstart = null;
        this.onpause = null;
        this.onstop = null;
        this.oncomplete = null;
        this.onloop = null;
        if (options) {
          Object.assign(this, options);
          if (options.segments) {
            this.segments = options.segments.slice();
          }
        }
      }
    };
    module2.exports = Animation;
  }
});

// node_modules/johnny-five/lib/evshield.js
var require_evshield = __commonJS({
  "node_modules/johnny-five/lib/evshield.js"(exports, module2) {
    var Emitter = require_emitter();
    var shared;
    var Bank = class {
      constructor(options) {
        this.address = options.address;
        this.io = options.io;
        this.io.i2cConfig(options);
      }
      read(register, numBytes, callback) {
        if (register) {
          this.io.i2cRead(this.address, register, numBytes, callback);
        } else {
          this.io.i2cRead(this.address, numBytes, callback);
        }
      }
      write(register, bytes) {
        if (!Array.isArray(bytes)) {
          bytes = [bytes];
        }
        this.io.i2cWrite(this.address, register, bytes);
      }
    };
    var EVS = class extends Emitter {
      constructor({ io: io2 }) {
        super();
        if (shared) {
          return shared;
        }
        this.bank = {
          a: new Bank({
            address: EVS.BANK_A,
            io: io2
          }),
          b: new Bank({
            address: EVS.BANK_B,
            io: io2
          })
        };
        shared = this;
      }
      setup({ bank, mode }, type) {
        this.bank[bank].write(mode, [type]);
      }
      read(port, register, numBytes, callback) {
        if (port.sensor && port.offset && !EVS.isRawSensor(port)) {
          register += port.offset;
        }
        this.bank[port.bank].read(register, numBytes, callback);
      }
      write({ bank }, register, data) {
        this.bank[bank].write(register, data);
      }
    };
    EVS.shieldPort = (pin) => {
      const port = EVS[pin];
      if (port === void 0) {
        throw new Error("Invalid EVShield pin name");
      }
      let address;
      let analog;
      let bank;
      let motor;
      let mode;
      let offset;
      let sensor;
      let endsWithS1 = false;
      if (pin.startsWith("BA")) {
        address = EVS.BANK_A;
        bank = "a";
      } else {
        address = EVS.BANK_B;
        bank = "b";
      }
      if (pin.includes("M")) {
        motor = pin.endsWith("M1") ? EVS.S1 : EVS.S2;
      }
      if (pin.includes("S")) {
        endsWithS1 = pin.endsWith("S1");
        analog = endsWithS1 ? EVS.S1_ANALOG : EVS.S2_ANALOG;
        mode = endsWithS1 ? EVS.S1_MODE : EVS.S2_MODE;
        offset = endsWithS1 ? EVS.S1_OFFSET : EVS.S2_OFFSET;
        sensor = endsWithS1 ? EVS.S1 : EVS.S2;
      }
      return {
        address,
        analog,
        bank,
        mode,
        motor,
        offset,
        port,
        sensor
      };
    };
    EVS.isRawSensor = ({ analog }) => analog === EVS.S1_ANALOG || analog === EVS.S2_ANALOG;
    EVS.BAS1 = 1;
    EVS.BAS2 = 2;
    EVS.BBS1 = 3;
    EVS.BBS2 = 4;
    EVS.BAM1 = 5;
    EVS.BAM2 = 6;
    EVS.BBM1 = 7;
    EVS.BBM2 = 8;
    EVS.BANK_A = 26;
    EVS.BANK_B = 27;
    EVS.S1 = 1;
    EVS.S2 = 2;
    EVS.M1 = 1;
    EVS.M2 = 2;
    EVS.MM = 3;
    EVS.Type_NONE = 0;
    EVS.Type_SWITCH = 1;
    EVS.Type_ANALOG = 2;
    EVS.Type_I2C = 9;
    EVS.Type_NXT_LIGHT_REFLECTED = 3;
    EVS.Type_NXT_LIGHT = 4;
    EVS.Type_NXT_COLOR = 13;
    EVS.Type_NXT_COLOR_RGBRAW = 4;
    EVS.Type_NXT_COLORRED = 14;
    EVS.Type_NXT_COLORGREEN = 15;
    EVS.Type_NXT_COLORBLUE = 16;
    EVS.Type_NXT_COLORNONE = 17;
    EVS.Type_DATABIT0_HIGH = 64;
    EVS.S1_MODE = 111;
    EVS.S1_ANALOG = 112;
    EVS.S1_OFFSET = 0;
    EVS.S2_MODE = 163;
    EVS.S2_ANALOG = 164;
    EVS.S2_OFFSET = 52;
    EVS.Type_EV3_LIGHT_REFLECTED = 0;
    EVS.Type_EV3_LIGHT = 1;
    EVS.Type_EV3_COLOR = 2;
    EVS.Type_EV3_COLOR_REFRAW = 3;
    EVS.Type_EV3_COLOR_RGBRAW = 4;
    EVS.Type_EV3_TOUCH = 18;
    EVS.Type_EV3 = 19;
    EVS.Light = 131;
    EVS.Bump = 132;
    EVS.ColorMeasure = 131;
    EVS.Proximity = 131;
    EVS.Touch = 131;
    EVS.Ultrasonic = 129;
    EVS.Mode = 129;
    EVS.Light_Bytes = 2;
    EVS.Analog_Bytes = 2;
    EVS.Bump_Bytes = 1;
    EVS.ColorMeasure_Bytes = 2;
    EVS.Proximity_Bytes = 2;
    EVS.Touch_Bytes = 1;
    EVS.Motor_1 = 1;
    EVS.Motor_2 = 2;
    EVS.Motor_Both = 3;
    EVS.Motor_Next_Action_Float = 0;
    EVS.Motor_Next_Action_Brake = 1;
    EVS.Motor_Next_Action_BrakeHold = 2;
    EVS.Motor_Stop = 96;
    EVS.Motor_Reset = 82;
    EVS.Motor_Reverse = 0;
    EVS.Motor_Forward = 1;
    EVS.Motor_Move_Absolute = 0;
    EVS.Motor_Move_Relative = 1;
    EVS.Motor_Completion_Dont_Wait = 0;
    EVS.Motor_Completion_Wait_For = 1;
    EVS.Speed_Full = 90;
    EVS.Speed_Medium = 60;
    EVS.Speed_Slow = 25;
    EVS.CONTROL_SPEED = 1;
    EVS.CONTROL_RAMP = 2;
    EVS.CONTROL_RELATIVE = 4;
    EVS.CONTROL_TACHO = 8;
    EVS.CONTROL_BRK = 16;
    EVS.CONTROL_ON = 32;
    EVS.CONTROL_TIME = 64;
    EVS.CONTROL_GO = 128;
    EVS.STATUS_SPEED = 1;
    EVS.STATUS_RAMP = 2;
    EVS.STATUS_MOVING = 4;
    EVS.STATUS_TACHO = 8;
    EVS.STATUS_BREAK = 16;
    EVS.STATUS_OVERLOAD = 32;
    EVS.STATUS_TIME = 64;
    EVS.STATUS_STALL = 128;
    EVS.COMMAND = 65;
    EVS.VOLTAGE = 110;
    EVS.SETPT_M1 = 66;
    EVS.SPEED_M1 = 70;
    EVS.TIME_M1 = 71;
    EVS.CMD_B_M1 = 72;
    EVS.CMD_A_M1 = 73;
    EVS.SETPT_M2 = 74;
    EVS.SPEED_M2 = 78;
    EVS.TIME_M2 = 79;
    EVS.CMD_B_M2 = 80;
    EVS.CMD_A_M2 = 81;
    EVS.POSITION_M1 = 82;
    EVS.POSITION_M2 = 86;
    EVS.STATUS_M1 = 90;
    EVS.STATUS_M2 = 91;
    EVS.TASKS_M1 = 92;
    EVS.TASKS_M2 = 93;
    EVS.ENCODER_PID = 94;
    EVS.SPEED_PID = 100;
    EVS.PASS_COUNT = 106;
    EVS.TOLERANCE = 107;
    EVS.BTN_PRESS = 218;
    EVS.RGB_LED = 215;
    EVS.CENTER_RGB_LED = 222;
    module2.exports = EVS;
  }
});

// node_modules/johnny-five/lib/button.js
var require_button = __commonJS({
  "node_modules/johnny-five/lib/button.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var Emitter = require_emitter();
    var EVS = require_evshield();
    var Fn = require_fn();
    var priv = new Map();
    var Pins = Board.Pins;
    var aliases = {
      down: ["down", "press"],
      up: ["up", "release"]
    };
    var Controllers = {
      DEFAULT: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (Pins.isFirmata(this) && (typeof options.pinValue === "string" && (options.pinValue.length > 1 && options.pinValue[0] === "A"))) {
              options.pinValue = this.io.analogPins[+options.pinValue.slice(1)];
            }
            this.pin = Number.isNaN(+options.pinValue) ? options.pinValue : +options.pinValue;
            this.io.pinMode(this.pin, this.io.MODES.INPUT);
            if (this.pullup) {
              this.io.digitalWrite(this.pin, this.io.HIGH);
            }
            if (this.pulldown) {
              this.io.digitalWrite(this.pin, this.io.LOW);
            }
            this.io.digitalRead(this.pin, (data) => {
              if (data !== state.last) {
                callback(data);
              }
            });
          }
        },
        toBoolean: {
          writable: true,
          value(raw) {
            return raw === this.downValue;
          }
        }
      },
      TINKERKIT: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            let value = 0;
            this.io.pinMode(this.pin, this.io.MODES.ANALOG);
            this.io.analogRead(this.pin, (data) => {
              data = data > 512 ? 1 : 0;
              if (data !== value && data !== state.last) {
                callback(data);
              }
              value = data;
            });
          }
        },
        toBoolean: {
          writable: true,
          value(raw) {
            return raw === this.downValue;
          }
        }
      },
      EVS_EV3: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.previous = 0;
            state.shield = EVS.shieldPort(options.pin);
            state.register = EVS.Touch;
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_EV3_TOUCH);
            state.ev3.read(state.shield, EVS.Touch, EVS.Touch_Bytes, (data) => {
              const value = data[0];
              if (state.previous !== value) {
                callback(value);
              }
              state.previous = value;
            });
          }
        },
        toBoolean: {
          writable: true,
          value(raw) {
            return raw === this.downValue;
          }
        }
      },
      EVS_NXT: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.previous = 0;
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_ANALOG);
            state.ev3.read(state.shield, state.shield.analog, EVS.Analog_Bytes, (data) => {
              let value = data[0] | data[1] << 8;
              value = value < 300 ? 1 : 0;
              if (state.previous !== value) {
                callback(value);
              }
              state.previous = value;
            });
          }
        },
        toBoolean: {
          writable: true,
          value(raw) {
            return raw === this.downValue;
          }
        }
      }
    };
    var Button = class extends Emitter {
      constructor(options) {
        super();
        let raw;
        let invert = false;
        let downValue = 1;
        let upValue = 0;
        const state = {
          interval: null,
          last: null
        };
        const trigger = Fn.debounce((key) => {
          aliases[key].forEach((type) => this.emit(type));
        }, 7);
        let pinValue = typeof options === "object" ? options.pin : options;
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        options.pinValue = pinValue;
        this.holdtime = options.holdtime || 500;
        this.pullup = options.pullup || options.isPullup || false;
        this.pulldown = options.pulldown || options.isPulldown || false;
        invert = typeof options.invert !== "undefined" ? options.invert : this.pullup || false;
        if (invert) {
          downValue = downValue ^ 1;
          upValue = upValue ^ 1;
        }
        state.last = upValue;
        priv.set(this, state);
        Object.defineProperties(this, {
          value: {
            get() {
              return Number(this.isDown);
            }
          },
          invert: {
            get() {
              return invert;
            },
            set(value) {
              invert = value;
              downValue = invert ? 0 : 1;
              upValue = invert ? 1 : 0;
              state.last = upValue;
            }
          },
          downValue: {
            get() {
              return downValue;
            },
            set(value) {
              downValue = value;
              upValue = value ^ 1;
              invert = value ? true : false;
              state.last = upValue;
            }
          },
          upValue: {
            get() {
              return upValue;
            },
            set(value) {
              upValue = value;
              downValue = value ^ 1;
              invert = value ? true : false;
              state.last = downValue;
            }
          },
          isDown: {
            get() {
              return this.toBoolean(raw);
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
            if (!this.isDown) {
              if (state.interval) {
                clearInterval(state.interval);
              }
              trigger("up");
            }
            if (this.isDown) {
              trigger("down");
              state.interval = setInterval(() => {
                if (this.isDown) {
                  this.emit("hold");
                }
              }, this.holdtime);
            }
            state.last = data;
          });
        }
      }
    };
    var Buttons = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Button;
      }
    };
    Collection.installMethodForwarding(Buttons.prototype, Button.prototype);
    Button.Collection = Buttons;
    if (!!process.env.IS_TEST_MODE) {
      Button.Controllers = Controllers;
      Button.purge = function() {
        priv.clear();
      };
    }
    module2.exports = Button;
  }
});

// node_modules/johnny-five/lib/color.js
var require_color = __commonJS({
  "node_modules/johnny-five/lib/color.js"(exports, module2) {
    var Board = require_board();
    var EVS = require_evshield();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var priv = new Map();
    var Controllers = {
      EVS_EV3: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (options.mode) {
              options.mode = options.mode.toUpperCase();
            }
            state.mode = options.mode === "RAW" ? EVS.Type_EV3_COLOR_RGBRAW : EVS.Type_EV3_COLOR;
            state.bytes = state.mode === EVS.Type_EV3_COLOR_RGBRAW ? 6 : 2;
            state.colors = [
              [],
              [0, 0, 0],
              [0, 0, 255],
              [0, 128, 0],
              [255, 255, 0],
              [255, 0, 0],
              [255, 255, 255],
              [139, 69, 19]
            ];
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_EV3);
            state.ev3.write(state.shield, 129 + state.shield.offset, state.mode);
            state.ev3.read(state.shield, EVS.ColorMeasure, state.bytes, (data) => {
              let value = "";
              if (state.bytes === 2) {
                value += String(data[0] | data[1] << 8 || 1);
              } else {
                for (let i = 0; i < 3; i++) {
                  value += data[i * 2].toString(16).padStart(2, "0");
                }
              }
              callback(value);
            });
          }
        },
        toRGB: {
          value(raw) {
            const state = priv.get(this);
            if (state.mode === EVS.Type_EV3_COLOR) {
              return raw > 0 && raw < 8 ? state.colors[raw] : state.colors[0];
            } else {
              raw = String(raw);
              return [0, 0, 0].map((zero, index) => parseInt(raw.slice(index * 2, index * 2 + 2), 16));
            }
          }
        }
      },
      EVS_NXT: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (options.mode) {
              options.mode = options.mode.toUpperCase();
            }
            state.mode = options.mode === "RAW" ? EVS.Type_NXT_COLOR_RGBRAW : EVS.Type_NXT_COLOR;
            state.bytes = state.mode === EVS.Type_NXT_COLOR_RGBRAW ? 10 : 1;
            if (state.mode === EVS.Type_NXT_COLOR_RGBRAW) {
              throw new Error("Raw RGB is not currently supported for the NXT.");
            }
            state.colors = [
              [],
              [0, 0, 0],
              [0, 0, 255],
              [0, 128, 0],
              [255, 255, 0],
              [255, 0, 0],
              [255, 255, 255]
            ];
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_NXT_COLOR);
            state.ev3.read(state.shield, 112 + state.shield.offset, state.bytes, (data) => {
              let value = "";
              if (state.bytes === 1) {
                value += String(data[0]);
              } else {
              }
              callback(value);
            });
          }
        },
        toRGB: {
          value(raw) {
            const state = priv.get(this);
            if (state.mode === EVS.Type_NXT_COLOR) {
              return raw > 0 && raw < 7 ? state.colors[raw] : state.colors[0];
            } else {
              raw = String(raw);
              return [0, 0, 0].map((zero, index) => parseInt(raw.slice(index * 2, index * 2 + 2), 16));
            }
          }
        }
      },
      ISL29125: {
        ADDRESSES: {
          value: [68]
        },
        REGISTER: {
          value: {
            RESET: 0,
            CONFIG1: 1,
            CONFIG2: 2,
            CONFIG3: 3,
            READ: 9
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            this.io.i2cConfig(options);
            this.io.i2cWriteReg(address, this.REGISTER.RESET, 70);
            this.io.i2cWriteReg(address, this.REGISTER.CONFIG1, 5 | 8 | 0);
            this.io.i2cWriteReg(address, this.REGISTER.CONFIG2, 63);
            this.io.i2cWriteReg(address, this.REGISTER.CONFIG3, 0);
            this.io.i2cRead(address, this.REGISTER.READ, 6, (data) => {
              let value = "";
              const g = data[1] << 8 | data[0];
              const r = data[3] << 8 | data[2];
              const b = data[5] << 8 | data[4];
              const rgb = [r >> 2, g >> 2, b >> 2].map((value2) => Fn.constrain(value2, 0, 255));
              for (let i = 0; i < 3; i++) {
                value += rgb[i].toString(16).padStart(2, "0");
              }
              callback(value);
            });
          }
        },
        toRGB: {
          value(raw) {
            raw = String(raw);
            return [0, 0, 0].map((zero, index) => parseInt(raw.slice(index * 2, index * 2 + 2), 16));
          }
        }
      }
    };
    var colorNames = ["red", "green", "blue"];
    var Color2 = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {};
        const freq = options.freq || 25;
        let raw = 0;
        let last = null;
        priv.set(this, state);
        if (!this.toRGB) {
          this.toRGB = options.toRGB || ((x) => x);
        }
        Object.defineProperties(this, {
          value: {
            get() {
              return raw;
            }
          },
          rgb: {
            get() {
              return this.toRGB(raw).reduce((accum, value, index) => {
                accum[colorNames[index]] = value;
                return accum;
              }, {});
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
          });
        }
        setInterval(() => {
          if (raw === void 0) {
            return;
          }
          const data = {
            rgb: this.rgb
          };
          this.emit("data", data);
          if (raw !== last) {
            last = raw;
            this.emit("change", data);
          }
        }, freq);
      }
      static hexCode(rgb) {
        if (rgb.red === void 0 || rgb.green === void 0 || rgb.blue === void 0) {
          return null;
        }
        return rgb.length === 0 ? "unknown" : colorNames.reduce((accum, name) => accum += rgb[name].toString(16).padStart(2, "0"), "");
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Color2.Controllers = Controllers;
      Color2.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Color2;
  }
});

// node_modules/johnny-five/lib/esc.js
var require_esc = __commonJS({
  "node_modules/johnny-five/lib/esc.js"(exports, module2) {
    var Board = require_board();
    var Expander = require_expander();
    var Pins = Board.Pins;
    var Collection = require_collection();
    var { scale, fscale, constrain } = require_fn();
    var priv = new Map();
    var Controllers = {
      PCA9685: {
        initialize: {
          value: function(options) {
            const state = priv.get(this);
            this.address = options.address || 64;
            this.pwmRange = options.pwmRange || [1e3, 2e3];
            this.frequency = options.frequency || 50;
            state.expander = Expander.get({
              address: this.address,
              controller: this.controller,
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            this.pin = state.expander.normalize(options.pin);
          }
        },
        update: {
          writable: true,
          value: function(us) {
            const state = priv.get(this);
            state.expander.servoWrite(this.pin, us);
          }
        }
      },
      DEFAULT: {
        initialize: {
          value: function(options) {
            if (options.debug && !this.board.pins.isServo(this.pin)) {
              Board.Pins.Error({
                pin: this.pin,
                type: "PWM",
                via: "Servo"
              });
            }
            this.io.servoConfig(this.pin, this.pwmRange[0], this.pwmRange[1]);
          }
        },
        update: {
          writable: true,
          value: function(us) {
            this.io.servoWrite(this.pin, us);
          }
        }
      }
    };
    var FORWARD = "FORWARD";
    var FORWARD_REVERSE = "FORWARD_REVERSE";
    var FORWARD_BRAKE_REVERSE = "FORWARD_BRAKE_REVERSE";
    var Devices = {
      [FORWARD]: {
        device: {
          value: FORWARD
        }
      },
      [FORWARD_REVERSE]: {
        device: {
          value: FORWARD_REVERSE
        }
      },
      [FORWARD_BRAKE_REVERSE]: {
        device: {
          value: FORWARD_BRAKE_REVERSE
        }
      }
    };
    var ESC = class {
      constructor(options) {
        if (!(this instanceof ESC)) {
          return new ESC(options);
        }
        Board.Component.call(this, options = Board.Options(options));
        let pinValue;
        if (typeof options.controller === "undefined" && Pins.isFirmata(this)) {
          if (typeof pinValue === "string" && (pinValue.length > 1 && pinValue[0] === "A")) {
            pinValue = this.io.analogPins[+pinValue.slice(1)];
          }
          pinValue = +pinValue;
          if (!Number.isNaN(pinValue) && this.pin !== pinValue) {
            this.pin = pinValue;
          }
        }
        Board.Controller.call(this, Controllers, options);
        Object.defineProperties(this, options.device && Devices[options.device] || Devices.FORWARD);
        this.pwmRange = options.pwmRange || [1e3, 2e3];
        this.neutral = options.neutral;
        priv.set(this, {});
        this.initialize(options);
        const [low, high] = this.pwmRange;
        if (typeof this.neutral !== "undefined" && this.neutral <= 100) {
          this.neutral = scale(this.neutral, 0, 100, low, high);
        }
        if (typeof this.neutral === "undefined") {
          this.neutral = (low + high) / 2;
        }
        this.neutral = constrain(this.neutral, low, high);
        if (this.device === FORWARD_REVERSE && this.neutral === low) {
          throw new Error("Bidirectional (FORWARD_REVERSE) speed controllers require a non-zero neutral point");
        }
        if (this.device === FORWARD) {
          this.neutral = low;
        }
        this.throttle(this.neutral);
      }
      throttle(value) {
        if (value > 0 && value <= 100) {
          if (this.device !== "FORWARD") {
            throw new Error("Bidirectional (FORWARD_REVERSE, FORWARD_*_REVERSE) speed controllers require a pulse in usec");
          }
          value = fscale(value, 0, 100, this.pwmRange[0], this.pwmRange[1]);
        }
        this.update(constrain(value, this.pwmRange[0], this.pwmRange[1]));
        return this;
      }
      brake() {
        this.update(this.neutral);
        return this;
      }
    };
    var ESCs = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return ESC;
      }
    };
    Collection.installMethodForwarding(ESCs.prototype, ESC.prototype);
    ESC.Collection = ESCs;
    if (!!process.env.IS_TEST_MODE) {
      ESC.Controllers = Controllers;
      ESC.purge = function() {
        priv.clear();
      };
    }
    module2.exports = ESC;
  }
});

// node_modules/johnny-five/lib/gps.js
var require_gps = __commonJS({
  "node_modules/johnny-five/lib/gps.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Pin = require_pin();
    var { toFixed } = require_fn();
    var priv = new Map();
    var Breakouts = {
      ADAFRUIT_ULTIMATE_GPS: {
        receiver: {
          value: "FGPMMOPA6H"
        }
      }
    };
    var Receivers = {
      FGPMMOPA6H: {
        chip: {
          value: "MT3339"
        }
      }
    };
    var Chips = {
      DEFAULT: {
        baud: {
          value: 9600,
          writable: true
        },
        configure: {
          value(callback) {
            process.nextTick(callback);
          }
        }
      },
      MT3339: {
        baud: {
          value: 9600,
          writable: true
        },
        configure: {
          value(callback) {
            process.nextTick(callback);
          }
        },
        frequency: {
          get() {
            const state = priv.get(this);
            return state.frequency;
          },
          set(frequency) {
            const state = priv.get(this);
            if (frequency < 10) {
              frequency = 10;
            }
            state.frequency = frequency;
            this.sendCommand(`$PMTK220,${String(1e3 / state.frequency)}`);
          }
        },
        restart: {
          value(coldRestart) {
            if (coldRestart === true) {
              this.sendCommand("$PMTK103");
            } else {
              this.sendCommand("$PMTK101");
              setTimeout(() => {
                this.sendCommand("");
              }, 1e3);
            }
          }
        }
      }
    };
    var GPS = class extends Emitter {
      constructor(options) {
        super();
        if (Array.isArray(options)) {
          options = {
            pins: {
              rx: options[0],
              tx: options[1],
              onOff: options[2]
            }
          };
        }
        if (typeof options.pins === "undefined") {
          options.pins = {};
        }
        Board.Component.call(this, options = Board.Options(options));
        let breakout = options.breakout || {};
        let receiver = options.receiver;
        let chip = options.chip;
        if (Breakouts[breakout]) {
          if (!receiver && Breakouts[breakout].receiver) {
            receiver = Breakouts[breakout].receiver.value;
          }
          if (!chip && Breakouts[breakout].chip) {
            chip = Breakouts[breakout].chip.value;
          }
        }
        if (!chip) {
          if (receiver && Receivers[receiver].chip) {
            chip = Receivers[receiver].chip.value;
          } else {
            chip = "DEFAULT";
          }
        }
        breakout = typeof breakout === "string" ? Chips[breakout] : options.breakout;
        chip = typeof chip === "string" ? Chips[chip] : options.chip;
        receiver = typeof receiver === "string" ? Receivers[receiver] : options.receiver;
        if (chip) {
          Object.defineProperties(this, chip);
        }
        if (receiver) {
          Object.defineProperties(this, receiver);
        }
        if (breakout) {
          Object.defineProperties(this, breakout);
        }
        this.fixed = options.fixed || 6;
        this.baud = options.baud || this.baud;
        let state = {
          sat: {},
          latitude: 0,
          longitude: 0,
          altitude: 0,
          speed: 0,
          course: 0,
          frequency: 1,
          lowPowerMode: false
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          latitude: {
            get() {
              return state.latitude;
            }
          },
          longitude: {
            get() {
              return state.longitude;
            }
          },
          altitude: {
            get() {
              return state.altitude;
            }
          },
          sat: {
            get() {
              return state.sat;
            }
          },
          speed: {
            get() {
              return state.speed;
            }
          },
          course: {
            get() {
              return state.course;
            }
          },
          time: {
            get() {
              return state.time;
            }
          }
        });
        if (this.initialize) {
          this.initialize(options);
        }
      }
      initialize(options) {
        const state = priv.get(this);
        state.portId = options.serialPort || options.portId || options.port || options.bus;
        if (typeof state.portId === "undefined" && this.io.SERIAL_PORT_IDs) {
          state.portId = this.io.SERIAL_PORT_IDs.DEFAULT;
        }
        ["tx", "rx"].forEach((pin) => {
          if (this.pins[pin]) {
            this.io.pinMode(this.pins[pin], this.io.MODES.SERIAL);
          }
        });
        if (this.pins.onOff) {
          this.io.pinMode(this.pins.onOff, this.io.MODES.OUTPUT);
          this.onOff = new Pin(this.pins.onOff);
        }
        this.io.serialConfig({
          portId: state.portId,
          baud: this.baud,
          rxPin: this.pins.rx,
          txPin: this.pins.tx
        });
        if (this.configure) {
          this.configure(() => {
            this.listen();
            if (options.frequency) {
              this.frequency = options.frequency;
            }
          });
        }
      }
      sendCommand(string) {
        const state = priv.get(this);
        const cc = [];
        for (let i = 0; i < string.length; ++i) {
          cc[i] = string.charCodeAt(i);
        }
        const hexsum = getNmeaChecksum(string.substring(1));
        cc.push(42, hexsum.charCodeAt(0), hexsum.charCodeAt(1), 13, 10);
        this.io.serialWrite(state.portId, cc);
      }
      listen() {
        const state = priv.get(this);
        let input = "";
        this.io.serialRead(state.portId, (data) => {
          input += new Buffer(data).toString("ascii");
          const sentences = input.split("\r\n");
          if (sentences.length > 1) {
            for (let i = 0; i < sentences.length - 1; i++) {
              this.parseNmeaSentence(sentences[i]);
            }
            input = sentences[sentences.length - 1];
          }
        });
      }
      parseNmeaSentence(sentence) {
        const state = priv.get(this);
        const cksum = sentence.split("*");
        if (cksum[1] !== getNmeaChecksum(cksum[0].substring(1))) {
          return;
        }
        this.emit("sentence", sentence);
        const segments = cksum[0].split(",");
        const last = {
          latitude: state.latitude,
          longitude: state.longitude,
          altitude: state.altitude,
          speed: state.speed,
          course: state.course
        };
        switch (segments[0]) {
          case "$GPGGA":
            state.time = segments[1];
            state.latitude = degToDec(segments[2], 2, segments[3], this.fixed);
            state.longitude = degToDec(segments[4], 3, segments[5], this.fixed);
            state.altitude = Number(segments[9]);
            break;
          case "$GPGSA":
            state.sat.satellites = segments.slice(3, 15);
            state.sat.pdop = Number(segments[15]);
            state.sat.hdop = Number(segments[16]);
            state.sat.vdop = Number(segments[17]);
            this.emit("operations", sentence);
            break;
          case "$GPRMC":
            state.time = segments[1];
            state.latitude = degToDec(segments[3], 2, segments[4], this.fixed);
            state.longitude = degToDec(segments[5], 3, segments[6], this.fixed);
            state.course = Number(segments[8]);
            state.speed = toFixed(segments[7] * 0.514444, this.fixed);
            break;
          case "$GPVTG":
            state.course = Number(segments[1]);
            state.speed = toFixed(segments[5] * 0.514444, this.fixed);
            break;
          case "$GPGSV":
            break;
          case "$PGACK":
            this.emit("acknowledge", sentence);
            break;
          default:
            this.emit("unknown", sentence);
            break;
        }
        this.emit("data", {
          latitude: state.latitude,
          longitude: state.longitude,
          altitude: state.altitude,
          speed: state.speed,
          course: state.course,
          sat: state.sat,
          time: state.time
        });
        if (last.latitude !== state.latitude || last.longitude !== state.longitude || last.altitude !== state.altitude) {
          this.emit("change", {
            latitude: state.latitude,
            longitude: state.longitude,
            altitude: state.altitude
          });
        }
        if (last.speed !== state.speed || last.course !== state.course) {
          this.emit("navigation", {
            speed: state.speed,
            course: state.course
          });
        }
      }
    };
    function degToDec(degrees, intDigitsLength, cardinal, fixed) {
      if (degrees) {
        let decimal = Number(degrees.substring(0, intDigitsLength)) + Number(degrees.substring(intDigitsLength)) / 60;
        if (cardinal === "S" || cardinal === "W") {
          decimal *= -1;
        }
        return Number(decimal.toFixed(fixed));
      } else {
        return 0;
      }
    }
    function getNmeaChecksum(string) {
      let cksum = 0;
      for (let i = 0; i < string.length; ++i) {
        cksum ^= string.charCodeAt(i);
      }
      cksum = cksum.toString(16).toUpperCase();
      if (cksum.length < 2) {
        cksum = `00${cksum}`.slice(-2);
      }
      return cksum;
    }
    if (!!process.env.IS_TEST_MODE) {
      GPS.Breakouts = Breakouts;
      GPS.Chips = Chips;
      GPS.Receivers = Receivers;
      GPS.purge = () => {
        priv.clear();
      };
    }
    module2.exports = GPS;
  }
});

// node_modules/johnny-five/lib/definitions/mpr121.js
var require_mpr121 = __commonJS({
  "node_modules/johnny-five/lib/definitions/mpr121.js"(exports, module2) {
    module2.exports = {
      MAPS: {
        MPR121QR2_SHIELD: {
          KEYS: {
            0: 1,
            1: 2,
            2: 3,
            3: 4,
            4: 5,
            5: 6,
            6: 7,
            7: 8,
            8: 9
          },
          TARGETS: {
            256: 0,
            32: 1,
            4: 2,
            128: 3,
            16: 4,
            2: 5,
            64: 6,
            8: 7,
            1: 8
          }
        },
        MPR121: {
          KEYS: {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            10: 10,
            11: 11
          },
          TARGETS: {
            1: 0,
            2: 1,
            4: 2,
            8: 3,
            16: 4,
            32: 5,
            64: 6,
            128: 7,
            256: 8,
            512: 9,
            1024: 10,
            2048: 11
          }
        },
        MPR121_KEYPAD: {
          KEYS: {
            0: 1,
            1: 2,
            2: 3,
            3: 4,
            4: 5,
            5: 6,
            6: 7,
            7: 8,
            8: 9,
            9: 10,
            10: 11,
            11: 12
          },
          TARGETS: {
            8: 0,
            128: 1,
            2048: 2,
            4: 3,
            64: 4,
            1024: 5,
            2: 6,
            32: 7,
            512: 8,
            1: 9,
            16: 10,
            256: 11
          }
        },
        MPR121_SHIELD: {
          KEYS: {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            10: 10,
            11: 11
          },
          TARGETS: {
            1: 0,
            2: 1,
            4: 2,
            8: 3,
            16: 4,
            32: 5,
            64: 6,
            128: 7,
            256: 8,
            512: 9,
            1024: 10,
            2048: 11
          }
        }
      },
      MPR121_DEFAULT_ADDRESS: 90,
      MPR121_SOFTRESET: 128,
      ELE0_ELE7_TOUCH_STATUS: 0,
      ELE8_ELE11_ELEPROX_TOUCH_STATUS: 1,
      ELE0_7_OOR_STATUS: 2,
      ELE8_11_ELEPROX_OOR_STATUS: 3,
      ELE0_FILTERED_DATA_LSB: 4,
      ELE0_FILTERED_DATA_MSB: 5,
      ELE1_FILTERED_DATA_LSB: 6,
      ELE1_FILTERED_DATA_MSB: 7,
      ELE2_FILTERED_DATA_LSB: 8,
      ELE2_FILTERED_DATA_MSB: 9,
      ELE3_FILTERED_DATA_LSB: 10,
      ELE3_FILTERED_DATA_MSB: 11,
      ELE4_FILTERED_DATA_LSB: 12,
      ELE4_FILTERED_DATA_MSB: 13,
      ELE5_FILTERED_DATA_LSB: 14,
      ELE5_FILTERED_DATA_MSB: 15,
      ELE6_FILTERED_DATA_LSB: 16,
      ELE6_FILTERED_DATA_MSB: 17,
      ELE7_FILTERED_DATA_LSB: 18,
      ELE7_FILTERED_DATA_MSB: 19,
      ELE8_FILTERED_DATA_LSB: 20,
      ELE8_FILTERED_DATA_MSB: 21,
      ELE9_FILTERED_DATA_LSB: 22,
      ELE9_FILTERED_DATA_MSB: 23,
      ELE10_FILTERED_DATA_LSB: 24,
      ELE10_FILTERED_DATA_MSB: 25,
      ELE11_FILTERED_DATA_LSB: 26,
      ELE11_FILTERED_DATA_MSB: 27,
      ELEPROX_FILTERED_DATA_LSB: 28,
      ELEPROX_FILTERED_DATA_MSB: 29,
      ELE0_BASELINE_VALUE: 30,
      ELE1_BASELINE_VALUE: 31,
      ELE2_BASELINE_VALUE: 32,
      ELE3_BASELINE_VALUE: 33,
      ELE4_BASELINE_VALUE: 34,
      ELE5_BASELINE_VALUE: 35,
      ELE6_BASELINE_VALUE: 36,
      ELE7_BASELINE_VALUE: 37,
      ELE8_BASELINE_VALUE: 38,
      ELE9_BASELINE_VALUE: 39,
      ELE10_BASELINE_VALUE: 40,
      ELE11_BASELINE_VALUE: 41,
      ELEPROX_BASELINE_VALUE: 42,
      MHD_RISING: 43,
      NHD_AMOUNT_RISING: 44,
      NCL_RISING: 45,
      FDL_RISING: 46,
      MHD_FALLING: 47,
      NHD_AMOUNT_FALLING: 48,
      NCL_FALLING: 49,
      FDL_FALLING: 50,
      NHD_AMOUNT_TOUCHED: 51,
      NCL_TOUCHED: 52,
      FDL_TOUCHED: 53,
      ELEPROX_MHD_RISING: 54,
      ELEPROX_NHD_AMOUNT_RISING: 55,
      ELEPROX_NCL_RISING: 56,
      ELEPROX_FDL_RISING: 57,
      ELEPROX_MHD_FALLING: 58,
      ELEPROX_NHD_AMOUNT_FALLING: 59,
      ELEPROX_FDL_FALLING: 60,
      ELEPROX_NHD_AMOUNT_TOUCHED: 62,
      ELEPROX_NCL_TOUCHED: 63,
      ELEPROX_FDL_TOUCHED: 64,
      ELE0_TOUCH_THRESHOLD: 65,
      ELE0_RELEASE_THRESHOLD: 66,
      ELE1_TOUCH_THRESHOLD: 67,
      ELE1_RELEASE_THRESHOLD: 68,
      ELE2_TOUCH_THRESHOLD: 69,
      ELE2_RELEASE_THRESHOLD: 70,
      ELE3_TOUCH_THRESHOLD: 71,
      ELE3_RELEASE_THRESHOLD: 72,
      ELE4_TOUCH_THRESHOLD: 73,
      ELE4_RELEASE_THRESHOLD: 74,
      ELE5_TOUCH_THRESHOLD: 75,
      ELE5_RELEASE_THRESHOLD: 76,
      ELE6_TOUCH_THRESHOLD: 77,
      ELE6_RELEASE_THRESHOLD: 78,
      ELE7_TOUCH_THRESHOLD: 79,
      ELE7_RELEASE_THRESHOLD: 80,
      ELE8_TOUCH_THRESHOLD: 81,
      ELE8_RELEASE_THRESHOLD: 82,
      ELE9_TOUCH_THRESHOLD: 83,
      ELE9_RELEASE_THRESHOLD: 84,
      ELE10_TOUCH_THRESHOLD: 85,
      ELE10_RELEASE_THRESHOLD: 86,
      ELE11_TOUCH_THRESHOLD: 87,
      ELE11_RELEASE_THRESHOLD: 88,
      ELEPROX_TOUCH_THRESHOLD: 89,
      ELEPROX_RELEASE_THRESHOLD: 90,
      DEBOUNCE_TOUCH_AND_RELEASE: 91,
      AFE_CONFIGURATION: 92,
      FILTER_CONFIG: 93,
      ELECTRODE_CONFIG: 94,
      ELE0_CURRENT: 95,
      ELE1_CURRENT: 96,
      ELE2_CURRENT: 97,
      ELE3_CURRENT: 98,
      ELE4_CURRENT: 99,
      ELE5_CURRENT: 100,
      ELE6_CURRENT: 101,
      ELE7_CURRENT: 102,
      ELE8_CURRENT: 103,
      ELE9_CURRENT: 104,
      ELE10_CURRENT: 105,
      ELE11_CURRENT: 106,
      ELEPROX_CURRENT: 107,
      ELE0_ELE1_CHARGE_TIME: 108,
      ELE2_ELE3_CHARGE_TIME: 109,
      ELE4_ELE5_CHARGE_TIME: 110,
      ELE6_ELE7_CHARGE_TIME: 111,
      ELE8_ELE9_CHARGE_TIME: 112,
      ELE10_ELE11_CHARGE_TIME: 113,
      ELEPROX_CHARGE_TIME: 114,
      GPIO_CONTROL_0: 115,
      GPIO_CONTROL_1: 116,
      GPIO_DATA: 117,
      GPIO_DIRECTION: 118,
      GPIO_ENABLE: 119,
      GPIO_SET: 120,
      GPIO_CLEAR: 121,
      GPIO_TOGGLE: 122,
      AUTO_CONFIG_CONTROL_0: 123,
      AUTO_CONFIG_CONTROL_1: 124,
      AUTO_CONFIG_USL: 125,
      AUTO_CONFIG_LSL: 126,
      AUTO_CONFIG_TARGET_LEVEL: 127,
      TOUCH_THRESHOLD: 15,
      RELEASE_THRESHOLD: 10,
      NUM_CHANNELS: 12
    };
  }
});

// node_modules/johnny-five/lib/keypad.js
var require_keypad = __commonJS({
  "node_modules/johnny-five/lib/keypad.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var { scale, toFixed, uint16 } = Fn;
    var priv = new Map();
    var aliases = {
      down: ["down", "press", "tap", "impact", "hit", "touch"],
      up: ["up", "release"],
      hold: ["hold"]
    };
    function flatten(array) {
      return array.flat ? array.flat() : array.reduce((accum, val) => accum.concat(val), []);
    }
    function flatKeys(options) {
      let keys = [];
      if (options.keys && Array.isArray(options.keys)) {
        keys = options.keys.slice();
        if (keys.every(Array.isArray)) {
          keys = flatten(keys);
        }
      }
      return keys;
    }
    var Controllers = {
      MPR121: {
        ADDRESSES: {
          value: [90, 91, 92, 93]
        },
        REGISTER: {
          value: require_mpr121()
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            const keyMap = this.REGISTER.MAPS[options.controller].KEYS;
            const targets = this.REGISTER.MAPS[options.controller].TARGETS;
            const mapping = Object.keys(keyMap).reduce((accum, index) => {
              accum[index] = keyMap[index];
              return accum;
            }, []);
            let keys = flatKeys(options);
            const length = mapping.length;
            this.io.i2cConfig(options);
            this.io.i2cWrite(address, this.REGISTER.MPR121_SOFTRESET, 99);
            this.io.i2cWrite(address, this.REGISTER.MHD_RISING, 1);
            this.io.i2cWrite(address, this.REGISTER.NHD_AMOUNT_RISING, 1);
            this.io.i2cWrite(address, this.REGISTER.NCL_RISING, 0);
            this.io.i2cWrite(address, this.REGISTER.FDL_RISING, 0);
            this.io.i2cWrite(address, this.REGISTER.MHD_FALLING, 1);
            this.io.i2cWrite(address, this.REGISTER.NHD_AMOUNT_FALLING, 1);
            this.io.i2cWrite(address, this.REGISTER.NCL_FALLING, 255);
            this.io.i2cWrite(address, this.REGISTER.FDL_FALLING, 2);
            this.sensitivity = {
              press: Array(12).fill(0.95),
              release: Array(12).fill(0.975)
            };
            if (options.keys && options.controller === "MPR121_SHIELD") {
              keys = keys.reverse();
            }
            if (options.sensitivity) {
              if (Array.isArray(options.sensitivity)) {
                options.sensitivity.forEach(function({ press, release }, index) {
                  if (typeof press !== "undefined") {
                    this.sensitivity.press[index] = press;
                  }
                  if (typeof release !== "undefined") {
                    this.sensitivity.release[index] = release;
                  }
                }, this);
              } else {
                if (typeof options.sensitivity.press !== "undefined") {
                  this.sensitivity.press.fill(options.sensitivity.press);
                }
                if (typeof options.sensitivity.release !== "undefined") {
                  this.sensitivity.release.fill(options.sensitivity.release);
                }
              }
            }
            for (let i = 0; i < 12; i++) {
              this.io.i2cWrite(address, this.REGISTER.ELE0_TOUCH_THRESHOLD + (i << 1), scale(toFixed(1 - this.sensitivity.press[i], 3), 0, 1, 0, 255));
              this.io.i2cWrite(address, this.REGISTER.ELE0_RELEASE_THRESHOLD + (i << 1), scale(toFixed(1 - this.sensitivity.release[i], 3), 0, 1, 0, 255));
            }
            this.io.i2cWrite(address, this.REGISTER.FILTER_CONFIG, 19);
            this.io.i2cWrite(address, this.REGISTER.AFE_CONFIGURATION, 128);
            this.io.i2cWrite(address, this.REGISTER.AUTO_CONFIG_CONTROL_0, 143);
            this.io.i2cWrite(address, this.REGISTER.AUTO_CONFIG_USL, 228);
            this.io.i2cWrite(address, this.REGISTER.AUTO_CONFIG_LSL, 148);
            this.io.i2cWrite(address, this.REGISTER.AUTO_CONFIG_TARGET_LEVEL, 205);
            this.io.i2cWrite(address, this.REGISTER.ELECTRODE_CONFIG, 204);
            if (!keys.length) {
              keys = Array.from(Object.assign({}, keyMap, {
                length
              }));
            }
            state.length = length;
            state.touches = touches(length);
            state.keys = keys;
            state.mapping = mapping;
            state.targets = targets;
            state.isMultitouch = true;
            this.io.i2cRead(address, 0, 2, (bytes) => callback(uint16(bytes[1], bytes[0])));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const indices = [];
            for (let i = 0; i < 12; i++) {
              if (raw & 1 << i) {
                indices.push(state.targets[raw & 1 << i]);
              }
            }
            return indices;
          }
        }
      },
      VKEY: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            const aref = options.aref || this.io.aref || 5;
            const use5V = Fn.inRange(aref, 4.5, 5.5);
            const mapping = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
            let keys = flatKeys(options);
            let length = 0;
            if (!keys.length) {
              keys = mapping;
            }
            state.scale = [
              use5V ? 17 : 26,
              use5V ? 40 : 58,
              use5V ? 496 : 721
            ];
            length = mapping.length;
            state.length = length;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = false;
            this.io.pinMode(this.pin, this.io.MODES.ANALOG);
            this.io.analogRead(this.pin, (adc) => callback(adc));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const length = state.length;
            const low = state.scale[0];
            const step = state.scale[1];
            const high = state.scale[2];
            if (raw < low || raw > high) {
              return [];
            }
            return [length - (raw - low) / step | 0];
          }
        }
      },
      ANALOG: {
        initialize: {
          value(options, callback) {
            let keys = flatKeys(options);
            let mapping = [];
            let length = 0;
            if (options.length && !keys.length) {
              keys = Array.from({
                length: options.length
              }, (_, key) => key);
            }
            if (!keys.length) {
              throw new Error("Missing `keys`. Analog Keypad requires either a numeric `length` or a `keys` array.");
            }
            mapping = keys;
            length = mapping.length;
            const state = priv.get(this);
            const total = length + 1;
            const vrange = Math.round(1023 / total);
            const ranges = Array.from({
              length: total
            }, (_, index) => {
              const start = vrange * index;
              return Array.from({
                length: vrange - 1
              }, (_2, index2) => start + index2);
            });
            state.length = length;
            state.ranges = ranges;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = true;
            this.io.pinMode(this.pin, this.io.MODES.ANALOG);
            this.io.analogRead(this.pin, (adc) => callback(adc));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const ranges = state.ranges;
            let index = ranges.findIndex((range) => range.includes(raw));
            if (index === state.length) {
              index--;
            }
            if (index < 0) {
              return [];
            }
            return [index];
          }
        }
      },
      AT42QT1070: {
        ADDRESSES: {
          value: [27]
        },
        REGISTER: {
          value: {
            READ: 3
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            const mapping = [0, 1, 2, 3, 4, 5, 6];
            let keys = flatKeys(options);
            let length = 0;
            if (!keys.length) {
              keys = mapping;
            }
            length = mapping.length;
            state.length = length;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = true;
            this.io.i2cConfig(options);
            this.io.i2cRead(address, this.REGISTER.READ, 1, (data) => callback(data[0]));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const indices = [];
            for (let i = 0; i < 7; i++) {
              if (raw & 1 << i) {
                indices.push(i);
              }
            }
            return indices;
          }
        }
      },
      "3X4_I2C_NANO_BACKPACK": {
        ADDRESSES: {
          value: [10, 11, 12, 13]
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            const mapping = [1, 2, 3, 4, 5, 6, 7, 8, 9, "*", 0, "#"];
            let keys = flatKeys(options);
            let length = 0;
            if (!keys.length) {
              keys = mapping;
            }
            length = mapping.length;
            state.length = length;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = true;
            this.io.i2cConfig(options);
            this.io.i2cRead(address, 2, (bytes) => callback(uint16(bytes[0], bytes[1])));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const indices = [];
            for (let i = 0; i < state.length; i++) {
              if (raw & 1 << i) {
                indices.push(i);
              }
            }
            return indices;
          }
        }
      },
      "4X4_I2C_NANO_BACKPACK": {
        ADDRESSES: {
          value: [10, 11, 12, 13]
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            let keys = flatKeys(options);
            const mapping = [1, 2, 3, "A", 4, 5, 6, "B", 7, 8, 9, "C", "*", 0, "#", "D"];
            let length = 0;
            if (!keys.length) {
              keys = mapping;
            }
            length = mapping.length;
            state.length = length;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = true;
            this.io.i2cConfig(options);
            this.io.i2cRead(address, 2, (bytes) => callback(uint16(bytes[0], bytes[1])));
          }
        },
        toAlias: {
          value(index) {
            return priv.get(this).keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const indices = [];
            for (let i = 0; i < state.length; i++) {
              if (raw & 1 << i) {
                indices.push(i);
              }
            }
            return indices;
          }
        }
      },
      SX1509: {
        ADDRESSES: {
          value: [10, 11, 12, 13]
        },
        REGISTER: {
          value: {
            PULLUP: 3,
            OPEN_DRAIN: 5,
            DIR: 7,
            DIR_B: 14,
            DIR_A: 15
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            let keys = flatKeys(options);
            const mapping = [1, 2, 3, 4, 5, 6, 7, 8, 9, "*", 0, "#"];
            let length = 0;
            if (!keys.length) {
              keys = mapping;
            }
            length = mapping.length;
            state.length = length;
            state.touches = touches(length);
            state.mapping = mapping;
            state.keys = keys;
            state.isMultitouch = true;
            this.io.i2cConfig(options);
            this.io.i2cWriteReg(address, this.REGISTER.DIR, 240);
            this.io.i2cWriteReg(address, this.REGISTER.OPEN_DRAIN, 15);
            this.io.i2cWriteReg(address, this.REGISTER.PULLUP, 240);
            this.io.i2cRead(address, 2, (bytes) => callback(uint16(bytes[0], bytes[1])));
          }
        },
        toAlias: {
          value(index) {
            const state = priv.get(this);
            return state.keys[index];
          }
        },
        toIndices: {
          value(raw) {
            const state = priv.get(this);
            const indices = [];
            for (let i = 0; i < state.length; i++) {
              if (raw & 1 << i) {
                indices.push(i);
              }
            }
            return indices;
          }
        }
      }
    };
    Controllers.MPR121QR2 = Controllers.MPR121;
    Controllers.MPR121QR2_SHIELD = Controllers.MPR121;
    Controllers.MPR121_KEYPAD = Controllers.MPR121;
    Controllers.MPR121_SHIELD = Controllers.MPR121;
    Controllers.QTOUCH = Controllers.AT42QT1070;
    Controllers.DEFAULT = Controllers.ANALOG;
    function touches(length) {
      return Array.from({ length }, () => ({
        timeout: null,
        value: 0
      }));
    }
    var Keypad = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        let raw = null;
        const state = {
          touches: null,
          timeout: null,
          length: null,
          keys: null,
          mapping: null,
          holdtime: null
        };
        const trigger = Fn.debounce(function(type, value) {
          const event = {
            type,
            which: value,
            timestamp: Date.now()
          };
          aliases[type].forEach(function(type2) {
            this.emit(type2, event);
          }, this);
          this.emit("change", Object.assign({}, event));
        }, 5);
        Board.Controller.call(this, Controllers, options);
        state.holdtime = options.holdtime ? options.holdtime : 500;
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            raw = data;
            const now = Date.now();
            const indices = this.toIndices(data);
            const kLength = state.length;
            const lists = {
              down: [],
              hold: [],
              up: []
            };
            let target = null;
            let alias = null;
            for (let k = 0; k < kLength; k++) {
              alias = this.toAlias(k);
              if (indices.includes(k)) {
                if (state.touches[k].value === 0) {
                  state.touches[k].timeout = now + state.holdtime;
                  lists.down.push(alias);
                } else if (state.touches[k].value === 1) {
                  if (state.touches[k].timeout !== null && now > state.touches[k].timeout) {
                    state.touches[k].timeout = now + state.holdtime;
                    lists.hold.push(alias);
                  }
                }
                state.touches[k].value = 1;
              } else {
                if (state.touches[k].value === 1) {
                  state.touches[k].timeout = null;
                  lists.up.push(alias);
                }
                state.touches[k].value = 0;
              }
              target = null;
              alias = null;
            }
            Object.keys(lists).forEach(function(key) {
              const list = lists[key];
              if (list.length) {
                trigger.call(this, key, list);
              }
            }, this);
          });
        }
        Object.defineProperties(this, {
          isMultitouch: {
            get() {
              return state.isMultitouch;
            }
          },
          value: {
            get() {
              return raw;
            }
          }
        });
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Keypad.Controllers = Controllers;
      Keypad.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Keypad;
  }
});

// node_modules/johnny-five/lib/lcd-chars.js
var require_lcd_chars = __commonJS({
  "node_modules/johnny-five/lib/lcd-chars.js"(exports, module2) {
    module2.exports = {
      DEFAULT: {
        0: [14, 27, 27, 27, 27, 27, 14, 0],
        1: [2, 6, 14, 6, 6, 6, 6, 0],
        2: [14, 27, 3, 6, 12, 24, 31, 0],
        3: [14, 27, 3, 14, 3, 27, 14, 0],
        4: [3, 7, 15, 27, 31, 3, 3, 0],
        5: [31, 24, 30, 3, 3, 27, 14, 0],
        6: [14, 27, 24, 30, 27, 27, 14, 0],
        7: [31, 3, 6, 12, 12, 12, 12, 0],
        8: [14, 27, 27, 14, 27, 27, 14, 0],
        9: [14, 27, 27, 15, 3, 27, 14, 0],
        10: [23, 21, 21, 21, 23, 0, 31, 0],
        11: [10, 10, 10, 10, 10, 0, 31, 0],
        12: [23, 17, 23, 20, 23, 0, 31, 0],
        13: [23, 17, 19, 17, 23, 0, 31, 0],
        14: [21, 21, 23, 17, 17, 0, 31, 0],
        15: [23, 20, 23, 17, 23, 0, 31, 0],
        16: [23, 20, 23, 21, 23, 0, 31, 0],
        17: [23, 17, 18, 18, 18, 0, 31, 0],
        18: [23, 21, 23, 21, 23, 0, 31, 0],
        19: [23, 21, 23, 17, 23, 0, 31, 0],
        circle: [0, 14, 17, 17, 17, 14, 0, 0],
        cdot: [0, 14, 17, 21, 17, 14, 0, 0],
        donut: [0, 14, 31, 27, 31, 14, 0, 0],
        ball: [0, 14, 31, 31, 31, 14, 0, 0],
        square: [0, 31, 17, 17, 17, 31, 0, 0],
        sdot: [0, 31, 17, 21, 17, 31, 0, 0],
        fbox: [0, 31, 31, 31, 31, 31, 0, 0],
        sbox: [0, 0, 14, 10, 14, 0, 0, 0],
        sfbox: [0, 0, 14, 14, 14, 0, 0, 0],
        bigpointerright: [8, 12, 10, 9, 10, 12, 8, 0],
        bigpointerleft: [2, 6, 10, 18, 10, 6, 2, 0],
        arrowright: [8, 12, 10, 9, 10, 12, 8, 0],
        arrowleft: [2, 6, 10, 18, 10, 6, 2, 0],
        ascprogress1: [16, 16, 16, 16, 16, 16, 16, 16],
        ascprogress2: [24, 24, 24, 24, 24, 24, 24, 24],
        ascprogress3: [28, 28, 28, 28, 28, 28, 28, 28],
        ascprogress4: [30, 30, 30, 30, 30, 30, 30, 30],
        fullprogress: [31, 31, 31, 31, 31, 31, 31, 31],
        descprogress1: [1, 1, 1, 1, 1, 1, 1, 1],
        descprogress2: [3, 3, 3, 3, 3, 3, 3, 3],
        descprogress3: [7, 7, 7, 7, 7, 7, 7, 7],
        descprogress4: [15, 15, 15, 15, 15, 15, 15, 15],
        ascchart1: [31, 0, 0, 0, 0, 0, 0, 0],
        ascchart2: [31, 31, 0, 0, 0, 0, 0, 0],
        ascchart3: [31, 31, 31, 0, 0, 0, 0, 0],
        ascchart4: [31, 31, 31, 31, 0, 0, 0, 0],
        ascchart5: [31, 31, 31, 31, 31, 0, 0, 0],
        ascchart6: [31, 31, 31, 31, 31, 31, 0, 0],
        ascchart7: [31, 31, 31, 31, 31, 31, 31, 0],
        descchart1: [0, 0, 0, 0, 0, 0, 0, 31],
        descchart2: [0, 0, 0, 0, 0, 0, 31, 31],
        descchart3: [0, 0, 0, 0, 0, 31, 31, 31],
        descchart4: [0, 0, 0, 0, 31, 31, 31, 31],
        descchart5: [0, 0, 0, 31, 31, 31, 31, 31],
        descchart6: [0, 0, 31, 31, 31, 31, 31, 31],
        descchart7: [0, 31, 31, 31, 31, 31, 31, 31],
        borderleft1: [1, 1, 1, 1, 1, 1, 1, 1],
        borderleft2: [3, 2, 2, 2, 2, 2, 2, 3],
        borderleft3: [7, 4, 4, 4, 4, 4, 4, 7],
        borderleft4: [15, 8, 8, 8, 8, 8, 8, 15],
        borderleft5: [31, 16, 16, 16, 16, 16, 16, 31],
        bordertopbottom5: [31, 0, 0, 0, 0, 0, 0, 31],
        borderright1: [16, 16, 16, 16, 16, 16, 16, 16],
        borderright2: [24, 8, 8, 8, 8, 8, 8, 24],
        borderright3: [28, 4, 4, 4, 4, 4, 4, 28],
        borderright4: [30, 2, 2, 2, 2, 2, 2, 30],
        borderright5: [31, 1, 1, 1, 1, 1, 1, 31],
        box1: [3, 3, 3, 0, 0, 0, 0, 0],
        box2: [24, 24, 24, 0, 0, 0, 0, 0],
        box3: [27, 27, 27, 0, 0, 0, 0, 0],
        box4: [0, 0, 0, 0, 3, 3, 3, 0],
        box5: [3, 3, 3, 0, 3, 3, 3, 0],
        box6: [24, 24, 24, 0, 3, 3, 3, 0],
        box7: [27, 27, 27, 0, 3, 3, 3, 0],
        box8: [0, 0, 0, 0, 24, 24, 24, 0],
        box9: [3, 3, 3, 0, 24, 24, 24, 0],
        box10: [24, 24, 24, 0, 24, 24, 24, 0],
        box11: [27, 27, 27, 0, 24, 24, 24, 0],
        box12: [0, 0, 0, 0, 27, 27, 27, 0],
        box13: [3, 3, 3, 0, 27, 27, 27, 0],
        box14: [24, 24, 24, 0, 27, 27, 27, 0],
        box15: [27, 27, 27, 0, 27, 27, 27, 0],
        euro: [3, 4, 30, 8, 30, 8, 7, 0],
        cent: [0, 0, 14, 17, 16, 21, 14, 8],
        speaker: [1, 3, 15, 15, 15, 3, 1, 0],
        sound: [8, 16, 0, 24, 0, 16, 8, 0],
        x: [0, 27, 14, 4, 14, 27, 0, 0],
        target: [0, 10, 17, 21, 17, 10, 0, 0],
        pointerright: [0, 8, 12, 14, 12, 8, 0, 0],
        pointerup: [0, 0, 4, 14, 31, 0, 0, 0],
        pointerleft: [0, 2, 6, 14, 6, 2, 0, 0],
        pointerdown: [0, 0, 31, 14, 4, 0, 0, 0],
        arrowne: [0, 15, 3, 5, 9, 16, 0, 0],
        arrownw: [0, 30, 24, 20, 18, 1, 0, 0],
        arrowsw: [0, 1, 18, 20, 24, 30, 0, 0],
        arrowse: [0, 16, 9, 5, 3, 15, 0, 0],
        dice1: [0, 0, 0, 4, 0, 0, 0, 0],
        dice2: [0, 16, 0, 0, 0, 1, 0, 0],
        dice3: [0, 16, 0, 4, 0, 1, 0, 0],
        dice4: [0, 17, 0, 0, 0, 17, 0, 0],
        dice5: [0, 17, 0, 4, 0, 17, 0, 0],
        dice6: [0, 17, 0, 17, 0, 17, 0, 0],
        bell: [4, 14, 14, 14, 31, 0, 4, 0],
        smile: [0, 10, 0, 17, 14, 0, 0, 0],
        note: [2, 3, 2, 14, 30, 12, 0, 0],
        clock: [0, 14, 21, 23, 17, 14, 0, 0],
        heart: [0, 10, 31, 31, 31, 14, 4, 0],
        duck: [0, 12, 29, 15, 15, 6, 0, 0],
        check: [0, 1, 3, 22, 28, 8, 0, 0],
        retarrow: [1, 1, 5, 9, 31, 8, 4, 0],
        runninga: [6, 6, 5, 14, 20, 4, 10, 17],
        runningb: [6, 6, 4, 14, 14, 4, 10, 10]
      }
    };
  }
});

// node_modules/color-convert/css-keywords.js
var require_css_keywords = __commonJS({
  "node_modules/color-convert/css-keywords.js"(exports, module2) {
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_css_keywords();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key].join()] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3 },
      hsl: { channels: 3 },
      hsv: { channels: 3 },
      hwb: { channels: 3 },
      cmyk: { channels: 4 },
      xyz: { channels: 3 },
      lab: { channels: 3 },
      lch: { channels: 3 },
      hex: { channels: 1 },
      keyword: { channels: 1 },
      ansi16: { channels: 1 },
      ansi256: { channels: 1 },
      hcg: { channels: 3 }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        channels = convert[model].channels;
        delete convert[model].channels;
        Object.defineProperty(convert[model], "channels", { value: channels });
      }
    }
    var channels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var v;
      if (max === 0) {
        s = 0;
      } else {
        s = delta / max * 1e3 / 10;
      }
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      v = max / 255 * 1e3 / 10;
      return [h, s, v];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    convert.rgb.keyword = function(rgb) {
      return reverseKeywords[rgb.join()];
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var sv;
      var v;
      if (l === 0) {
        return [0, 0, 0];
      }
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var sl;
      var l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r *= 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g *= 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b *= 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      var y2;
      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }
      x = x / 95.047 <= 8856e-6 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 8859e-6 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var integer = parseInt(match[0], 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions2();
    var models = Object.keys(conversions);
    function buildGraph() {
      var graph = {};
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models2 = Object.keys(graph);
      for (var len = models2.length, i = 0; i < len; i++) {
        var toModel = models2[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/johnny-five/lib/led/rgb.js
var require_rgb = __commonJS({
  "node_modules/johnny-five/lib/led/rgb.js"(exports, module2) {
    var Board = require_board();
    var Animation = require_animation();
    var Expander = require_expander();
    var converter = require_color_convert2();
    var { constrain, map } = require_fn();
    var priv = new Map();
    var Controllers = {
      DEFAULT: {
        initialize: {
          value({ pins, debug }) {
            RGB.colors.forEach((color, index) => {
              const pin = pins[index];
              if (debug && !this.board.pins.isPwm(pin)) {
                Board.Pins.Error({
                  pin,
                  type: "PWM",
                  via: "Led.RGB"
                });
              }
              this.io.pinMode(pin, this.io.MODES.PWM);
              this.pins[index] = pin;
            });
          }
        },
        write: {
          writable: true,
          value(colors) {
            const state = priv.get(this);
            RGB.colors.forEach((color, index) => {
              const pin = this.pins[index];
              let value = colors[color];
              if (state.isAnode) {
                value = 255 - constrain(value, 0, 255);
              }
              value = map(value, 0, 255, 0, this.board.RESOLUTION.PWM);
              this.io.analogWrite(pin, value);
            });
          }
        }
      },
      PCA9685: {
        initialize: {
          value({ address, pwmRange, frequency, pins }) {
            const state = priv.get(this);
            this.address = address || 64;
            this.pwmRange = pwmRange || [0, 4095];
            this.frequency = frequency || 200;
            state.expander = Expander.get({
              address: this.address,
              controller: this.controller,
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            RGB.colors.forEach((color, index) => {
              this.pins[index] = state.expander.normalize(pins[index]);
              state.expander.analogWrite(this.pins[index], 0);
            });
          }
        },
        write: {
          writable: true,
          value(colors) {
            const state = priv.get(this);
            RGB.colors.forEach((color, index) => {
              const pin = this.pins[index];
              let value = colors[color];
              if (state.isAnode) {
                value = 255 - constrain(value, 0, 255);
              }
              state.expander.analogWrite(pin, value);
            });
          }
        }
      },
      BLINKM: {
        REGISTER: {
          value: {
            GO_TO_RGB_COLOR_NOW: 110,
            STOP_SCRIPT: 111
          }
        },
        initialize: {
          value(options) {
            this.address = options.address || 9;
            options.address = this.address;
            if (!this.board.Drivers[this.address]) {
              this.io.i2cConfig(options);
              this.board.Drivers[this.address] = {
                initialized: false
              };
              this.io.i2cWrite(this.address, [this.REGISTER.STOP_SCRIPT]);
              this.board.Drivers[this.address].initialized = true;
            }
          }
        },
        write: {
          writable: true,
          value({ red, green, blue }) {
            this.io.i2cWrite(this.address, [this.REGISTER.GO_TO_RGB_COLOR_NOW, red, green, blue]);
          }
        }
      }
    };
    Controllers.ESPLORA = {
      initialize: {
        value(options) {
          options.pins = [5, 10, 9];
          this.pins = [];
          Controllers.DEFAULT.initialize.value.call(this, options);
        }
      },
      write: Controllers.DEFAULT.write
    };
    var RGB = class {
      constructor(options) {
        if (Array.isArray(options)) {
          options = {
            pins: options
          };
        } else if (typeof options.pins === "object" && !Array.isArray(options.pins)) {
          options.pins = [options.pins.red, options.pins.green, options.pins.blue];
        }
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {
          red: 255,
          green: 255,
          blue: 255,
          intensity: 100,
          isAnode: options.isAnode || false,
          interval: null,
          values: {
            red: 255,
            green: 255,
            blue: 255
          }
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          isOn: {
            get() {
              return RGB.colors.some((color) => state[color] > 0);
            }
          },
          isRunning: {
            get() {
              return !!state.interval;
            }
          },
          isAnode: {
            get() {
              return state.isAnode;
            }
          },
          values: {
            get() {
              return Object.assign({}, state.values);
            }
          },
          update: {
            value(colors) {
              const state2 = priv.get(this);
              colors = colors || this.color();
              state2.values = RGB.ToScaledRGB(state2.intensity, colors);
              this.write(state2.values);
              Object.assign(state2, colors);
            }
          }
        });
        this.initialize(options);
        this.off();
      }
      color(red, green, blue) {
        const state = priv.get(this);
        let colors;
        if (arguments.length === 0) {
          colors = this.isOn ? state : state.prev;
          return RGB.colors.reduce((current, color) => (current[color] = Math.round(colors[color]), current), {});
        }
        const update = RGB.ToRGB(red, green, blue);
        RGB.colors.forEach((color) => {
          let value = update[color];
          if (value == null) {
            throw new Error(`Led.RGB.color: invalid color ([${[update.red, update.green, update.blue].join(",")}])`);
          }
          value = constrain(value, 0, 255);
          update[color] = value;
        });
        this.update(update);
        return this;
      }
      on() {
        const state = priv.get(this);
        let colors;
        if (!this.isOn) {
          colors = state.prev || {
            red: 255,
            green: 255,
            blue: 255
          };
          state.prev = null;
          this.update(colors);
        }
        return this;
      }
      off() {
        const state = priv.get(this);
        if (this.isOn) {
          state.prev = RGB.colors.reduce((current, color) => (current[color] = state[color], current), {});
          this.update({
            red: 0,
            green: 0,
            blue: 0
          });
        }
        return this;
      }
      blink(duration, callback) {
        const state = priv.get(this);
        this.stop();
        if (typeof duration === "function") {
          callback = duration;
          duration = null;
        }
        state.interval = setInterval(() => {
          this.toggle();
          if (typeof callback === "function") {
            callback();
          }
        }, duration || 100);
        return this;
      }
      toggle() {
        return this[this.isOn ? "off" : "on"]();
      }
      stop() {
        const state = priv.get(this);
        if (state.interval) {
          clearInterval(state.interval);
        }
        if (state.animation) {
          state.animation.stop();
        }
        state.interval = null;
        return this;
      }
      intensity(intensity) {
        const state = priv.get(this);
        if (arguments.length === 0) {
          return state.intensity;
        }
        state.intensity = constrain(intensity, 0, 100);
        this.update();
        return this;
      }
      [Animation.normalize](keyFrames) {
        const state = priv.get(this);
        if (keyFrames[0] === null) {
          keyFrames[0] = state.values;
        }
        return keyFrames.reduce((accum, frame) => {
          const value = frame;
          let normalized = {};
          let color = null;
          let intensity = state.intensity;
          if (frame !== null) {
            if (typeof value === "number") {
              throw new Error("RGB LEDs expect a complete keyFrame object or hexadecimal string value");
            }
            if (typeof value === "string") {
              color = value;
            }
            if (Array.isArray(value)) {
              color = value;
            } else {
              if (typeof value === "object") {
                if (typeof value.color !== "undefined") {
                  color = value.color;
                } else {
                  color = value;
                }
              }
            }
            if (typeof frame.intensity === "number") {
              intensity = frame.intensity;
              delete frame.intensity;
            }
            normalized.easing = frame.easing || "linear";
            normalized.value = RGB.ToScaledRGB(intensity, RGB.ToRGB(color));
          } else {
            normalized = frame;
          }
          accum.push(normalized);
          return accum;
        }, []);
      }
      [Animation.render](frames) {
        return this.color(frames[0]);
      }
    };
    RGB.prototype[Animation.keys] = RGB.colors;
    RGB.colors = ["red", "green", "blue"];
    RGB.ToScaledRGB = (intensity, colors) => {
      const scale = intensity / 100;
      return RGB.colors.reduce((current, color) => (current[color] = Math.round(colors[color] * scale), current), {});
    };
    RGB.ToRGB = (red, green, blue) => {
      let update = {};
      let flags = 0;
      let input;
      if (typeof red !== "undefined") {
        flags |= 1 << 2;
      }
      if (typeof green !== "undefined") {
        flags |= 1 << 1;
      }
      if (typeof blue !== "undefined") {
        flags |= 1 << 0;
      }
      if ((flags | 4) === 4) {
        input = red;
        if (input == null) {
          throw new Error(`Invalid color (${input})`);
        }
        if (Array.isArray(input)) {
          update = {
            red: input[0],
            green: input[1],
            blue: input[2]
          };
        } else if (typeof input === "object") {
          update = {
            red: input.red,
            green: input.green,
            blue: input.blue
          };
        } else if (typeof input === "string") {
          if (/^#?[0-9A-Fa-f]{6}$/.test(input)) {
            if (input.length === 7 && input[0] === "#") {
              input = input.slice(1);
            }
            update = {
              red: parseInt(input.slice(0, 2), 16),
              green: parseInt(input.slice(2, 4), 16),
              blue: parseInt(input.slice(4, 6), 16)
            };
          } else {
            if (/^rgb/.test(input)) {
              const args = input.match(/^rgba?\(([^)]+)\)$/)[1].split(/[\s,]+/);
              if (isPercentString(args[0])) {
                args.forEach((value, index) => {
                  if (index <= 2) {
                    args[index] = Math.round(parseInt(value, 10) / 100 * 255);
                  }
                });
              }
              update = {
                red: parseInt(args[0], 10),
                green: parseInt(args[1], 10),
                blue: parseInt(args[2], 10)
              };
              if (args.length > 3) {
                if (isPercentString(args[3])) {
                  args[3] = parseInt(args[3], 10) / 100;
                }
                update = RGB.ToScaledRGB(100 * parseFloat(args[3]), update);
              }
            } else {
              return RGB.ToRGB(converter.keyword.rgb(input.toLowerCase()));
            }
          }
        }
      } else {
        update = {
          red,
          green,
          blue
        };
      }
      return update;
    };
    function isPercentString(input) {
      return typeof input === "string" && input.endsWith("%");
    }
    RGB.prototype.strobe = RGB.prototype.blink;
    if (!!process.env.IS_TEST_MODE) {
      RGB.Controllers = Controllers;
      RGB.purge = () => {
        priv.clear();
      };
    }
    module2.exports = RGB;
  }
});

// node_modules/johnny-five/lib/lcd.js
var require_lcd = __commonJS({
  "node_modules/johnny-five/lib/lcd.js"(exports, module2) {
    var Board = require_board();
    var Pin = require_pin();
    var lcdCharacters = require_lcd_chars();
    var RGB = require_rgb();
    var priv = new Map();
    function sleepus(usDelay) {
      const startTime = process.hrtime();
      let deltaTime;
      let usWaited = 0;
      while (usDelay > usWaited) {
        deltaTime = process.hrtime(startTime);
        usWaited = (deltaTime[0] * 1e9 + deltaTime[1]) / 1e3;
      }
    }
    function sleep(ms) {
      sleepus(ms * 1e3);
    }
    var Expander = class {
      constructor(address, io2) {
        this.address = address;
        this.mask = 255;
        this.memory = 0;
        this.io = io2;
      }
      pinMode(pin, dir) {
        if (dir === 1) {
          this.mask &= ~(1 << pin);
        } else {
          this.mask |= 1 << pin;
        }
      }
      portMode(dir) {
        this.mask = dir === 0 ? 255 : 0;
      }
      portWrite(value) {
        this.memory = value & ~this.mask;
        this.io.i2cWrite(this.address, this.memory);
      }
    };
    var REGISTER = {
      DEFAULT: {
        SHIFT_LEFT: 4,
        CLEAR: 1,
        HOME: 2,
        ENTRY: 4,
        DISPLAY: 8,
        DIMENSIONS: 32,
        CURSORSHIFT: 16,
        SETCGRAMADDR: 64,
        SETDDRAMADDR: 128,
        DATA: 64,
        COMMAND: 128,
        ENTRYRIGHT: 0,
        ENTRYLEFT: 2,
        ENTRYSHIFTINCREMENT: 1,
        ENTRYSHIFTDECREMENT: 0,
        DISPLAYON: 4,
        DISPLAYOFF: 0,
        CURSORON: 2,
        CURSOROFF: 0,
        BLINKON: 1,
        BLINKOFF: 0,
        DISPLAYMOVE: 8,
        CURSORMOVE: 0,
        MOVERIGHT: 4,
        MOVELEFT: 0,
        BITMODE: {
          4: 0,
          8: 16
        },
        LINE: {
          1: 0,
          2: 8
        },
        DOTS: {
          "5x10": 4,
          "5x8": 0
        },
        BACKLIGHT_ON: 8,
        BACKLIGHT_OFF: 0,
        MEMORYLIMIT: 8,
        EN: 4,
        RW: 2,
        RS: 1,
        D4: 4,
        D5: 5,
        D6: 6,
        D7: 7
      }
    };
    var Controllers = {
      JHD1313M1: {
        REGISTER: {
          value: REGISTER.DEFAULT
        },
        CHARS: {
          value: lcdCharacters.DEFAULT
        },
        initialize: {
          value(options) {
            this.address = {
              lcd: options.address || 62,
              rgb: 98
            };
            options.address = this.address;
            this.io.i2cConfig(options);
            this.lines = options.lines || 2;
            this.rows = options.rows || 2;
            this.cols = options.cols || 16;
            this.dots = options.dots || "5x8";
            const display = this.REGISTER.DISPLAY | this.REGISTER.DISPLAYON | this.REGISTER.CURSOROFF | this.REGISTER.BLINKOFF;
            const state = {
              display,
              characters: {},
              index: this.REGISTER.MEMORYLIMIT - 1,
              backlight: {
                polarity: 1,
                pin: null,
                value: null
              }
            };
            priv.set(this, state);
            blocking: {
              const lines = this.REGISTER.DIMENSIONS | this.REGISTER.LINE[2];
              sleep(50);
              this.command(lines);
              sleep(5);
              this.command(lines);
              this.command(lines);
              this.command(lines);
              sleep(5);
              this.command(this.REGISTER.ENTRY | this.REGISTER.ENTRYLEFT | this.REGISTER.ENTRYSHIFTDECREMENT);
              this.on();
              this.clear();
              this.home();
            }
            this.bgOn();
            if (options.color) {
              this.bgColor(options.color);
            } else {
              this.bgColor("black");
            }
          }
        },
        clear: {
          value() {
            return this.command(this.REGISTER.CLEAR);
          }
        },
        setCursor: {
          value(col, row) {
            return this.command(row === 0 ? col | 128 : col | 192);
          }
        },
        autoscroll: {
          value() {
            const state = priv.get(this);
            state.display = this.REGISTER.ENTRYLEFT | this.REGISTER.ENTRYSHIFTINCREMENT;
            this.command(this.REGISTER.ENTRY | state.display);
            return this;
          }
        },
        bgColor: {
          value(red, green, blue) {
            const rgb = RGB.ToRGB(red, green, blue);
            const address = this.address.rgb;
            this.io.i2cWrite(address, [0, 0]);
            this.io.i2cWrite(address, [1, 0]);
            this.io.i2cWrite(address, [4, rgb.red]);
            this.io.i2cWrite(address, [3, rgb.green]);
            this.io.i2cWrite(address, [2, rgb.blue]);
            return this;
          }
        },
        bgOn: {
          value() {
            this.io.i2cWrite(this.address.rgb, [this.REGISTER.BACKLIGHT_ON, 170]);
            return this;
          }
        },
        bgOff: {
          value() {
            this.io.i2cWrite(this.address.rgb, [this.REGISTER.BACKLIGHT_ON, 0]);
            return this;
          }
        },
        command: {
          value(mode, value) {
            if (arguments.length === 1) {
              value = mode;
              mode = this.REGISTER.COMMAND;
            }
            if (mode === this.REGISTER.DATA) {
              return this.send(value);
            }
            return this.writeBits(this.REGISTER.COMMAND, value);
          }
        },
        send: {
          value(value) {
            return this.writeBits(this.REGISTER.DATA, value);
          }
        },
        writeBits: {
          value(mode, value) {
            this.io.i2cWrite(this.address.lcd, [mode, value]);
            return this;
          }
        },
        hilo: {
          value(callback) {
            callback.call(this);
          }
        }
      },
      PCF8574: {
        REGISTER: {
          value: Object.assign({}, REGISTER.DEFAULT, {
            COMMAND: 0,
            DATA: 1,
            BACKLIGHT_ON: 255,
            BACKLIGHT_OFF: 0
          })
        },
        CHARS: {
          value: lcdCharacters.DEFAULT
        },
        initialize: {
          value(options) {
            this.bitMode = options.bitMode || 4;
            this.lines = options.lines || 2;
            this.rows = options.rows || 2;
            this.cols = options.cols || 16;
            this.dots = options.dots || "5x8";
            if (!options.address) {
              options.address = ["PCF8574A", "PCF8574AT"].includes(options.controller) ? 63 : 39;
            }
            this.io.i2cConfig(options);
            this.address = {
              lcd: options.address
            };
            this.expander = new Expander(this.address.lcd, this.io);
            this.expander.portMode(this.io.MODES.OUTPUT);
            this.expander.portWrite(0);
            const backlight = options.backlight || {
              polarity: 0,
              pin: 3
            };
            backlight.pin = typeof backlight.pin === "undefined" ? 3 : backlight.pin;
            backlight.polarity = typeof backlight.polarity === "undefined" ? 0 : backlight.polarity;
            const dimensions = this.REGISTER.BITMODE[this.bitMode] | this.REGISTER.LINE[this.lines] | this.REGISTER.DOTS[this.dots];
            const display = this.REGISTER.DISPLAY | this.REGISTER.DISPLAYON | this.REGISTER.CURSOROFF | this.REGISTER.BLINKOFF;
            const entry = this.REGISTER.ENTRYLEFT | this.REGISTER.ENTRYSHIFTDECREMENT;
            const state = {
              display,
              characters: {},
              index: this.REGISTER.MEMORYLIMIT - 1,
              backlight: {
                polarity: backlight.polarity,
                pinMask: 1 << backlight.pin,
                statusMask: 0
              },
              data: [
                1 << this.REGISTER.D4,
                1 << this.REGISTER.D5,
                1 << this.REGISTER.D6,
                1 << this.REGISTER.D7
              ]
            };
            priv.set(this, state);
            let toggle = 3 << this.REGISTER.SHIFT_LEFT;
            blocking: {
              this.expander.portWrite(toggle);
              this.pulse(toggle);
              sleep(4);
              this.expander.portWrite(toggle);
              this.pulse(toggle);
              sleep(4);
              this.expander.portWrite(toggle);
              this.pulse(toggle);
              toggle = 2 << this.REGISTER.SHIFT_LEFT;
              this.expander.portWrite(toggle);
              this.pulse(toggle);
              this.command(this.REGISTER.DIMENSIONS | dimensions);
              this.command(state.display);
              state.display = entry;
              this.command(this.REGISTER.ENTRY | state.display);
              this.on();
              this.clear();
              this.backlight();
            }
          }
        },
        clear: {
          value() {
            this.command(this.REGISTER.CLEAR);
            sleep(2);
            return this;
          }
        },
        backlight: {
          value(value) {
            const state = priv.get(this);
            let mask;
            value = typeof value === "undefined" ? 255 : value;
            if (state.backlight.pinMask !== 0) {
              if (state.backlight.polarity === 0 && value > 0 || state.backlight.polarity === 1 && value === 0) {
                mask = 255;
              } else {
                mask = 0;
              }
              state.backlight.statusMask = state.backlight.pinMask & mask;
              this.expander.portWrite(state.backlight.statusMask);
            }
            return this;
          }
        },
        createChar: {
          value(name, charMap) {
            const state = priv.get(this);
            let address;
            if (typeof name === "number") {
              address = name & 7;
            } else {
              address = state.index;
              state.index--;
              if (state.index === -1) {
                state.index = this.REGISTER.MEMORYLIMIT - 1;
              }
            }
            this.command(this.REGISTER.SETCGRAMADDR | address << 3);
            blocking: {
              sleep(1);
              for (let i = 0; i < 8; i++) {
                this.command(this.REGISTER.DATA, charMap[i]);
                sleep(1);
              }
            }
            state.characters[name] = address;
            return address;
          }
        },
        noBacklight: {
          value() {
            this.backlight(0);
          }
        },
        on: {
          value() {
            const state = priv.get(this);
            state.display |= this.REGISTER.DISPLAYON;
            this.command(this.REGISTER.DISPLAY | state.display);
            return this;
          }
        },
        off: {
          value() {
            const state = priv.get(this);
            state.display &= ~this.REGISTER.DISPLAYON;
            this.command(this.REGISTER.DISPLAY | state.display);
            return this;
          }
        },
        hilo: {
          value(callback) {
            callback.call(this);
          }
        },
        command: {
          value(mode, value) {
            if (arguments.length === 1) {
              value = mode;
              mode = this.REGISTER.COMMAND;
            }
            this.send(mode, value);
            return this;
          }
        },
        send: {
          writable: true,
          value(mode, value) {
            this.writeBits(mode, value >> 4);
            this.writeBits(mode, value & 15);
            return this;
          }
        },
        writeBits: {
          writable: true,
          value(mode, value) {
            const state = priv.get(this);
            let pinMapValue = 0;
            for (let i = 0; i < 4; i++) {
              if ((value & 1) === 1) {
                pinMapValue |= state.data[i];
              }
              value = value >> 1;
            }
            if (mode === this.REGISTER.DATA) {
              mode = this.REGISTER.RS;
            }
            pinMapValue |= mode | state.backlight.statusMask;
            this.pulse(pinMapValue);
            return this;
          }
        },
        pulse: {
          writable: true,
          value(data) {
            this.expander.portWrite(data | this.REGISTER.EN);
            this.expander.portWrite(data & ~this.REGISTER.EN);
          }
        }
      },
      PARALLEL: {
        REGISTER: {
          value: REGISTER.DEFAULT
        },
        CHARS: {
          value: lcdCharacters.DEFAULT
        },
        initialize: {
          value(options) {
            this.bitMode = options.bitMode || 4;
            this.lines = options.lines || 2;
            this.rows = options.rows || 2;
            this.cols = options.cols || 16;
            this.dots = options.dots || "5x8";
            if (Array.isArray(options.pins)) {
              this.pins = {
                rs: options.pins[0],
                en: options.pins[1],
                data: [
                  options.pins[5],
                  options.pins[4],
                  options.pins[3],
                  options.pins[2]
                ]
              };
            } else {
              this.pins = options.pins;
            }
            const display = this.REGISTER.DISPLAY | this.REGISTER.DISPLAYON;
            const state = {
              display,
              characters: {},
              index: this.REGISTER.MEMORYLIMIT - 1,
              backlight: {
                polarity: 1,
                pin: null,
                value: null
              }
            };
            priv.set(this, state);
            options.pins.forEach(function(pin) {
              this.io.pinMode(pin, 1);
            }, this);
            this.io.digitalWrite(this.pins.rs, this.io.LOW);
            this.io.digitalWrite(this.pins.en, this.io.LOW);
            if (options.backlight) {
              if (typeof options.backlight === "number") {
                const temp = options.backlight;
                options.backlight = {
                  pin: temp
                };
              }
              if (options.backlight.pin) {
                state.backlight.pin = new Pin({
                  pin: options.backlight.pin,
                  board: this.board
                });
                state.backlight.pin.high();
              }
            }
            blocking: {
              this.command(3);
              sleep(4);
              this.command(3);
              sleep(4);
              this.command(3);
              if (this.bitMode === 4) {
                this.command(2);
              }
              this.command(this.REGISTER.LINE[this.lines] | this.REGISTER.DOTS[this.dots]);
              this.command(display);
              this.clear();
              this.home();
            }
          }
        }
      }
    };
    Controllers.LCM1602 = Controllers.LCD1602 = Controllers.LCM1602IIC = Controllers.LCD2004 = Controllers.PCF8574A = Controllers.PCF8574AT = Controllers.PCF8574T = Controllers.PCF8574;
    Controllers.MJKDZ = Object.assign({}, Controllers.PCF8574, {
      REGISTER: {
        value: Object.assign({}, REGISTER.DEFAULT, {
          SHIFT_LEFT: 0,
          COMMAND: 0,
          DATA: 6,
          EN: 16,
          RW: 5,
          RS: 6,
          D4: 0,
          D5: 1,
          D6: 2,
          D7: 3
        })
      },
      writeBits: {
        writable: true,
        value(mode, value) {
          const state = priv.get(this);
          let pinMapValue = 0;
          for (let i = 0; i < 4; i++) {
            if ((value & 1) === 1) {
              pinMapValue |= state.data[i];
            }
            value = value >> 1;
          }
          if (mode === this.REGISTER.DATA) {
            mode = 1 << this.REGISTER.RS;
          }
          pinMapValue |= mode | state.backlight.statusMask;
          this.pulse(pinMapValue);
          return this;
        }
      }
    });
    Controllers.DEFAULT = Controllers.PARALLEL;
    var LCD = class {
      constructor(options) {
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        this.ctype = options.controller;
        if (this.initialize) {
          this.initialize(options);
        }
        Object.defineProperties(this, {
          characters: {
            get() {
              return Object.assign({}, priv.get(this).characters);
            }
          }
        });
      }
      command(mode, value) {
        if (typeof value === "undefined") {
          value = mode;
          mode = 128;
        }
        if (this.bitMode === 4) {
          this.send(value >> 4);
        }
        this.send(value);
        return this;
      }
      send(value) {
        let pin = 0;
        let mask = {
          4: 8,
          8: 128
        }[this.bitMode];
        for (; mask > 0; mask = mask >> 1) {
          this.io.digitalWrite(this.pins.data[pin], this.io[value & mask ? "HIGH" : "LOW"]);
          pin++;
        }
        this.io.digitalWrite(this.pins.en, this.io.LOW);
        this.io.digitalWrite(this.pins.en, this.io.HIGH);
        sleepus(1);
        this.io.digitalWrite(this.pins.en, this.io.LOW);
        sleepus(37);
        return this;
      }
      hilo(callback) {
        this.io.digitalWrite(this.pins.rs, this.io.HIGH);
        callback.call(this);
        this.io.digitalWrite(this.pins.rs, this.io.LOW);
      }
      print(message, options) {
        let state;
        let dontProcessSpecials;
        let hasCharacters;
        let processed;
        message = `${message}`;
        options = options || {};
        state = priv.get(this);
        dontProcessSpecials = options.dontProcessSpecials || false;
        hasCharacters = !dontProcessSpecials && RE_SPECIALS.test(message);
        if (message.length === 1) {
          this.hilo(function() {
            this.command(this.REGISTER.DATA, message.charCodeAt(0));
          });
        } else {
          if (hasCharacters) {
            processed = message.replace(RE_SPECIALS, (match, name) => {
              const address = state.characters[name];
              return typeof address === "number" ? String.fromCharCode(address) : match;
            });
            this.print(processed, {
              dontProcessSpecials: true
            });
          } else {
            this.hilo(function() {
              Array.from(message).forEach(function(character) {
                this.command(this.REGISTER.DATA, character.charCodeAt(0));
              }, this);
            });
          }
        }
        return this;
      }
      write(charCode) {
        this.hilo.call(this, function() {
          this.command(this.REGISTER.DATA, charCode);
        });
        return this;
      }
      clear() {
        this.command(this.REGISTER.CLEAR);
        sleep(2);
        return this;
      }
      home() {
        this.command(this.REGISTER.HOME);
        sleep(2);
        return this;
      }
      setCursor(col, row) {
        const rowOffsets = [0, 64, 20, 84];
        this.command(this.REGISTER.SETDDRAMADDR | col + rowOffsets[row]);
        return this;
      }
      backlight(highOrLow) {
        const state = priv.get(this);
        highOrLow = typeof highOrLow === "undefined" ? true : false;
        if (state.backlight.pin instanceof Pin) {
          if (highOrLow) {
            state.backlight.pin.high();
          } else {
            state.backlight.pin.low();
          }
        }
        if (highOrLow) {
          state.display |= this.REGISTER.DISPLAYON;
        } else {
          state.display &= ~this.REGISTER.DISPLAYON;
        }
        this.command(state.display);
        return this;
      }
      noBacklight() {
        const state = priv.get(this);
        if (state.backlight.pin instanceof Pin) {
          state.backlight.pin.high();
        }
        return this.backlight(false);
      }
      on() {
        const state = priv.get(this);
        state.display |= this.REGISTER.DISPLAYON;
        this.command(state.display);
        return this;
      }
      off() {
        const state = priv.get(this);
        state.display &= ~this.REGISTER.DISPLAYON;
        this.command(state.display);
        return this;
      }
      cursor(row, col) {
        if (typeof col !== "undefined" && typeof row !== "undefined") {
          return this.setCursor(col, row);
        }
        const state = priv.get(this);
        state.display |= this.REGISTER.CURSORON;
        this.command(state.display);
        return this;
      }
      noCursor() {
        const state = priv.get(this);
        state.display &= ~this.REGISTER.CURSORON;
        this.command(state.display);
        return this;
      }
      blink() {
        const state = priv.get(this);
        state.display |= this.REGISTER.BLINKON;
        this.command(state.display);
        return this;
      }
      noBlink() {
        const state = priv.get(this);
        state.display &= ~this.REGISTER.BLINKON;
        this.command(state.display);
        return this;
      }
      autoscroll() {
        const state = priv.get(this);
        state.display |= this.REGISTER.ENTRYSHIFTINCREMENT;
        this.command(this.REGISTER.ENTRY | state.display);
        return this;
      }
      noAutoscroll() {
        const state = priv.get(this);
        state.display &= ~this.REGISTER.ENTRYSHIFTINCREMENT;
        this.command(this.REGISTER.ENTRY | state.display);
        return this;
      }
      createChar(name, charMap) {
        const state = priv.get(this);
        let address;
        if (typeof name === "number") {
          address = name & 7;
        } else {
          address = state.index;
          state.index--;
          if (state.index === -1) {
            state.index = this.REGISTER.MEMORYLIMIT - 1;
          }
        }
        this.command(this.REGISTER.SETCGRAMADDR | address << 3);
        this.hilo(function() {
          for (let i = 0; i < 8; i++) {
            this.command(this.REGISTER.DATA, charMap[i]);
          }
        });
        state.characters[name] = address;
        return address;
      }
      useChar(name) {
        const state = priv.get(this);
        if (typeof state.characters[name] === "undefined") {
          const newCharIndex = this.createChar(name, this.CHARS[name]);
          for (const oldName in state.characters) {
            if (name !== oldName && state.characters[oldName] === newCharIndex) {
              delete state.characters[oldName];
              break;
            }
          }
          state.characters[name] = newCharIndex;
        }
        return this;
      }
    };
    var RE_SPECIALS = /:(\w+):/g;
    LCD.POSITIVE = 0;
    LCD.NEGATIVE = 1;
    LCD.Characters = lcdCharacters;
    module2.exports = LCD;
  }
});

// node_modules/johnny-five/lib/led/led.js
var require_led = __commonJS({
  "node_modules/johnny-five/lib/led/led.js"(exports, module2) {
    var Board = require_board();
    var Animation = require_animation();
    var Expander = require_expander();
    var { constrain, map, scale } = require_fn();
    var Pins = Board.Pins;
    var priv = new Map();
    var Controllers = {
      PCA9685: {
        initialize: {
          value({ address, pwmRange, frequency, pin }) {
            const state = priv.get(this);
            this.address = address || 64;
            this.pwmRange = pwmRange || [0, 4095];
            this.frequency = frequency || 200;
            state.expander = Expander.get({
              address: this.address,
              controller: this.controller,
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            this.pin = state.expander.normalize(pin);
            state.mode = this.io.MODES.PWM;
          }
        },
        update: {
          writable: true,
          value(input) {
            const state = priv.get(this);
            const output = typeof input !== "undefined" ? input : state.value;
            const value = state.isAnode ? 255 - Board.constrain(output, 0, 255) : output;
            this.write(value);
          }
        },
        write: {
          writable: true,
          value(value) {
            const state = priv.get(this);
            state.expander.analogWrite(this.pin, value);
          }
        }
      },
      DEFAULT: {
        initialize: {
          value({ pin }, pinValue) {
            const state = priv.get(this);
            const isFirmata = Pins.isFirmata(this);
            let defaultLed;
            if (isFirmata && typeof pinValue === "string" && (pinValue.length > 1 && pinValue[0] === "A")) {
              pinValue = this.io.analogPins[+pinValue.slice(1)];
            }
            defaultLed = this.io.defaultLed || 13;
            pinValue = +pinValue;
            if (isFirmata && this.io.analogPins.includes(pinValue)) {
              this.pin = pinValue;
              state.mode = this.io.MODES.OUTPUT;
            } else {
              this.pin = typeof pin === "undefined" ? defaultLed : pin;
              state.mode = this.io.MODES[this.board.pins.isPwm(this.pin) ? "PWM" : "OUTPUT"];
            }
            this.io.pinMode(this.pin, state.mode);
          }
        },
        update: {
          writable: true,
          value(input) {
            const state = priv.get(this);
            const output = typeof input !== "undefined" ? input : state.value;
            let value = state.isAnode ? 255 - Board.constrain(output, 0, 255) : output;
            value = map(value, 0, 255, 0, this.board.RESOLUTION.PWM);
            if (value !== this.io.LOW && value !== this.io.HIGH && this.mode !== this.io.MODES.PWM) {
              Board.Pins.Error({
                pin: this.pin,
                type: "PWM",
                via: "Led"
              });
            }
            if (state.mode === this.io.MODES.OUTPUT) {
              value = output;
            }
            this.write(value);
          }
        },
        write: {
          writable: true,
          value(value) {
            const state = priv.get(this);
            if (state.mode === this.io.MODES.OUTPUT) {
              this.io.digitalWrite(this.pin, value);
            }
            if (state.mode === this.io.MODES.PWM) {
              this.io.analogWrite(this.pin, value);
            }
          }
        }
      }
    };
    var Led = class {
      constructor(options) {
        const pinValue = typeof options === "object" ? options.pin : options;
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {
          isAnode: options.isAnode,
          isOn: false,
          isRunning: false,
          value: null,
          direction: 1,
          mode: null,
          intensity: 0,
          interval: null
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          value: {
            get() {
              return state.value;
            }
          },
          mode: {
            get() {
              return state.mode;
            }
          },
          isOn: {
            get() {
              return !!state.value;
            }
          },
          isRunning: {
            get() {
              return state.isRunning;
            }
          },
          animation: {
            get() {
              return state.animation;
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options, pinValue);
        }
      }
      on() {
        const state = priv.get(this);
        if (state.mode === this.io.MODES.OUTPUT) {
          state.value = this.io.HIGH;
        }
        if (state.mode === this.io.MODES.PWM) {
          if (state.value === null) {
            state.value = 255;
          }
          if (!state.interval) {
            state.value = 255;
          }
          if (state.value === 0) {
            state.value = 255;
          }
        }
        this.update();
        return this;
      }
      off() {
        const state = priv.get(this);
        state.value = 0;
        this.update();
        return this;
      }
      toggle() {
        return this[this.isOn ? "off" : "on"]();
      }
      brightness(brightness) {
        const state = priv.get(this);
        state.value = brightness;
        this.update();
        return this;
      }
      intensity(intensity) {
        const state = priv.get(this);
        if (arguments.length === 0) {
          return state.intensity;
        }
        state.intensity = constrain(intensity, 0, 100);
        return this.brightness(scale(state.intensity, 0, 100, 0, 255));
      }
      [Animation.normalize](keyFrames) {
        const state = priv.get(this);
        if (keyFrames[0] === null) {
          keyFrames[0] = {
            value: state.value || 0
          };
        }
        return keyFrames.map((frame) => {
          const value = frame;
          if (frame !== null) {
            if (typeof frame === "number") {
              frame = {
                value
              };
            } else {
              if (typeof frame.brightness === "number") {
                frame.value = frame.brightness;
                delete frame.brightness;
              }
              if (typeof frame.intensity === "number") {
                frame.value = scale(frame.intensity, 0, 100, 0, 255);
                delete frame.intensity;
              }
            }
            if (!frame.easing) {
              frame.easing = "linear";
            }
          }
          return frame;
        });
      }
      [Animation.render](position) {
        const state = priv.get(this);
        state.value = position[0];
        return this.update();
      }
      pulse(duration, callback) {
        const state = priv.get(this);
        this.stop();
        const options = {
          duration: typeof duration === "number" ? duration : 1e3,
          keyFrames: [0, 255],
          metronomic: true,
          loop: true,
          easing: "inOutSine",
          onloop() {
            if (typeof callback === "function") {
              callback();
            }
          }
        };
        if (typeof duration === "object") {
          Object.assign(options, duration);
        }
        if (typeof duration === "function") {
          callback = duration;
        }
        state.isRunning = true;
        state.animation = state.animation || new Animation(this);
        state.animation.enqueue(options);
        return this;
      }
      fade(val, duration, callback) {
        const state = priv.get(this);
        this.stop();
        const options = {
          duration: typeof duration === "number" ? duration : 1e3,
          keyFrames: [null, typeof val === "number" ? val : 255],
          easing: "outSine",
          oncomplete() {
            state.isRunning = false;
            if (typeof callback === "function") {
              callback();
            }
          }
        };
        if (typeof val === "object") {
          Object.assign(options, val);
        }
        if (typeof val === "function") {
          callback = val;
        }
        if (typeof duration === "object") {
          Object.assign(options, duration);
        }
        if (typeof duration === "function") {
          callback = duration;
        }
        state.isRunning = true;
        state.animation = state.animation || new Animation(this);
        state.animation.enqueue(options);
        return this;
      }
      fadeIn(duration, callback) {
        return this.fade(255, duration || 1e3, callback);
      }
      fadeOut(duration, callback) {
        return this.fade(0, duration || 1e3, callback);
      }
      blink(duration, callback) {
        const state = priv.get(this);
        this.stop();
        if (typeof duration === "function") {
          callback = duration;
          duration = null;
        }
        state.isRunning = true;
        state.interval = setInterval(() => {
          this.toggle();
          if (typeof callback === "function") {
            callback();
          }
        }, duration || 100);
        return this;
      }
      stop() {
        const state = priv.get(this);
        if (state.interval) {
          clearInterval(state.interval);
        }
        if (state.animation) {
          state.animation.stop();
        }
        state.interval = null;
        state.isRunning = false;
        return this;
      }
    };
    Led.prototype.strobe = Led.prototype.blink;
    if (!!process.env.IS_TEST_MODE) {
      Led.Controllers = Controllers;
      Led.purge = function() {
        priv.clear();
      };
    }
    module2.exports = Led;
  }
});

// node_modules/johnny-five/lib/led/leds.js
var require_leds = __commonJS({
  "node_modules/johnny-five/lib/led/leds.js"(exports, module2) {
    var Animation = require_animation();
    var Led = require_led();
    var Collection = require_collection();
    var Leds = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Led;
      }
      [Animation.normalize](keyFrameSet) {
        return keyFrameSet.map((keyFrames, index) => {
          if (keyFrames !== null) {
            return this[index][Animation.normalize](keyFrames);
          }
          return keyFrames;
        });
      }
      [Animation.render](frames) {
        return this.each((led, i) => led[Animation.render]([frames[i]]));
      }
    };
    Collection.installMethodForwarding(Leds.prototype, Led.prototype, {
      skip: [Animation.normalize, Animation.render]
    });
    Collection.installCallbackReconciliation(Leds.prototype, ["pulse", "fade", "fadeIn", "fadeOut", "blink"]);
    Led.Collection = Leds;
    module2.exports = Leds;
  }
});

// node_modules/johnny-five/lib/led/rgbs.js
var require_rgbs = __commonJS({
  "node_modules/johnny-five/lib/led/rgbs.js"(exports, module2) {
    var Animation = require_animation();
    var Collection = require_collection();
    var RGB = require_rgb();
    var RGBs = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return RGB;
      }
      [Animation.normalize](keyFrameSet) {
        return keyFrameSet.map((keyFrames, index) => {
          if (keyFrames !== null) {
            return this[index][Animation.normalize](keyFrames);
          }
          return keyFrames;
        });
      }
      [Animation.render](frames) {
        return this.each((led, i) => led[Animation.render]([frames[i]]));
      }
    };
    Collection.installMethodForwarding(RGBs.prototype, RGB.prototype, {
      skip: [Animation.normalize, Animation.render]
    });
    Collection.installCallbackReconciliation(RGBs.prototype, ["blink"]);
    RGBs.prototype[Animation.keys] = RGB.colors;
    module2.exports = RGBs;
  }
});

// node_modules/johnny-five/lib/led/led-chars.js
var require_led_chars = __commonJS({
  "node_modules/johnny-five/lib/led/led-chars.js"(exports, module2) {
    module2.exports = {
      MATRIX_CHARS: {
        " ": [0, 0, 0, 0, 0, 0, 0, 0],
        "!": [4, 4, 4, 4, 0, 0, 4, 0],
        '"': [10, 10, 10, 0, 0, 0, 0, 0],
        "#": [10, 10, 31, 10, 31, 10, 10, 0],
        "$": [4, 15, 20, 14, 5, 30, 4, 0],
        "%": [24, 25, 2, 4, 8, 19, 3, 0],
        "&": [12, 18, 20, 8, 21, 18, 13, 0],
        "'": [12, 4, 8, 0, 0, 0, 0, 0],
        "(": [2, 4, 8, 8, 8, 4, 2, 0],
        ")": [8, 4, 2, 2, 2, 4, 8, 0],
        "*": [0, 4, 21, 14, 21, 4, 0, 0],
        "+": [0, 4, 4, 31, 4, 4, 0, 0],
        ",": [0, 0, 0, 0, 12, 4, 8, 0],
        "-": [0, 0, 0, 31, 0, 0, 0, 0],
        ".": [0, 0, 0, 0, 0, 12, 12, 0],
        "/": [0, 1, 2, 4, 8, 16, 0, 0],
        "[": [14, 8, 8, 8, 8, 8, 14, 0],
        "\\": [0, 16, 8, 4, 2, 1, 0, 0],
        "]": [14, 2, 2, 2, 2, 2, 14, 0],
        "^": [4, 10, 17, 0, 0, 0, 0, 0],
        "_": [0, 0, 0, 0, 0, 0, 31, 0],
        "`": [16, 8, 4, 0, 0, 0, 0, 0],
        ":": [0, 12, 12, 0, 12, 12, 0, 0],
        ";": [0, 12, 12, 0, 12, 4, 8, 0],
        "<": [2, 4, 8, 16, 8, 4, 2, 0],
        "=": [0, 0, 31, 0, 31, 0, 0, 0],
        ">": [8, 4, 2, 1, 2, 4, 8, 0],
        "?": [14, 17, 1, 2, 4, 0, 4, 0],
        "@": [14, 17, 1, 13, 21, 21, 14, 0],
        "{": [2, 4, 4, 8, 4, 4, 2, 0],
        "|": [4, 4, 4, 0, 4, 4, 4, 0],
        "}": [8, 4, 4, 2, 4, 4, 8, 0],
        "~": [8, 21, 2, 0, 0, 0, 0, 0],
        "0": [14, 17, 19, 21, 25, 17, 14, 0],
        "1": [4, 12, 4, 4, 4, 4, 14, 0],
        "2": [14, 17, 1, 2, 4, 8, 31, 0],
        "3": [31, 2, 4, 2, 1, 17, 14, 0],
        "4": [2, 6, 10, 18, 31, 2, 2, 0],
        "5": [31, 16, 30, 1, 1, 17, 14, 0],
        "6": [6, 8, 16, 30, 17, 17, 14, 0],
        "7": [31, 1, 2, 4, 4, 4, 4, 0],
        "8": [30, 17, 17, 14, 17, 17, 14, 0],
        "9": [14, 17, 17, 15, 1, 2, 12, 0],
        "A": [8, 20, 34, 62, 34, 34, 34, 34],
        "B": [60, 34, 34, 62, 34, 34, 60, 0],
        "C": [60, 64, 64, 64, 64, 64, 60, 0],
        "D": [124, 66, 66, 66, 66, 66, 124, 0],
        "E": [124, 64, 64, 124, 64, 64, 64, 124],
        "F": [124, 64, 64, 124, 64, 64, 64, 64],
        "G": [60, 64, 64, 64, 64, 68, 68, 60],
        "H": [68, 68, 68, 124, 68, 68, 68, 68],
        "I": [124, 16, 16, 16, 16, 16, 16, 124],
        "J": [60, 8, 8, 8, 8, 8, 72, 48],
        "K": [0, 36, 40, 48, 32, 48, 40, 36],
        "L": [64, 64, 64, 64, 64, 64, 64, 124],
        "M": [129, 195, 165, 153, 129, 129, 129, 129],
        "N": [0, 66, 98, 82, 74, 70, 66, 0],
        "O": [60, 66, 66, 66, 66, 66, 66, 60],
        "P": [60, 34, 34, 34, 60, 32, 32, 32],
        "Q": [28, 34, 34, 34, 34, 38, 34, 29],
        "R": [60, 34, 34, 34, 60, 36, 34, 33],
        "S": [0, 30, 32, 32, 62, 2, 2, 60],
        "T": [0, 62, 8, 8, 8, 8, 8, 8],
        "U": [66, 66, 66, 66, 66, 66, 34, 28],
        "V": [66, 66, 66, 66, 66, 66, 36, 24],
        "W": [0, 73, 73, 73, 73, 42, 28, 0],
        "X": [0, 65, 34, 20, 8, 20, 34, 65],
        "Y": [65, 34, 20, 8, 8, 8, 8, 8],
        "Z": [0, 127, 2, 4, 8, 16, 32, 127],
        "a": [0, 0, 14, 1, 15, 17, 15, 0],
        "b": [16, 16, 22, 25, 17, 17, 30, 0],
        "c": [0, 0, 14, 17, 16, 17, 14, 0],
        "d": [1, 1, 13, 19, 17, 17, 15, 0],
        "e": [0, 0, 14, 17, 31, 16, 14, 0],
        "f": [2, 5, 4, 14, 4, 4, 4, 0],
        "g": [0, 13, 19, 19, 13, 1, 14, 0],
        "h": [16, 16, 22, 25, 17, 17, 17, 0],
        "i": [4, 0, 12, 4, 4, 4, 14, 0],
        "j": [2, 0, 6, 2, 2, 18, 12, 0],
        "k": [8, 8, 9, 10, 12, 10, 9, 0],
        "l": [12, 4, 4, 4, 4, 4, 14, 0],
        "m": [0, 0, 26, 21, 21, 21, 21, 0],
        "n": [0, 0, 22, 25, 17, 17, 17, 0],
        "o": [0, 0, 14, 17, 17, 17, 14, 0],
        "p": [0, 22, 25, 25, 22, 16, 16, 0],
        "q": [0, 13, 19, 19, 13, 1, 1, 0],
        "r": [0, 0, 22, 25, 16, 16, 16, 0],
        "s": [0, 0, 15, 16, 30, 1, 31, 0],
        "t": [8, 8, 28, 8, 8, 9, 6, 0],
        "u": [0, 0, 18, 18, 18, 18, 13, 0],
        "v": [0, 0, 17, 17, 17, 10, 4, 0],
        "w": [0, 0, 17, 17, 21, 21, 10, 0],
        "x": [0, 0, 17, 10, 4, 10, 17, 0],
        "y": [0, 0, 17, 17, 19, 13, 1, 14],
        "z": [0, 0, 31, 2, 4, 8, 31, 0],
        euro: [14, 16, 124, 32, 124, 32, 16, 14],
        cent: [0, 60, 66, 64, 64, 82, 60, 32],
        angryface: [0, 102, 102, 0, 24, 36, 66, 129],
        circle: [60, 66, 129, 129, 129, 129, 66, 60],
        cdot: [60, 66, 129, 153, 153, 129, 66, 60],
        donut: [60, 126, 255, 231, 231, 255, 126, 60],
        equality: [0, 255, 255, 0, 0, 255, 255, 0],
        ball: [60, 126, 255, 255, 255, 255, 126, 60],
        thinsquare: [255, 129, 129, 129, 129, 129, 129, 255],
        thicksquare: [255, 255, 195, 195, 195, 195, 255, 255],
        centeredsquare1: [0, 0, 60, 60, 60, 60, 0, 0],
        centeredsquare2: [0, 0, 60, 60, 60, 60, 0, 0],
        arrowright: [0, 4, 6, 255, 255, 6, 4, 0],
        arrowleft: [0, 32, 96, 255, 255, 96, 32, 0],
        note: [4, 6, 7, 4, 60, 124, 124, 56],
        clock: [60, 82, 145, 145, 143, 129, 66, 60],
        heartoutline: [102, 153, 129, 129, 66, 36, 24, 0],
        heartfull: [102, 255, 255, 255, 126, 60, 24, 0],
        thincheck: [0, 0, 1, 2, 4, 136, 80, 32],
        thickcheck: [0, 1, 3, 6, 140, 216, 112, 32],
        speaker: [3, 7, 63, 63, 63, 63, 7, 3],
        sound: [0, 64, 128, 0, 192, 0, 128, 64],
        xbig: [195, 231, 126, 60, 60, 126, 231, 195],
        target: [60, 126, 195, 219, 219, 195, 126, 60],
        bell: [24, 60, 60, 60, 60, 126, 0, 24],
        smile: [0, 102, 102, 0, 0, 129, 66, 60],
        frown: [0, 102, 102, 0, 0, 60, 66, 129],
        winkright: [0, 96, 102, 0, 0, 129, 66, 60],
        winkleft: [0, 6, 102, 0, 0, 129, 66, 60],
        blink: [0, 0, 102, 0, 0, 129, 66, 60],
        laughing: [0, 102, 102, 0, 255, 129, 66, 60],
        tongueout: [0, 102, 102, 0, 0, 126, 10, 4],
        expressionless: [0, 102, 102, 0, 0, 255, 0, 0],
        ascprogress1: [128, 128, 128, 128, 128, 128, 128, 128],
        ascprogress2: [192, 192, 192, 192, 192, 192, 192, 192],
        ascprogress3: [224, 224, 224, 224, 224, 224, 224, 224],
        ascprogress4: [240, 240, 240, 240, 240, 240, 240, 240],
        ascprogress5: [248, 248, 248, 248, 248, 248, 248, 248],
        ascprogress6: [252, 252, 252, 252, 252, 252, 252, 252],
        ascprogress7: [254, 254, 254, 254, 254, 254, 254, 254],
        fullprogress: [255, 255, 255, 255, 255, 255, 255, 255],
        descprogress1: [127, 127, 127, 127, 127, 127, 127, 127],
        descprogress2: [63, 63, 63, 63, 63, 63, 63, 63],
        descprogress3: [31, 31, 31, 31, 31, 31, 31, 31],
        descprogress4: [15, 15, 15, 15, 15, 15, 15, 15],
        descprogress5: [7, 7, 7, 7, 7, 7, 7, 7],
        descprogress6: [3, 3, 3, 3, 3, 3, 3, 3],
        descprogress7: [1, 1, 1, 1, 1, 1, 1, 1],
        ascchart1: [255, 0, 0, 0, 0, 0, 0, 0],
        ascchart2: [255, 255, 0, 0, 0, 0, 0, 0],
        ascchart3: [255, 255, 255, 0, 0, 0, 0, 0],
        ascchart4: [255, 255, 255, 255, 0, 0, 0, 0],
        ascchart5: [255, 255, 255, 255, 255, 0, 0, 0],
        ascchart6: [255, 255, 255, 255, 255, 255, 0, 0],
        ascchart7: [255, 255, 255, 255, 255, 255, 255, 0],
        ascchart8: [255, 255, 255, 255, 255, 255, 255, 255],
        descchart1: [0, 255, 255, 255, 255, 255, 255, 255],
        descchart2: [0, 0, 255, 255, 255, 255, 255, 255],
        descchart3: [0, 0, 0, 255, 255, 255, 255, 255],
        descchart4: [0, 0, 0, 0, 255, 255, 255, 255],
        descchart5: [0, 0, 0, 0, 0, 255, 255, 255],
        descchart6: [0, 0, 0, 0, 0, 0, 255, 255],
        descchart7: [0, 0, 0, 0, 0, 0, 0, 255],
        descchart8: [0, 0, 0, 0, 0, 0, 0, 0],
        borderleft1: [1, 1, 1, 1, 1, 1, 1, 1],
        borderleft2: [3, 2, 2, 2, 2, 2, 2, 3],
        borderleft3: [7, 4, 4, 4, 4, 4, 4, 7],
        borderleft4: [15, 8, 8, 8, 8, 8, 8, 15],
        borderleft5: [31, 16, 16, 16, 16, 16, 16, 31],
        borderleft6: [63, 32, 32, 32, 32, 32, 32, 63],
        borderleft7: [127, 64, 64, 64, 64, 64, 64, 127],
        borderleft8: [255, 128, 128, 128, 128, 128, 128, 255],
        bordertopbottom5: [255, 0, 0, 0, 0, 0, 0, 255],
        borderright1: [128, 128, 128, 128, 128, 128, 128, 128],
        borderright2: [192, 64, 64, 64, 64, 64, 64, 192],
        borderright3: [224, 32, 32, 32, 32, 32, 32, 224],
        borderright4: [240, 16, 16, 16, 16, 16, 16, 240],
        borderright5: [248, 8, 8, 8, 8, 8, 8, 248],
        borderright6: [252, 4, 4, 4, 4, 4, 4, 252],
        borderright7: [254, 2, 2, 2, 2, 2, 2, 254],
        borderright8: [255, 1, 1, 1, 1, 1, 1, 255],
        box1: [224, 224, 224, 0, 0, 0, 0, 0],
        box2: [7, 7, 7, 0, 0, 0, 0, 0],
        box3: [231, 231, 231, 0, 0, 0, 0, 0],
        box4: [0, 0, 0, 0, 0, 7, 7, 7],
        box5: [7, 7, 7, 0, 0, 7, 7, 7],
        box6: [224, 224, 224, 0, 0, 7, 7, 7],
        box7: [231, 231, 231, 0, 0, 7, 7, 7],
        box8: [0, 0, 0, 0, 0, 224, 224, 224],
        box9: [7, 7, 7, 0, 0, 224, 224, 224],
        box10: [224, 224, 224, 0, 0, 224, 224, 224],
        box11: [231, 231, 231, 0, 0, 224, 224, 224],
        box12: [0, 0, 0, 0, 0, 231, 231, 231],
        box13: [7, 7, 7, 0, 0, 231, 231, 231],
        box14: [224, 224, 224, 0, 0, 231, 231, 231],
        box15: [231, 231, 231, 0, 0, 231, 231, 231],
        checkerboard1: [170, 85, 170, 85, 170, 85, 170, 85],
        checkerboard2: [85, 170, 85, 170, 85, 170, 85, 170],
        checkerboard3: [93, 234, 87, 186, 85, 238, 85, 187],
        checkerboard4: [204, 51, 51, 204, 204, 51, 51, 204],
        checkerboard5: [204, 204, 51, 51, 204, 204, 51, 51],
        checkerboard6: [51, 204, 204, 51, 51, 204, 204, 51],
        checkerboard7: [51, 51, 204, 204, 51, 51, 204, 204],
        pointerright: [32, 48, 56, 60, 60, 56, 48, 32],
        pointerup: [0, 0, 24, 60, 126, 255, 0, 0],
        pointerleft: [4, 12, 28, 60, 60, 28, 12, 4],
        pointerdown: [0, 0, 255, 126, 60, 24, 0, 0],
        arrowne: [0, 62, 6, 10, 18, 34, 64, 128],
        arrownw: [0, 124, 96, 80, 72, 68, 2, 1],
        arrowsw: [1, 2, 68, 72, 80, 96, 124, 0],
        arrowse: [128, 64, 34, 18, 10, 6, 62, 0],
        dice1: [0, 0, 0, 24, 24, 0, 0, 0],
        dice2: [192, 192, 0, 0, 0, 0, 3, 3],
        dice3: [192, 192, 0, 24, 24, 0, 3, 3],
        dice4: [195, 195, 0, 0, 0, 0, 195, 195],
        dice5: [195, 195, 0, 24, 24, 0, 195, 195],
        dice6: [195, 195, 0, 195, 195, 0, 195, 195],
        outlinedplus1: [60, 36, 231, 129, 129, 231, 36, 60],
        outlinedplus2: [255, 231, 231, 129, 129, 231, 231, 255],
        twoboxes1: [240, 144, 144, 240, 15, 9, 9, 15],
        twoboxes2: [240, 144, 144, 254, 18, 18, 30, 0],
        twoboxes3: [240, 144, 188, 244, 36, 60, 0, 0],
        twoboxes4: [240, 248, 216, 248, 120, 0, 0, 0],
        twoboxes5: [15, 9, 9, 15, 240, 144, 144, 240],
        fourboxes: [255, 153, 153, 255, 255, 153, 153, 255],
        chain1: [240, 248, 216, 248, 120, 0, 0, 0],
        chain2: [240, 144, 188, 244, 47, 61, 9, 15]
      },
      SPECIAL_CHARS: {
        "0": [60, 102, 102, 102, 102, 102, 102, 60],
        "1": [24, 56, 120, 24, 24, 24, 24, 24],
        "2": [60, 102, 6, 12, 24, 48, 96, 126],
        "3": [60, 102, 6, 28, 6, 6, 102, 60],
        "4": [14, 30, 54, 102, 102, 126, 6, 6],
        "5": [126, 96, 96, 124, 6, 6, 102, 60],
        "6": [60, 102, 96, 124, 102, 102, 102, 60],
        "7": [126, 126, 6, 12, 24, 24, 24, 24],
        "8": [60, 102, 102, 60, 102, 102, 102, 60],
        "9": [60, 102, 102, 62, 6, 6, 102, 60],
        "10": [94, 82, 82, 82, 82, 94, 0, 255],
        "11": [36, 36, 36, 36, 36, 36, 0, 255],
        "12": [94, 66, 68, 72, 80, 94, 0, 255],
        "13": [94, 66, 78, 66, 66, 94, 0, 255],
        "14": [82, 82, 94, 66, 66, 66, 0, 255],
        "15": [94, 80, 94, 66, 66, 94, 0, 255],
        "16": [94, 80, 94, 82, 82, 94, 0, 255],
        "17": [94, 66, 68, 72, 72, 72, 0, 255],
        "18": [94, 82, 94, 82, 82, 94, 0, 255],
        "19": [94, 82, 94, 66, 66, 94, 0, 255]
      },
      DIGIT_CHARS: {
        "0": 126,
        "1": 48,
        "2": 109,
        "3": 121,
        "4": 51,
        "5": 91,
        "6": 95,
        "7": 112,
        "8": 127,
        "9": 123,
        " ": 0,
        ".": 128,
        ":": 255,
        "!": 176,
        "A": 119,
        "a": 125,
        "B": 127,
        "b": 31,
        "C": 78,
        "c": 13,
        "D": 126,
        "d": 61,
        "E": 79,
        "e": 111,
        "F": 71,
        "f": 71,
        "G": 94,
        "g": 123,
        "H": 55,
        "h": 23,
        "I": 48,
        "i": 16,
        "J": 60,
        "j": 56,
        "K": 55,
        "k": 23,
        "L": 14,
        "l": 6,
        "M": 85,
        "m": 85,
        "N": 21,
        "n": 21,
        "O": 126,
        "o": 29,
        "P": 103,
        "p": 103,
        "Q": 115,
        "q": 115,
        "R": 119,
        "r": 5,
        "S": 91,
        "s": 91,
        "T": 70,
        "t": 15,
        "U": 62,
        "u": 28,
        "V": 39,
        "v": 35,
        "W": 63,
        "w": 43,
        "X": 37,
        "x": 37,
        "Y": 59,
        "y": 51,
        "Z": 109,
        "z": 109
      }
    };
  }
});

// node_modules/johnny-five/lib/led/ledcontrol.js
var require_ledcontrol = __commonJS({
  "node_modules/johnny-five/lib/led/ledcontrol.js"(exports, module2) {
    var Board = require_board();
    var ledCharacters = require_led_chars();
    var priv = new Map();
    var LedControl = class {
      constructor(options) {
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        this.digitOrder = 1;
        if (!this.isMatrix) {
          this.colon = options.colon || false;
        }
        const devices = options.devices || (options.addresses ? options.addresses.length : 1);
        this.memory = Array(64).fill(0);
        options.dims = options.dims || LedControl.MATRIX_DIMENSIONS["8x8"];
        if (typeof options.dims === "string") {
          options.dims = LedControl.MATRIX_DIMENSIONS[options.dims];
        }
        if (Array.isArray(options.dims)) {
          options.dims = {
            rows: options.dims[0],
            columns: options.dims[1]
          };
        }
        const state = {
          devices,
          digits: options.digits || 8,
          isMatrix: !!options.isMatrix,
          isBicolor: !!options.isBicolor,
          rows: options.dims.rows,
          columns: options.dims.columns
        };
        if (!(state.columns === 8 || state.columns === 16) || !(state.rows === 8 || state.rows === 16) || state.columns + state.rows === 32) {
          throw new Error("Invalid matrix dimensions specified: must be 8x8, 16x8 or 8x16");
        }
        Object.defineProperties(this, {
          devices: {
            get() {
              return state.devices;
            }
          },
          digits: {
            get() {
              return state.digits;
            }
          },
          isMatrix: {
            get() {
              return state.isMatrix;
            }
          },
          isBicolor: {
            get() {
              return state.isBicolor;
            }
          },
          rows: {
            get() {
              return state.rows;
            }
          },
          columns: {
            get() {
              return state.columns;
            }
          }
        });
        priv.set(this, state);
        this.initialize(options);
      }
      each(callbackfn) {
        for (let i = 0; i < this.devices; i++) {
          callbackfn.call(this, i);
        }
      }
      on(addr) {
        if (typeof addr === "undefined") {
          this.each(function(device) {
            this.on(device);
          });
        } else {
          this.send(addr, this.OP.SHUTDOWN || LedControl.OP.SHUTDOWN, 1);
        }
        return this;
      }
      off(addr) {
        if (typeof addr === "undefined") {
          this.each(function(device) {
            this.off(device);
          });
        } else {
          this.send(addr, this.OP.SHUTDOWN || LedControl.OP.SHUTDOWN, 0);
        }
        return this;
      }
      digit(addr, position, chr) {
        let args;
        let offset;
        let index;
        let character;
        let value;
        let hasDecimal = false;
        if (arguments.length < 3) {
          args = Array.from(arguments);
          this.each(function(device) {
            this.digit.apply(this, (args.unshift(device), args));
          });
          return this;
        }
        if (this.isMatrix) {
          this.draw.apply(this, arguments);
          return this;
        }
        offset = addr * this.digits;
        character = String(chr);
        position = Number(position);
        index = position;
        if (this.digitOrder === -1) {
          index = this.digits - index - 1;
        }
        if (character.length === 2 && character[1] === ".") {
          hasDecimal = true;
          character = character[0];
        }
        value = LedControl.DIGIT_CHARS[character];
        if (!value) {
          value = Math.abs(Number(character));
        }
        if (hasDecimal) {
          value = value | LedControl.DIGIT_CHARS["."];
        }
        this.memory[offset + index] = value;
        this.sendDigit(addr, index, value);
        return this;
      }
      print(message, options) {
        const rdigchars = /([0-9A-Za-z][.]|[0-9A-Za-z:]|[\s])/g;
        let characters;
        options = options || {
          device: 0
        };
        if (this.isMatrix) {
          throw new Error("Led.Matrix does not yet support the print method");
        }
        if (typeof message !== "string") {
          message = String(message);
        }
        characters = message.match(rdigchars);
        if (this.colon) {
          if (characters.length > 2 && (characters[2] !== ":" && characters[2] !== " ")) {
            characters.splice(2, 0, " ");
          }
        }
        (characters || []).forEach(function(character, position) {
          this.digit(options.device, position, character);
        }, this);
        return this;
      }
      brightness(addr, val) {
        if (arguments.length === 1) {
          val = addr;
          this.each(function(device) {
            this.brightness(device, val);
          });
        } else {
          this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));
        }
        return this;
      }
      column(addr, col, value) {
        let state;
        if (!this.isMatrix) {
          throw new Error("The `column` method is only supported for Matrix devices");
        }
        if (arguments.length === 2) {
          value = col;
          col = addr;
          this.each(function(device) {
            this.column(device, col, value);
          });
        } else {
          for (let row = 0; row < this.rows; row++) {
            state = value >> this.rows - 1 - row;
            state = state & 1;
            this.led(addr, row, col, state);
          }
        }
        return this;
      }
      draw(addr, chr) {
        let character;
        if (arguments.length === 1) {
          chr = addr;
          this.each(function(device) {
            this.draw(device, chr);
          });
        } else {
          if (this.isMatrix) {
            if (Array.isArray(chr)) {
              character = chr;
            } else {
              character = ledCharacters.MATRIX_CHARS[chr];
            }
            if (character !== void 0) {
              if (character.length !== this.rows && character.length !== this.columns) {
                throw new Error(`Invalid character: ${character}`);
              }
              const charLength = character.length;
              for (let i = 0; i < this.rows - charLength; i++) {
                character.push(0);
              }
              character.forEach(function(rowData, idx) {
                this.row(addr, idx, rowData);
              }, this);
            }
          } else {
            this.digit.apply(this, arguments);
          }
        }
        return this;
      }
      device(addr) {
        const bound = {};
        Object.keys(LedControl.prototype).forEach((key) => {
          bound[key] = this[key].bind(this, addr);
        });
        Object.getOwnPropertyNames(this).forEach((key) => {
          if (this[key] && typeof this[key] === "function") {
            bound[key] = this[key].bind(this, addr);
          }
        });
        return bound;
      }
    };
    var addresses = new Set([112, 113, 114, 115, 116, 117, 118, 119]);
    var Controllers = {
      HT16K33: {
        OP: {
          value: {
            SHUTDOWN: 32,
            BRIGHTNESS: 224,
            BLINK: 128
          }
        },
        initialize: {
          writable: true,
          value(options) {
            const state = priv.get(this);
            const available = Array.from(addresses);
            if (available.length === 0) {
              throw new Error("There are no available HT16K33 controller addresses");
            }
            this.addresses = options.addresses || (options.address ? [options.address] : null);
            if (this.addresses === null) {
              this.addresses = available.slice(0, state.devices);
            }
            this.addresses.forEach((address) => {
              if (!addresses.has(address)) {
                throw new Error(`Invalid HT16K33 controller address: ${address}`);
              }
              addresses.delete(address);
            });
            this.rotation = options.rotation || 1;
            if (this.columns === 16 && !options.rotation) {
              this.rotation = 0;
            }
            this.buffer = Array(this.rows).fill([]);
            if (!this.isMatrix) {
              this.colon = true;
            }
            options.addresses = this.addresses;
            this.io.i2cConfig(options);
            this.each(function(device) {
              this.on(device);
              this.blink(device, false);
              this.brightness(device, 100);
              this.clear(device);
            });
          }
        },
        blink: {
          writable: true,
          value(addr, val) {
            if (arguments.length === 1) {
              val = addr;
              this.each(function(device) {
                this.blink(device, val);
              });
            } else {
              let _val = null;
              switch (val) {
                case false:
                  _val = 0;
                  break;
                case "slow":
                  _val = 6;
                  break;
                case "normal":
                  _val = 4;
                  break;
                case "fast":
                  _val = 2;
                  break;
              }
              if (_val == null) {
                return;
              }
              this.send(addr, this.OP.BLINK | 1, _val);
            }
            return this;
          }
        },
        clear: {
          writable: true,
          value(addr) {
            let offset;
            if (typeof addr === "undefined") {
              this.each(function(device) {
                this.clear(device);
              });
            } else {
              offset = addr * this.columns;
              for (let i = 0; i < this.rows; i++) {
                this.memory[offset + i] = 0;
                this.buffer[addr][i] = 0;
              }
              this.writeDisplay(addr);
            }
            return this;
          }
        },
        led: {
          writable: true,
          value(addr, row, col, state) {
            if (arguments.length === 3) {
              state = col;
              col = row;
              row = addr;
              this.each(function(device) {
                this.led(device, row, col, state);
              });
              return this;
            } else {
              let x = col;
              let y = row;
              let tmp;
              let rows = this.rows;
              let columns = this.columns;
              if (y < 0 || y >= rows) {
                return this;
              }
              if (x < 0 || x >= columns) {
                return this;
              }
              switch (this.rotation) {
                case 1:
                  columns = this.rows;
                  rows = this.columns;
                  tmp = x;
                  x = y;
                  y = tmp;
                  x = columns - x - 1;
                  break;
                case 2:
                  x = columns - x - 1;
                  y = rows - y - 1;
                  break;
                case 3:
                  columns = this.rows;
                  rows = this.columns;
                  tmp = x;
                  x = y;
                  y = tmp;
                  y = rows - y - 1;
                  break;
              }
              if (!this.isBicolor) {
                if (columns === 8 && rows === 8) {
                  x += columns - 1;
                  x %= columns;
                }
                if (state) {
                  this.buffer[addr][y] |= 1 << x;
                } else {
                  this.buffer[addr][y] &= ~(1 << x);
                }
              } else {
                if (state === LedControl.COLORS.GREEN) {
                  this.buffer[addr][y] |= 1 << x;
                  this.buffer[addr][y] &= ~(1 << x + 8);
                } else if (state === LedControl.COLORS.YELLOW) {
                  this.buffer[addr][y] |= 1 << x + 8 | 1 << x;
                } else if (state === LedControl.COLORS.RED) {
                  this.buffer[addr][y] |= 1 << x + 8;
                  this.buffer[addr][y] &= ~(1 << x);
                } else {
                  this.buffer[addr][y] &= ~(1 << x) & ~(1 << x + 8);
                }
              }
              this.writeDisplay(addr);
            }
            return this;
          }
        },
        writeDisplay: {
          writable: true,
          value(addr) {
            const bytes = [0];
            for (let i = 0; i < 8; i++) {
              bytes.push(this.buffer[addr][i] & 255);
              bytes.push(this.buffer[addr][i] >> 8);
            }
            this.io.i2cWrite(this.addresses[addr], bytes);
          }
        },
        row: {
          writable: true,
          value(addr, row, val) {
            if (!this.isMatrix) {
              throw new Error("The `row` method is only supported for Matrix devices");
            }
            if (typeof val === "number") {
              val = `0000000000000000${parseInt(val, 10).toString(2)}`.substr(0 - this.columns, this.columns);
            }
            if (arguments.length === 2) {
              val = row;
              row = addr;
              this.each(function(device) {
                this.row(device, row, val);
              });
            } else {
              for (let i = 0; i < this.columns; i++) {
                this.led(addr, row, i, parseInt(val[i], 10));
              }
            }
            return this;
          }
        },
        scanLimit: {
          writable: true,
          value() {
            throw new Error("The `scanLimit` method is not implemented for HT16K33 devices");
          }
        },
        send: {
          writable: true,
          value(addr, opcode, data) {
            if (arguments.length !== 3) {
              throw new Error("The `send` method expects three arguments: device, opcode, data");
            }
            this.io.i2cWrite(this.addresses[addr], [opcode | data]);
            return this;
          }
        },
        sendDigit: {
          writable: true,
          value(addr, index, code) {
            if (code > 0 && code < 255) {
              code = `00000000${code.toString(2)}`.slice(-8).split("");
              code = code.shift() + code.reverse().join("");
              code = parseInt(code, 2);
            }
            this.buffer[addr][index] = code;
            this.writeDisplay(addr);
            return this;
          }
        }
      },
      DEFAULT: {
        OP: {
          value: {}
        },
        initialize: {
          writable: true,
          value({ pins }) {
            this.pins = {
              data: pins.data,
              clock: pins.clock,
              cs: pins.cs || pins.latch
            };
            ["data", "clock", "cs"].forEach(function(pin) {
              this.io.pinMode(this.pins[pin], this.io.MODES.OUTPUT);
            }, this);
            this.digitOrder = -1;
            this.digitOrder = -1;
            for (let device = 0; device < this.devices; device++) {
              if (this.isMatrix) {
                this.send(device, LedControl.OP.DECODING, 0);
              }
              this.send(device, LedControl.OP.BRIGHTNESS, 3);
              this.send(device, LedControl.OP.SCANLIMIT, 7);
              this.send(device, LedControl.OP.SHUTDOWN, 1);
              this.send(device, LedControl.OP.DISPLAYTEST, 0);
              this.clear(device);
              this.on(device);
            }
            return this;
          }
        },
        clear: {
          writable: true,
          value(addr) {
            let offset;
            if (typeof addr === "undefined") {
              this.each(function(device) {
                this.clear(device);
              });
            } else {
              offset = addr * 8;
              for (let i = 0; i < 8; i++) {
                this.memory[offset + i] = 0;
                this.send(addr, i + 1, 0);
              }
            }
            return this;
          }
        },
        sendDigit: {
          writable: true,
          value(addr, index, code) {
            this.send(addr, index + 1, code);
            return this;
          }
        },
        led: {
          writable: true,
          value(addr, row, col, state) {
            let offset;
            let val;
            if (arguments.length === 3) {
              state = col;
              col = row;
              row = addr;
              this.each(function(device) {
                this.led(device, row, col, state);
              });
            } else {
              offset = addr * this.columns;
              val = 128 >> col;
              if (state) {
                this.memory[offset + row] = this.memory[offset + row] | val;
              } else {
                val = ~val;
                this.memory[offset + row] = this.memory[offset + row] & val;
              }
              this.send(addr, row + 1, this.memory[offset + row]);
            }
            return this;
          }
        },
        row: {
          writable: true,
          value(addr, row, val) {
            if (!this.isMatrix) {
              throw new Error("The `row` method is only supported for Matrix devices");
            }
            let offset;
            if (typeof val === "string") {
              val = parseInt(val, 2);
            }
            if (arguments.length === 2) {
              val = row;
              row = addr;
              this.each(function(device) {
                this.row(device, row, val);
              });
            } else {
              offset = addr * this.columns;
              this.memory[offset + row] = val;
              this.send(addr, row + 1, this.memory[offset + row]);
            }
            return this;
          }
        },
        scanLimit: {
          writable: true,
          value(addr, limit) {
            if (arguments.length === 1) {
              limit = addr;
              this.each(function(device) {
                this.scanLimit(device, limit);
              });
            } else {
              this.send(addr, LedControl.OP.SCANLIMIT, limit);
            }
            return this;
          }
        },
        send: {
          writable: true,
          value(addr, opcode, data) {
            if (arguments.length !== 3) {
              throw new Error("`send` expects three arguments: device, opcode, data");
            }
            const offset = addr * 2;
            const maxBytes = this.devices * 2;
            const spiData = [];
            if (addr < this.devices) {
              for (let i = 0; i < maxBytes; i++) {
                spiData[i] = 0;
              }
              spiData[offset + 1] = opcode;
              spiData[offset] = data;
              this.io.digitalWrite(this.pins.cs, this.io.LOW);
              for (let j = maxBytes; j > 0; j--) {
                this.board.shiftOut(this.pins.data, this.pins.clock, spiData[j - 1]);
              }
              this.io.digitalWrite(this.pins.cs, this.io.HIGH);
            }
            return this;
          }
        }
      }
    };
    LedControl.DEFAULTS = {
      DECODING: 0,
      BRIGHTNESS: 3,
      SCANLIMIT: 7,
      SHUTDOWN: 1,
      DISPLAYTEST: 0
    };
    Object.freeze(LedControl.DEFAULTS);
    LedControl.OP = {};
    LedControl.OP.NOOP = 0;
    LedControl.OP.DIGIT0 = 1;
    LedControl.OP.DIGIT1 = 2;
    LedControl.OP.DIGIT2 = 3;
    LedControl.OP.DIGIT3 = 4;
    LedControl.OP.DIGIT4 = 5;
    LedControl.OP.DIGIT5 = 6;
    LedControl.OP.DIGIT6 = 7;
    LedControl.OP.DIGIT7 = 8;
    LedControl.OP.DECODEMODE = 9;
    LedControl.OP.INTENSITY = 10;
    LedControl.OP.SCANLIMIT = 11;
    LedControl.OP.SHUTDOWN = 12;
    LedControl.OP.DISPLAYTEST = 15;
    LedControl.OP.BRIGHTNESS = LedControl.OP.INTENSITY;
    LedControl.OP.DECODING = LedControl.OP.DECODEMODE;
    LedControl.OP.DISPLAY = LedControl.OP.DISPLAYTEST;
    LedControl.OP.POWERDOWN = LedControl.OP.SHUTDOWN;
    Object.freeze(LedControl.OP);
    LedControl.COLORS = {
      RED: 1,
      YELLOW: 2,
      GREEN: 3
    };
    LedControl.DIRECTIONS = {
      UP: 1,
      RIGHT: 2,
      DOWN: 3,
      LEFT: 4,
      1: "UP",
      2: "RIGHT",
      3: "DOWN",
      4: "LEFT"
    };
    Object.freeze(LedControl.DIRECTIONS);
    var digits = [
      [224, 160, 160, 160, 160, 160, 224, 0],
      [64, 192, 64, 64, 64, 64, 224, 0],
      [224, 32, 32, 224, 128, 128, 224, 0],
      [224, 32, 32, 96, 32, 32, 224, 0],
      [32, 96, 160, 224, 32, 32, 32, 0],
      [224, 128, 128, 224, 32, 32, 224, 0],
      [224, 128, 128, 224, 160, 160, 224, 0],
      [224, 32, 32, 32, 32, 32, 32, 0],
      [224, 160, 160, 64, 160, 160, 224, 0],
      [224, 160, 160, 224, 32, 32, 224, 0]
    ];
    var charName = "";
    for (let i = 0; i < 10; i++) {
      for (let k = 0; k < 10; k++) {
        charName = `${i}${k}`;
        ledCharacters.MATRIX_CHARS[charName] = [];
        for (let j = 0; j < 8; j++) {
          ledCharacters.MATRIX_CHARS[charName][j] = digits[i][j] | digits[k][j] >>> 4;
        }
      }
    }
    LedControl.MATRIX_DIMENSIONS = {
      "16x8": {
        rows: 16,
        columns: 8
      },
      "8x16": {
        rows: 8,
        columns: 16
      },
      "8x8": {
        rows: 8,
        columns: 8
      }
    };
    LedControl.MATRIX_CHARS = ledCharacters.MATRIX_CHARS;
    LedControl.DIGIT_CHARS = ledCharacters.DIGIT_CHARS;
    if (!!process.env.IS_TEST_MODE) {
      LedControl.Controllers = Controllers;
      LedControl.purge = () => {
        addresses = new Set([112, 113, 114, 115, 116, 117, 118, 119]);
        priv.clear();
      };
    }
    module2.exports = LedControl;
  }
});

// node_modules/johnny-five/lib/led/matrix.js
var require_matrix = __commonJS({
  "node_modules/johnny-five/lib/led/matrix.js"(exports, module2) {
    var LedControl = require_ledcontrol();
    var Matrix = class extends LedControl {
      constructor(options) {
        options.isMatrix = true;
        super(options);
      }
      static get CHARS() {
        return LedControl.MATRIX_CHARS;
      }
    };
    module2.exports = Matrix;
  }
});

// node_modules/johnny-five/lib/led/digits.js
var require_digits = __commonJS({
  "node_modules/johnny-five/lib/led/digits.js"(exports, module2) {
    var LedControl = require_ledcontrol();
    var Digits = class extends LedControl {
      constructor(options) {
        options.isMatrix = false;
        super(options);
      }
      static get CHARS() {
        return LedControl.DIGIT_CHARS;
      }
    };
    module2.exports = Digits;
  }
});

// node_modules/johnny-five/lib/led/index.js
var require_led2 = __commonJS({
  "node_modules/johnny-five/lib/led/index.js"(exports, module2) {
    var Led = require_led();
    Led.Collection = require_leds();
    Led.RGB = require_rgb();
    Led.RGB.Collection = require_rgbs();
    Led.Matrix = require_matrix();
    Led.Digits = require_digits();
    module2.exports = Led;
  }
});

// node_modules/johnny-five/lib/light.js
var require_light = __commonJS({
  "node_modules/johnny-five/lib/light.js"(exports, module2) {
    var Board = require_board();
    var EVS = require_evshield();
    var Withinable = require_withinable();
    var { uint16, toFixed, scale } = require_fn();
    var priv = new Map();
    var Controllers = {
      DEFAULT: {
        initialize: {
          value(options, callback) {
            this.io.pinMode(this.pin, this.io.MODES.ANALOG);
            this.io.analogRead(this.pin, callback);
          }
        },
        toIntensityLevel: {
          value(value) {
            return toFixed(scale(value, 0, 1023, 0, 100) / 100, 2);
          }
        }
      },
      EVS_EV3: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (options.mode) {
              options.mode = options.mode.toUpperCase();
            }
            state.mode = options.mode === "REFLECTED" ? EVS.Type_EV3_LIGHT_REFLECTED : EVS.Type_EV3_LIGHT;
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_EV3);
            state.ev3.write(state.shield, 129 + state.shield.offset, state.mode);
            state.ev3.read(state.shield, EVS.Light, EVS.Light_Bytes, (data) => {
              const value = data[0] | data[1] << 8;
              callback(value);
            });
          }
        },
        toIntensityLevel: {
          value(value) {
            return toFixed(value / 100, 2);
          }
        }
      },
      EVS_NXT: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            if (options.mode) {
              options.mode = options.mode.toUpperCase();
            }
            state.mode = options.mode === "REFLECTED" ? EVS.Type_NXT_LIGHT_REFLECTED : EVS.Type_NXT_LIGHT;
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, state.mode);
            state.ev3.read(state.shield, state.shield.analog, EVS.Analog_Bytes, (data) => {
              callback(data[0] | data[1] << 8);
            });
          }
        },
        toIntensityLevel: {
          value(value) {
            return toFixed(scale(value, 0, 1023, 100, 0) / 100, 2);
          }
        }
      },
      TSL2561: {
        ADDRESSES: {
          value: [41, 57, 73]
        },
        REGISTER: {
          value: {
            CONTROL: 0,
            TIMING: 1,
            READ: 44
          }
        },
        initialize: {
          value(options, callback) {
            const command = (byte) => byte | 128;
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            this.io.i2cConfig(options);
            this.io.i2cWriteReg(address, command(this.REGISTER.CONTROL), 3);
            const LUX_SCALE = 14;
            const RATIO_SCALE = 9;
            const K1T = 64;
            const B1T = 498;
            const M1T = 446;
            const K2T = 128;
            const B2T = 532;
            const M2T = 721;
            const K3T = 192;
            const B3T = 575;
            const M3T = 891;
            const K4T = 256;
            const B4T = 624;
            const M4T = 1022;
            const K5T = 312;
            const B5T = 367;
            const M5T = 508;
            const K6T = 410;
            const B6T = 210;
            const M6T = 251;
            const K7T = 666;
            const B7T = 24;
            const M7T = 18;
            const K8T = 666;
            const B8T = 0;
            const M8T = 0;
            const GAIN_1X = 0;
            const GAIN_16X = 16;
            const TintMs = [
              13,
              101,
              402
            ];
            const TintDelayMs = [
              15,
              120,
              450
            ];
            const chScales = [
              29975,
              4071,
              65536
            ];
            let gain = GAIN_16X;
            let TintIndex = 0;
            let Tint = TintMs[TintIndex];
            let lux = 0;
            Object.defineProperties(this, {
              gain: {
                get() {
                  return gain;
                },
                set(value) {
                  if (value !== GAIN_1X && value !== GAIN_16X) {
                    throw new RangeError("Invalid gain. Expected one of: 0, 16");
                  }
                  gain = value;
                  this.io.i2cWriteReg(address, command(this.REGISTER.TIMING), TintIndex | gain);
                }
              },
              integration: {
                get() {
                  return Tint;
                },
                set(value) {
                  TintIndex = TintMs.indexOf(value);
                  if (TintIndex === -1) {
                    throw new RangeError("Invalid integration. Expected one of: 13, 101, 402");
                  }
                  Tint = value;
                  this.io.i2cWriteReg(address, command(this.REGISTER.TIMING), TintIndex | gain);
                }
              },
              lux: {
                get() {
                  return lux;
                }
              }
            });
            this.gain = gain;
            this.integration = Tint;
            const read = () => {
              setTimeout(() => {
                this.io.i2cReadOnce(address, command(this.REGISTER.READ), 4, (data) => {
                  let ch0 = uint16(data[1], data[0]);
                  let ch1 = uint16(data[3], data[2]);
                  let b = 0;
                  let m = 0;
                  let chScale = chScales[TintIndex];
                  if (!gain) {
                    chScale = chScale << 4;
                  }
                  ch0 = ch0 * chScale >> 10;
                  ch1 = ch1 * chScale >> 10;
                  let ratio1 = 0;
                  if (ch0) {
                    ratio1 = (ch1 << RATIO_SCALE + 1) / ch0;
                  }
                  ratio1 = Math.round(ratio1);
                  const ratio = ratio1 + 1 >> 1;
                  if (ratio >= 0 && ratio <= K1T) {
                    b = B1T;
                    m = M1T;
                  } else if (ratio <= K2T) {
                    b = B2T;
                    m = M2T;
                  } else if (ratio <= K3T) {
                    b = B3T;
                    m = M3T;
                  } else if (ratio <= K4T) {
                    b = B4T;
                    m = M4T;
                  } else if (ratio <= K5T) {
                    b = B5T;
                    m = M5T;
                  } else if (ratio <= K6T) {
                    b = B6T;
                    m = M6T;
                  } else if (ratio <= K7T) {
                    b = B7T;
                    m = M7T;
                  } else if (ratio > K8T) {
                    b = B8T;
                    m = M8T;
                  }
                  let temp = ch0 * b - ch1 * m;
                  if (temp < 0) {
                    temp = 0;
                  }
                  temp += 1 << LUX_SCALE - 1;
                  lux = temp >>> LUX_SCALE;
                  callback(lux);
                  read();
                });
              }, TintDelayMs[TintIndex]);
            };
            read();
          }
        },
        toLux: {
          value(value) {
            return value;
          }
        },
        toIntensityLevel: {
          value(value) {
            return toFixed(scale(value, 0, 17e3, 0, 100) / 100, 2);
          }
        }
      },
      BH1750: {
        ADDRESSES: {
          value: [35, 92]
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const mode = options.mode || 16;
            this.io.i2cConfig(options);
            this.io.i2cWrite(address, mode);
            const read = () => {
              setTimeout(() => {
                this.io.i2cReadOnce(address, 2, (data) => {
                  callback(uint16(data[0], data[1]));
                  read();
                });
              }, 120);
            };
            read();
          }
        },
        toLux: {
          value(value) {
            return Math.round(value / 1.2);
          }
        },
        toIntensityLevel: {
          value(value) {
            return toFixed(scale(value / 1.2, 0, 65535, 0, 100) / 100, 2);
          }
        }
      }
    };
    Controllers.ALSPT19 = Controllers["ALS-PT19"] = Controllers.DEFAULT;
    var Light = class extends Withinable {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        let value = 0;
        let last = 0;
        let {
          freq = 25
        } = options;
        priv.set(this, {});
        if (!this.toIntensityLevel) {
          this.toIntensityLevel = options.toIntensityLevel || ((x) => x);
        }
        if (!this.toLux) {
          this.toLux = options.toLux || ((x) => x);
        }
        Object.defineProperties(this, {
          value: {
            get() {
              return value;
            }
          },
          level: {
            get() {
              return this.toIntensityLevel(value);
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options, (data2) => value = data2);
        }
        if (typeof this.lux === "undefined") {
          Object.defineProperty(this, "lux", {
            get() {
              return this.toLux(value);
            }
          });
        }
        const data = {
          level: 0,
          lux: 0
        };
        setInterval(() => {
          data.level = this.level;
          data.lux = this.lux;
          this.emit("data", data);
          if (value !== last) {
            last = value;
            this.emit("change", data);
          }
        }, freq);
      }
    };
    if (process.env.IS_TEST_MODE) {
      Light.Controllers = Controllers;
      Light.purge = function() {
        priv.clear();
      };
    }
    module2.exports = Light;
  }
});

// node_modules/johnny-five/lib/joystick.js
var require_joystick = __commonJS({
  "node_modules/johnny-five/lib/joystick.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var { constrain, fscale } = require_fn();
    var priv = new Map();
    var axes = ["x", "y"];
    var Multiplexer = class {
      constructor({ pins, io: io2 }) {
        this.pins = pins;
        this.io = io2;
        this.io.pinMode(this.pins[0], this.io.MODES.OUTPUT);
        this.io.pinMode(this.pins[1], this.io.MODES.OUTPUT);
        this.io.pinMode(this.pins[2], this.io.MODES.OUTPUT);
        this.io.pinMode(this.pins[3], this.io.MODES.OUTPUT);
      }
      select(channel) {
        this.io.digitalWrite(this.pins[0], channel & 1 ? this.io.HIGH : this.io.LOW);
        this.io.digitalWrite(this.pins[1], channel & 2 ? this.io.HIGH : this.io.LOW);
        this.io.digitalWrite(this.pins[2], channel & 4 ? this.io.HIGH : this.io.LOW);
        this.io.digitalWrite(this.pins[3], channel & 8 ? this.io.HIGH : this.io.LOW);
      }
    };
    var Controllers = {
      ANALOG: {
        initialize: {
          value({ pins }, callback) {
            const axisValues = {
              x: null,
              y: null
            };
            pins.forEach((pin, index) => {
              this.io.pinMode(pin, this.io.MODES.ANALOG);
              this.io.analogRead(pin, (value) => {
                axisValues[axes[index]] = value;
                if (axisValues.x !== null && axisValues.y !== null) {
                  callback({
                    x: axisValues.x,
                    y: axisValues.y
                  });
                  axisValues.x = null;
                  axisValues.y = null;
                }
              });
            });
          }
        },
        toAxis: {
          value(raw, axis) {
            const state = priv.get(this);
            return constrain(fscale(raw - state[axis].zeroV, -511, 511, -1, 1), -1, 1);
          }
        }
      },
      ESPLORA: {
        initialize: {
          value(options, callback) {
            const multiplexer = new Multiplexer({
              pins: [18, 19, 20, 21],
              io: this.io
            });
            const channels = [11, 12];
            let index = 1;
            const axisValues = {
              x: null,
              y: null
            };
            this.io.pinMode(4, this.io.MODES.ANALOG);
            const handler = (value) => {
              axisValues[axes[index]] = value;
              if (axisValues.x !== null && axisValues.y !== null) {
                callback({
                  x: axisValues.x,
                  y: axisValues.y
                });
                axisValues.x = null;
                axisValues.y = null;
              }
              this.io.removeListener("analog-read-4", handler);
              setTimeout(read, 10);
            };
            var read = () => {
              multiplexer.select(channels[index ^= 1]);
              this.io.analogRead(4, handler);
            };
            read();
          }
        },
        toAxis: {
          value(raw, axis) {
            const state = priv.get(this);
            return constrain(fscale(raw - state[axis].zeroV, -511, 511, -1, 1), -1, 1);
          }
        }
      }
    };
    Controllers.DEFAULT = Controllers.ANALOG;
    var Joystick2 = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        if (!this.toAxis) {
          this.toAxis = options.toAxis || ((raw) => raw);
        }
        const state = {
          x: {
            invert: false,
            value: 0,
            previous: 0,
            zeroV: 0,
            calibrated: false
          },
          y: {
            invert: false,
            value: 0,
            previous: 0,
            zeroV: 0,
            calibrated: false
          }
        };
        state.x.zeroV = options.zeroV === void 0 ? 0 : options.zeroV.x || 0;
        state.y.zeroV = options.zeroV === void 0 ? 0 : options.zeroV.y || 0;
        state.x.invert = options.invertX || options.invert || false;
        state.y.invert = options.invertY || options.invert || false;
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => {
            let isChange = false;
            const computed = {
              x: null,
              y: null
            };
            Object.keys(data).forEach((axis) => {
              const value = data[axis];
              const sensor = state[axis];
              sensor.value = value;
              if (!state[axis].calibrated) {
                state[axis].calibrated = true;
                state[axis].zeroV = value;
                isChange = true;
              }
              computed[axis] = this[axis];
              const absAxis = Math.abs(computed[axis]);
              const absPAxis = Math.abs(sensor.previous);
              if (absAxis < absPAxis || absAxis > absPAxis) {
                isChange = true;
              }
              sensor.previous = computed[axis];
            });
            this.emit("data", {
              x: computed.x,
              y: computed.y
            });
            if (isChange) {
              this.emit("change", {
                x: computed.x,
                y: computed.y
              });
            }
          });
        }
        Object.defineProperties(this, {
          x: {
            get() {
              return this.toAxis(state.x.value, "x") * (state.x.invert ? -1 : 1);
            }
          },
          y: {
            get() {
              return this.toAxis(state.y.value, "y") * (state.y.invert ? -1 : 1);
            }
          }
        });
      }
    };
    if (!!process.env.IS_TEST_MODE) {
      Joystick2.Controllers = Controllers;
      Joystick2.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Joystick2;
  }
});

// node_modules/johnny-five/lib/motion.js
var require_motion = __commonJS({
  "node_modules/johnny-five/lib/motion.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var Emitter = require_emitter();
    var priv = new Map();
    function analogInitializer({ pin }, dataHandler) {
      const state = priv.get(this);
      this.io.pinMode(pin, this.io.MODES.ANALOG);
      setTimeout(() => {
        state.isCalibrated = true;
        this.emit("calibrated");
      }, 10);
      this.io.analogRead(pin, dataHandler);
    }
    var initialize = {
      value: analogInitializer
    };
    var Controllers = {
      PIR: {
        initialize: {
          value(options, dataHandler) {
            const state = priv.get(this);
            const calibrationDelay = typeof options.calibrationDelay !== "undefined" ? options.calibrationDelay : 2e3;
            this.io.pinMode(options.pin, this.io.MODES.INPUT);
            setTimeout(() => {
              state.isCalibrated = true;
              this.emit("calibrated");
            }, calibrationDelay);
            this.io.digitalRead(options.pin, dataHandler);
          }
        },
        toBoolean: {
          value(raw) {
            return !!raw;
          }
        }
      },
      GP2Y0D805Z0F: {
        ADDRESSES: {
          value: [38]
        },
        initialize: {
          value(options, dataHandler) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            setTimeout(() => {
              state.isCalibrated = true;
              this.emit("calibrated");
            }, 10);
            this.io.i2cConfig(options);
            this.io.i2cWriteReg(address, 3, 254);
            this.io.i2cWrite(address, [0]);
            this.io.i2cRead(address, 1, (data) => {
              dataHandler(data[0] & 2);
            });
          }
        },
        toBoolean: {
          value(raw) {
            return raw === 0;
          }
        }
      },
      GP2Y0D810Z0F: {
        initialize,
        toBoolean: {
          value(raw) {
            return raw >> 9 === 0;
          }
        }
      },
      GP2Y0A60SZLF: {
        initialize,
        toBoolean: {
          value(raw) {
            return raw >> 9 === 1;
          }
        }
      }
    };
    Controllers.GP2Y0D815Z0F = Controllers.GP2Y0D810Z0F;
    Controllers["HC-SR501"] = Controllers.PIR;
    Controllers["HCSR501"] = Controllers.PIR;
    Controllers["0D805"] = Controllers.GP2Y0D805Z0F;
    Controllers["805"] = Controllers.GP2Y0D805Z0F;
    Controllers["0D810"] = Controllers.GP2Y0D810Z0F;
    Controllers["810"] = Controllers.GP2Y0D810Z0F;
    Controllers["0D815"] = Controllers.GP2Y0D815Z0F;
    Controllers["815"] = Controllers.GP2Y0D815Z0F;
    Controllers["0A60SZLF"] = Controllers.GP2Y0A60SZLF;
    Controllers["60SZLF"] = Controllers.GP2Y0A60SZLF;
    Controllers.DEFAULT = Controllers.PIR;
    var Motion = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        let last = false;
        const freq = options.freq || 25;
        const state = {
          value: false,
          isCalibrated: false
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          detectedMotion: {
            get() {
              return this.toBoolean(state.value);
            }
          },
          isCalibrated: {
            get() {
              return state.isCalibrated;
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options, (data) => state.value = data);
        }
        setInterval(() => {
          let isChange = false;
          const eventData = {
            timestamp: Date.now(),
            detectedMotion: this.detectedMotion,
            isCalibrated: state.isCalibrated
          };
          if (state.isCalibrated && this.detectedMotion && !last) {
            this.emit("motionstart", eventData);
          }
          if (state.isCalibrated && !this.detectedMotion && last) {
            this.emit("motionend", eventData);
          }
          if (last !== this.detectedMotion) {
            isChange = true;
          }
          this.emit("data", eventData);
          if (isChange) {
            this.emit("change", eventData);
          }
          last = this.detectedMotion;
        }, freq);
      }
    };
    Motion.Collection = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Motion;
      }
    };
    Collection.installMethodForwarding(Motion.Collection.prototype, Motion.prototype);
    if (!!process.env.IS_TEST_MODE) {
      Motion.Controllers = Controllers;
      Motion.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Motion;
  }
});

// node_modules/johnny-five/lib/sensor.js
var require_sensor = __commonJS({
  "node_modules/johnny-five/lib/sensor.js"(exports, module2) {
    var Board = require_board();
    var Fn = require_fn();
    var Collection = require_collection();
    var Withinable = require_withinable();
    var priv = new Map();
    function median(input) {
      const sorted = input.sort((a, b) => a - b);
      const len = sorted.length;
      const half = Math.floor(len / 2);
      return len % 2 ? sorted[half] : (sorted[half - 1] + sorted[half]) / 2;
    }
    var Sensor = class extends Withinable {
      constructor(options) {
        super();
        let resolution = 1023;
        let raw = null;
        let last = -1;
        const samples = [];
        Board.Component.call(this, options = Board.Options(options));
        if (!options.type) {
          options.type = "analog";
        }
        if (this.io.RESOLUTION && (this.io.RESOLUTION.ADC && this.io.RESOLUTION.ADC !== resolution)) {
          resolution = this.io.RESOLUTION.ADC;
        }
        this.mode = options.type === "digital" ? this.io.MODES.INPUT : this.io.MODES.ANALOG;
        this.io.pinMode(this.pin, this.mode);
        const state = {
          enabled: typeof options.enabled === "undefined" ? true : options.enabled,
          booleanBarrier: options.type === "digital" ? 0 : null,
          intervalId: null,
          scale: null,
          value: 0,
          median: 0,
          freq: options.freq || 25,
          previousFreq: options.freq || 25
        };
        priv.set(this, state);
        this.range = options.range || [0, resolution];
        this.limit = options.limit || null;
        this.threshold = options.threshold === void 0 ? 1 : options.threshold;
        this.isScaled = false;
        this.io[`${options.type}Read`](this.pin, (data) => {
          raw = data;
          if (options.type !== "digital") {
            samples.push(raw);
          }
        });
        const eventProcessing = () => {
          let err;
          let boundary;
          err = null;
          if (options.type === "digital") {
            this.emit("data", raw);
            if (last !== raw) {
              this.emit("change", raw);
              last = raw;
            }
            return;
          }
          if (samples.length > 0) {
            state.median = median(samples);
          }
          const roundMedian = Math.round(state.median);
          this.emit("data", roundMedian);
          if (state.median <= last - this.threshold || state.median >= last + this.threshold) {
            this.emit("change", roundMedian);
            last = state.median;
          }
          if (this.limit) {
            if (state.median <= this.limit[0]) {
              boundary = "lower";
            }
            if (state.median >= this.limit[1]) {
              boundary = "upper";
            }
            if (boundary) {
              this.emit("limit", {
                boundary,
                value: roundMedian
              });
              this.emit(`limit:${boundary}`, roundMedian);
            }
          }
          samples.length = 0;
        };
        Object.defineProperties(this, {
          raw: {
            get() {
              return raw;
            }
          },
          analog: {
            get() {
              if (options.type === "digital") {
                return raw;
              }
              return raw === null ? 0 : Fn.map(this.raw, 0, resolution, 0, 255) | 0;
            }
          },
          constrained: {
            get() {
              if (options.type === "digital") {
                return raw;
              }
              return raw === null ? 0 : Fn.constrain(this.raw, 0, 255);
            }
          },
          boolean: {
            get() {
              const state2 = priv.get(this);
              let booleanBarrier = state2.booleanBarrier;
              const scale = state2.scale || [0, resolution];
              if (booleanBarrier === null) {
                booleanBarrier = scale[0] + (scale[1] - scale[0]) / 2;
              }
              return this.value > booleanBarrier;
            }
          },
          scaled: {
            get() {
              let mapped;
              let constrain;
              if (state.scale && raw !== null) {
                if (options.type === "digital") {
                  return state.scale[raw];
                }
                mapped = Fn.fmap(raw, this.range[0], this.range[1], state.scale[0], state.scale[1]);
                constrain = Fn.constrain(mapped, state.scale[0], state.scale[1]);
                return constrain;
              }
              return this.constrained;
            }
          },
          freq: {
            get() {
              return state.freq;
            },
            set(newFreq) {
              state.freq = newFreq;
              if (state.intervalId) {
                clearInterval(state.intervalId);
              }
              if (state.freq !== null) {
                state.intervalId = setInterval(eventProcessing, newFreq);
              }
            }
          },
          value: {
            get() {
              if (state.scale) {
                this.isScaled = true;
                return this.scaled;
              }
              return raw;
            }
          },
          resolution: {
            get() {
              return resolution;
            }
          }
        });
        if (!!process.env.IS_TEST_MODE) {
          Object.defineProperties(this, {
            state: {
              get() {
                return priv.get(this);
              }
            }
          });
        }
        if (state.enabled) {
          this.freq = state.freq;
        }
      }
      enable() {
        const state = priv.get(this);
        if (!state.enabled) {
          this.freq = state.freq || state.previousFreq;
        }
        return this;
      }
      disable() {
        const state = priv.get(this);
        if (state.enabled) {
          state.enabled = false;
          state.previousFreq = state.freq;
          this.freq = null;
        }
        return this;
      }
      scale(low, high) {
        this.isScaled = true;
        priv.get(this).scale = Array.isArray(low) ? low : [low, high];
        return this;
      }
      scaleTo(low, high) {
        const scale = Array.isArray(low) ? low : [low, high];
        return Fn.map(this.raw, 0, this.resolution, scale[0], scale[1]);
      }
      fscaleTo(low, high) {
        const scale = Array.isArray(low) ? low : [low, high];
        return Fn.fmap(this.raw, 0, this.resolution, scale[0], scale[1]);
      }
      booleanAt(barrier) {
        priv.get(this).booleanBarrier = barrier;
        return this;
      }
    };
    var Sensors = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Sensor;
      }
    };
    Collection.installMethodForwarding(Sensors.prototype, Sensor.prototype);
    Sensor.Collection = Sensors;
    if (!!process.env.IS_TEST_MODE) {
      Sensor.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Sensor;
  }
});

// node_modules/johnny-five/lib/shiftregister.js
var require_shiftregister = __commonJS({
  "node_modules/johnny-five/lib/shiftregister.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var priv = new Map();
    var encoded = {
      cathode: [63, 6, 91, 79, 102, 109, 125, 7, 127, 103],
      anode: [64, 121, 36, 48, 25, 18, 2, 120, 0, 24]
    };
    var ShiftRegister = class {
      constructor(opts) {
        if (!(this instanceof ShiftRegister)) {
          return new ShiftRegister(opts);
        }
        if (Array.isArray(opts)) {
          opts = {
            pins: {
              data: opts[0],
              clock: opts[1],
              latch: opts[2],
              reset: opts.length === 4 ? opts[3] : null
            }
          };
        } else if (typeof opts.pins === "object" && Array.isArray(opts.pins)) {
          opts.pins = {
            data: opts.pins[0],
            clock: opts.pins[1],
            latch: opts.pins[2],
            reset: opts.pins.length === 4 ? opts.pins[3] : null
          };
        }
        Board.Component.call(this, opts = Board.Options(opts));
        this.size = opts.size || 1;
        this.pins.reset = typeof opts.pins.reset !== "undefined" ? opts.pins.reset : null;
        const isAnode = typeof opts.isAnode !== "undefined" ? opts.isAnode : false;
        const clear = isAnode ? 255 : 0;
        const state = {
          isAnode,
          value: new Array(this.size).fill(clear),
          encoded: encoded[isAnode ? "anode" : "cathode"],
          clear
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          isAnode: {
            get() {
              return isAnode;
            }
          },
          value: {
            get() {
              return state.value;
            }
          }
        });
      }
      display(value) {
        const state = priv.get(this);
        let chars;
        if (typeof value === "number") {
          return this.display(String(value));
        }
        if (typeof value === "string") {
          const matches = value.match(/([0-9]{1}\.*)/g);
          if (matches && matches.length) {
            chars = matches.map((char) => {
              if (char.length === 1) {
                return state.encoded[char] | 1 << 7;
              }
              return state.encoded[char[0]];
            });
          }
        }
        this.send(chars);
        state.value = chars;
        return this;
      }
      send(value) {
        const state = priv.get(this);
        let args = Array.from(arguments);
        if (args.length === 1) {
          args = [value];
        }
        if (Array.isArray(value)) {
          args = value;
        }
        this.io.digitalWrite(this.pins.latch, this.io.LOW);
        args.forEach(function(arg) {
          if (typeof arg === "string") {
            arg = arg.charCodeAt(0);
          }
          if (this.isAnode && (arg !== 255 && !state.encoded.includes(arg) && !state.encoded.includes(arg & ~(1 << 7)))) {
            const index = encoded.anode.findIndex((value2) => value2 === arg);
            if (index !== -1) {
              arg = encoded.cathode[index];
            }
          }
          this.board.shiftOut(this.pins.data, this.pins.clock, true, arg);
        }, this);
        this.io.digitalWrite(this.pins.latch, this.io.HIGH);
        state.value = args;
        return this;
      }
      clear() {
        const state = priv.get(this);
        return this.send(Array(this.size).fill(state.clear));
      }
      reset() {
        if (this.pins.reset === null) {
          throw new Error("ShiftRegister was not initialized with a reset pin");
        }
        this.io.digitalWrite(this.pins.clock, this.io.LOW);
        this.io.digitalWrite(this.pins.reset, this.io.LOW);
        this.io.digitalWrite(this.pins.clock, this.io.HIGH);
        this.io.digitalWrite(this.pins.reset, this.io.HIGH);
        return this;
      }
    };
    var ShiftRegisters = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return ShiftRegister;
      }
    };
    Collection.installMethodForwarding(ShiftRegisters.prototype, ShiftRegister.prototype);
    Collection.installMethodForwarding(ShiftRegisters.prototype, ShiftRegister.prototype);
    ShiftRegister.Collection = ShiftRegisters;
    if (!!process.env.IS_TEST_MODE) {
      ShiftRegister.purge = () => {
        priv.clear();
      };
    }
    module2.exports = ShiftRegister;
  }
});

// node_modules/johnny-five/lib/motor.js
var require_motor = __commonJS({
  "node_modules/johnny-five/lib/motor.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var Emitter = require_emitter();
    var EVS = require_evshield();
    var Expander = require_expander();
    var Fn = require_fn();
    var Sensor = require_sensor();
    var ShiftRegister = require_shiftregister();
    var priv = new Map();
    var registers = new Map();
    function registerKey(registerOpts) {
      return ["clock", "data", "latch"].reduce((accum, key) => `${accum}.${registerOpts[key]}`, "");
    }
    function latch(state, bit, on) {
      return on ? state |= 1 << bit : state &= ~(1 << bit);
    }
    function updateShiftRegister(motor, dir) {
      const rKey = registerKey(motor.settings.register);
      const register = registers.get(motor.board)[rKey];
      let latchState = register.value;
      const bits = priv.get(motor).bits;
      const forward = dir !== "reverse";
      latchState = latch(latchState, bits.a, forward);
      latchState = latch(latchState, bits.b, !forward);
      if (register.value !== latchState) {
        register.send(latchState);
      }
    }
    var Controllers = {
      DEFAULT: {},
      ShiftRegister: {
        initialize: {
          value({ register, bits }) {
            const rKey = registerKey(register);
            if (!bits || bits.a === void 0 || bits.b === void 0) {
              throw new Error("ShiftRegister Motors MUST contain HBRIDGE bits {a, b}");
            }
            priv.get(this).bits = bits;
            if (!registers.has(this.board)) {
              registers.set(this.board, {});
            }
            if (!registers.get(this.board)[rKey]) {
              registers.get(this.board)[rKey] = new ShiftRegister({
                board: this.board,
                pins: register
              });
            }
            this.io.pinMode(this.pins.pwm, this.io.MODES.PWM);
          }
        },
        dir: {
          value(dir) {
            this.stop();
            updateShiftRegister(this, dir.name);
            this.direction = dir;
            process.nextTick(() => this.emit(dir.name));
            return this;
          }
        }
      },
      PCA9685: {
        initialize: {
          value({ address, pwmRange, frequency }) {
            const state = priv.get(this);
            this.address = address || 64;
            this.pwmRange = pwmRange || [0, 4080];
            this.frequency = frequency || 50;
            state.expander = Expander.get({
              address: this.address,
              controller: this.controller,
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            Object.keys(this.pins).forEach((pinName) => {
              this.pins[pinName] = state.expander.normalize(this.pins[pinName]);
            });
          }
        },
        setPWM: {
          writable: true,
          value(pin, speed) {
            priv.get(this).expander.analogWrite(pin, speed);
          }
        },
        setPin: {
          writable: true,
          value(pin, value) {
            priv.get(this).expander.digitalWrite(pin, value);
          }
        }
      },
      PCA9685_Hybrid: {
        initialize: {
          value({ address, pwmRange, frequency }) {
            const state = priv.get(this);
            this.address = address || 64;
            this.pwmRange = pwmRange || [0, 4080];
            this.frequency = frequency || 50;
            state.expander = Expander.get({
              address: this.address,
              controller: "PCA9685",
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            this.pins.pwm = state.expander.normalize(this.pins.pwm);
          }
        },
        setPWM: {
          writable: true,
          value(pin, speed) {
            priv.get(this).expander.analogWrite(pin, speed);
          }
        }
      },
      EVS_EV3: {
        initialize: {
          value(options) {
            const state = priv.get(this);
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            this.settings.pins = {
              pwm: options.pin,
              dir: options.pin
            };
          }
        },
        setPWM: {
          value(pin, value) {
            const state = priv.get(this);
            const register = state.shield.motor === EVS.M1 ? EVS.SPEED_M1 : EVS.SPEED_M2;
            let speed = Fn.scale(value, 0, 255, 0, 100) | 0;
            if (value === 0) {
              state.ev3.write(state.shield, EVS.COMMAND, EVS.Motor_Reset);
            } else {
              if (!this.direction.value) {
                speed = -speed;
              }
              const data = [
                speed,
                0,
                0,
                EVS.CONTROL_SPEED | EVS.CONTROL_GO
              ];
              state.ev3.write(state.shield, register, data);
            }
          }
        },
        setPin: {
          value(pin, value) {
            this.setPWM(this.pin, value);
          }
        },
        validatePins: {
          value() {
            if (typeof this.settings.pin === "undefined") {
              throw new Error("Pin must be defined");
            }
          }
        }
      },
      GROVE_I2C_MOTOR_DRIVER: {
        REGISTER: {
          value: {
            ADDRESS: 15
          }
        },
        COMMANDS: {
          value: {
            SET_SPEED: 130,
            SET_PWM_FREQUENCY: 132,
            SET_DIRECTION: 170,
            NOOP: 1
          }
        },
        initialize: {
          value(options) {
            const state = priv.get(this);
            let shared = priv.get("GROVE_I2C_MOTOR_DRIVER");
            if (!shared) {
              shared = {
                direction: {
                  A: 1,
                  B: 1
                },
                speed: {
                  A: 0,
                  B: 0
                }
              };
              priv.set("GROVE_I2C_MOTOR_DRIVER", shared);
            }
            state.shared = shared;
            state.pin = options.pin.toUpperCase();
            this.settings.pins = {
              pwm: options.pin,
              dir: options.pin
            };
            this.address = options.address || this.REGISTER.ADDRESS;
            options.address = this.address;
            this.io.i2cConfig(options);
          }
        },
        setPWM: {
          value(pin, value) {
            const state = priv.get(this);
            const speed = Board.constrain(value, 0, 255) | 0;
            state.shared.speed[state.pin] = speed;
            this.io.i2cWrite(this.address, [
              this.COMMANDS.SET_SPEED,
              state.shared.speed.A,
              state.shared.speed.B
            ]);
          }
        },
        setPin: {
          value(pin, value) {
            const state = priv.get(this);
            state.shared.direction[state.pin] = value ? 1 : 2;
            const a = state.shared.direction.A & 3;
            const b = state.shared.direction.B & 3;
            const direction = b << 2 | a;
            this.io.i2cWrite(this.address, [
              this.COMMANDS.SET_DIRECTION,
              direction,
              this.COMMANDS.NOOP
            ]);
          }
        },
        validatePins: {
          value() {
            if (typeof this.settings.pin === "undefined") {
              throw new Error("Pin must be defined");
            }
          }
        }
      }
    };
    Controllers.EVS_NXT = Controllers.EVS_EV3;
    var Devices = {
      NONDIRECTIONAL: {
        pins: {
          get() {
            if (this.settings.pin) {
              return {
                pwm: this.settings.pin
              };
            } else {
              return this.settings.pins || {};
            }
          }
        },
        dir: {
          writable: true,
          configurable: true,
          value(speed) {
            speed = speed || this.speed();
            return this;
          }
        },
        resume: {
          value() {
            const speed = this.speed();
            this.speed({
              speed
            });
            return this;
          }
        }
      },
      DIRECTIONAL: {
        pins: {
          get() {
            if (Array.isArray(this.settings.pins)) {
              return {
                pwm: this.settings.pins[0],
                dir: this.settings.pins[1]
              };
            } else {
              return this.settings.pins;
            }
          }
        },
        dir: {
          writable: true,
          configurable: true,
          value(dir) {
            this.stop();
            this.setPin(this.pins.dir, dir.value);
            this.direction = dir;
            process.nextTick(() => this.emit(dir.name));
            return this;
          }
        }
      },
      CDIR: {
        pins: {
          get() {
            if (Array.isArray(this.settings.pins)) {
              return {
                pwm: this.settings.pins[0],
                dir: this.settings.pins[1],
                cdir: this.settings.pins[2]
              };
            } else {
              return this.settings.pins;
            }
          }
        },
        dir: {
          value(dir) {
            this.stop();
            this.direction = dir;
            this.setPin(this.pins.cdir, 1 ^ dir.value);
            this.setPin(this.pins.dir, dir.value);
            process.nextTick(() => this.emit(dir.name));
            return this;
          }
        },
        brake: {
          value(duration) {
            this.speed({
              speed: 0,
              saveSpeed: false
            });
            this.setPin(this.pins.dir, 1, 127);
            this.setPin(this.pins.cdir, 1, 128, 127);
            this.speed({
              speed: 255,
              saveSpeed: false,
              braking: true
            });
            process.nextTick(() => this.emit("brake"));
            if (duration) {
              this.board.wait(duration, () => this.stop());
            }
            return this;
          }
        }
      }
    };
    var Motor = class extends Emitter {
      constructor(options) {
        super();
        var device, controller, state;
        Board.Component.call(this, options = Board.Options(options));
        this.settings = options;
        if (typeof this.settings.device === "undefined") {
          this.settings.device = "DIRECTIONAL";
          if (typeof this.settings.pins === "undefined" && typeof this.settings.register !== "object") {
            this.settings.device = "NONDIRECTIONAL";
          }
          if (this.settings.pins) {
            if (Array.isArray(this.settings.pins)) {
              this.settings.device = ["NONDIRECTIONAL", "DIRECTIONAL", "CDIR"][this.settings.pins.length - 1];
            } else {
              if (typeof this.settings.pins.dir === "undefined") {
                this.settings.device = "NONDIRECTIONAL";
              } else {
                this.settings.device = "DIRECTIONAL";
              }
              if (typeof this.settings.pins.cdir !== "undefined") {
                this.settings.device = "CDIR";
              }
            }
          }
        }
        if (typeof this.settings.controller === "string" && (this.settings.controller.startsWith("EVS") || this.settings.controller.startsWith("GROVE_I2C"))) {
          this.settings.device = "DIRECTIONAL";
        }
        device = typeof this.settings.device === "string" ? Devices[this.settings.device] : this.settings.device;
        this.threshold = typeof this.settings.threshold !== "undefined" ? this.settings.threshold : 30;
        this.invertPWM = typeof this.settings.invertPWM !== "undefined" ? this.settings.invertPWM : false;
        Object.defineProperties(this, device);
        if (this.settings.register) {
          this.settings.controller = "ShiftRegister";
        }
        if (this.settings.controller) {
          controller = typeof this.settings.controller === "string" ? Controllers[this.settings.controller] : this.settings.controller;
          Board.Controller.call(this, Controllers, options);
        }
        if (this.settings.current) {
          this.settings.current.board = this.board;
          this.current = new Sensor(this.settings.current);
        }
        state = {
          isOn: false,
          currentSpeed: typeof this.settings.speed !== "undefined" ? this.settings.speed : 128,
          braking: false,
          enabled: false
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          isOn: {
            get: function() {
              return state.isOn;
            }
          },
          currentSpeed: {
            get: function() {
              return state.currentSpeed;
            }
          },
          braking: {
            get: function() {
              return state.braking;
            }
          },
          enabled: {
            get: function() {
              return state.enabled;
            }
          }
        });
        this.direction = {
          value: 1
        };
        if (this.initialize) {
          this.initialize(options);
        }
        this.validatePins();
        this.enable();
        this.dir(this.direction);
      }
    };
    Motor.prototype.initialize = function() {
      this.io.pinMode(this.pins.pwm, this.io.MODES.PWM);
      ["dir", "cdir", "brake", "enable"].forEach((pin) => {
        if (typeof this.pins[pin] !== "undefined") {
          this.io.pinMode(this.pins[pin], this.io.MODES.OUTPUT);
        }
      });
    };
    Motor.prototype.setPin = function(pin, value) {
      this.io.digitalWrite(pin, value);
    };
    Motor.prototype.setPWM = function(pin, value) {
      this.io.analogWrite(pin, Fn.map(value, 0, 255, 0, this.board.RESOLUTION.PWM));
    };
    Motor.prototype.speed = function(options) {
      var state = priv.get(this);
      if (typeof options === "undefined") {
        return state.currentSpeed;
      } else {
        if (typeof options === "number") {
          options = {
            speed: options
          };
        }
        options.speed = Board.constrain(options.speed, 0, 255);
        options.saveSpeed = typeof options.saveSpeed !== "undefined" ? options.saveSpeed : true;
        if (options.speed < this.threshold) {
          options.speed = 0;
        }
        state.isOn = options.speed === 0 ? false : true;
        if (options.saveSpeed) {
          state.currentSpeed = options.speed;
        }
        if (options.braking) {
          state.braking = true;
        }
        if (this.invertPWM && this.direction.value === 1) {
          options.speed ^= 255;
        }
        this.setPWM(this.pins.pwm, options.speed);
        return this;
      }
    };
    Motor.prototype.start = function(speed) {
      if (this.pins.brake && this.braking) {
        this.setPin(this.pins.brake, 0);
      }
      speed = typeof speed !== "undefined" ? speed : this.speed();
      this.speed({
        speed,
        braking: false
      });
      if (speed > 0) {
        process.nextTick(() => this.emit("start"));
      }
      return this;
    };
    Motor.prototype.stop = function() {
      this.speed({
        speed: 0,
        saveSpeed: false
      });
      process.nextTick(() => this.emit("stop"));
      return this;
    };
    Motor.prototype.brake = function(duration) {
      if (typeof this.pins.brake === "undefined") {
        if (this.board.io.name !== "Mock") {
          console.log("Non-braking motor type");
        }
        this.stop();
      } else {
        this.setPin(this.pins.brake, 1);
        this.setPin(this.pins.dir, 1);
        this.speed({
          speed: 255,
          saveSpeed: false,
          braking: true
        });
        process.nextTick(() => this.emit("brake"));
        if (duration) {
          var motor = this;
          this.board.wait(duration, function() {
            motor.resume();
          });
        }
      }
      return this;
    };
    Motor.prototype.release = function() {
      this.resume();
      process.nextTick(() => this.emit("release"));
      return this;
    };
    Motor.prototype.resume = function() {
      var speed = this.speed();
      this.dir(this.direction);
      this.start(speed);
      return this;
    };
    Motor.prototype.enable = function() {
      var state = priv.get(this);
      if (typeof this.pins.enable !== "undefined" && !state.enabled) {
        this.setPin(this.pins.enable, 1);
        state.enabled = true;
      }
    };
    Motor.prototype.disable = function() {
      var state = priv.get(this);
      if (typeof this.pins.enable !== "undefined" && state.enabled) {
        this.setPin(this.pins.enable, 0);
        state.enabled = false;
      }
    };
    Motor.prototype.validatePins = function() {
      if (typeof this.pins.pwm === "undefined") {
        throw new Error("PWM pin must be defined");
      }
      if (typeof this.pins.dir === "undefined" && this.settings.device !== "NONDIRECTIONAL") {
        throw new Error("DIR pin must be defined");
      }
      if (this.settings.device === "CDIR" && typeof this.pins.cdir === "undefined") {
        throw new Error("CDIR pin must be defined for three wire motors");
      }
    };
    [
      {
        name: "forward",
        abbr: "fwd",
        value: 1
      },
      {
        name: "reverse",
        abbr: "rev",
        value: 0
      }
    ].forEach((dir) => {
      Motor.prototype[dir.name] = Motor.prototype[dir.abbr] = function(speed) {
        this.dir(dir);
        this.start(speed);
        return this;
      };
    });
    Motor.SHIELD_CONFIGS = {
      ADAFRUIT_V1: {
        M1: {
          pins: {
            pwm: 11
          },
          register: {
            data: 8,
            clock: 4,
            latch: 12
          },
          bits: {
            a: 2,
            b: 3
          }
        },
        M2: {
          pins: {
            pwm: 3
          },
          register: {
            data: 8,
            clock: 4,
            latch: 12
          },
          bits: {
            a: 1,
            b: 4
          }
        },
        M3: {
          pins: {
            pwm: 6
          },
          register: {
            data: 8,
            clock: 4,
            latch: 12
          },
          bits: {
            a: 5,
            b: 7
          }
        },
        M4: {
          pins: {
            pwm: 5
          },
          register: {
            data: 8,
            clock: 4,
            latch: 12
          },
          bits: {
            a: 0,
            b: 6
          }
        }
      },
      ADAFRUIT_V2: {
        M1: {
          pins: {
            pwm: 8,
            dir: 9,
            cdir: 10
          },
          address: 96,
          controller: "PCA9685"
        },
        M2: {
          pins: {
            pwm: 13,
            dir: 12,
            cdir: 11
          },
          address: 96,
          controller: "PCA9685"
        },
        M3: {
          pins: {
            pwm: 2,
            dir: 3,
            cdir: 4
          },
          address: 96,
          controller: "PCA9685"
        },
        M4: {
          pins: {
            pwm: 7,
            dir: 6,
            cdir: 5
          },
          address: 96,
          controller: "PCA9685"
        }
      },
      SEEED_STUDIO: {
        A: {
          pins: {
            pwm: 9,
            dir: 8,
            cdir: 11
          }
        },
        B: {
          pins: {
            pwm: 10,
            dir: 12,
            cdir: 13
          }
        }
      },
      FREETRONICS_HBRIDGE: {
        A: {
          pins: {
            pwm: 6,
            dir: 4,
            cdir: 7
          }
        },
        B: {
          pins: {
            pwm: 5,
            dir: 3,
            cdir: 2
          }
        }
      },
      ARDUINO_MOTOR_SHIELD_R3_1: {
        A: {
          pins: {
            pwm: 3,
            dir: 12
          }
        },
        B: {
          pins: {
            pwm: 11,
            dir: 13
          }
        }
      },
      ARDUINO_MOTOR_SHIELD_R3_2: {
        A: {
          pins: {
            pwm: 3,
            dir: 12,
            brake: 9
          }
        },
        B: {
          pins: {
            pwm: 11,
            dir: 13,
            brake: 8
          }
        }
      },
      ARDUINO_MOTOR_SHIELD_R3_3: {
        A: {
          pins: {
            pwm: 3,
            dir: 12,
            brake: 9,
            current: "A0"
          }
        },
        B: {
          pins: {
            pwm: 11,
            dir: 13,
            brake: 8,
            current: "A1"
          }
        }
      },
      DF_ROBOT: {
        A: {
          pins: {
            pwm: 6,
            dir: 7
          }
        },
        B: {
          pins: {
            pwm: 5,
            dir: 4
          }
        }
      },
      NKC_ELECTRONICS_KIT: {
        A: {
          pins: {
            pwm: 9,
            dir: 12
          }
        },
        B: {
          pins: {
            pwm: 10,
            dir: 13
          }
        }
      },
      RUGGED_CIRCUITS: {
        A: {
          pins: {
            pwm: 3,
            dir: 12
          }
        },
        B: {
          pins: {
            pwm: 11,
            dir: 13
          }
        }
      },
      SPARKFUN_ARDUMOTO: {
        A: {
          pins: {
            pwm: 3,
            dir: 12
          }
        },
        B: {
          pins: {
            pwm: 11,
            dir: 13
          }
        }
      },
      POLOLU_DRV8835_SHIELD: {
        M1: {
          pins: {
            pwm: 9,
            dir: 7
          }
        },
        M2: {
          pins: {
            pwm: 10,
            dir: 8
          }
        }
      },
      POLOLU_VNH5019_SHIELD: {
        M1: {
          pins: {
            pwm: 9,
            dir: 2,
            cdir: 4,
            enable: 6
          }
        },
        M2: {
          pins: {
            pwm: 10,
            dir: 7,
            cdir: 8,
            enable: 12
          }
        }
      },
      MICRO_MAGICIAN_V2: {
        A: {
          pins: {
            pwm: 6,
            dir: 8
          },
          invertPWM: true
        },
        B: {
          pins: {
            pwm: 5,
            dir: 7
          },
          invertPWM: true
        }
      },
      SPARKFUN_LUDUS: {
        A: {
          pins: {
            pwm: 3,
            dir: 4,
            cdir: 5
          }
        },
        B: {
          pins: {
            pwm: 6,
            dir: 7,
            cdir: 8
          }
        }
      },
      SPARKFUN_DUAL_HBRIDGE_EDISON_BLOCK: {
        A: {
          pins: {
            pwm: 20,
            dir: 33,
            cdir: 46,
            enable: 47
          }
        },
        B: {
          pins: {
            pwm: 14,
            dir: 48,
            cdir: 36,
            enable: 47
          }
        }
      },
      PICAR_V: {
        A: {
          controller: "PCA9685_Hybrid",
          pins: {
            pwm: 4,
            dir: "GPIO17"
          }
        },
        B: {
          controller: "PCA9685_Hybrid",
          pins: {
            pwm: 5,
            dir: "GPIO27"
          }
        }
      }
    };
    var Motors = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Motor;
      }
    };
    Collection.installMethodForwarding(Motors.prototype, Motor.prototype);
    Motor.Collection = Motors;
    if (!!process.env.IS_TEST_MODE) {
      Motor.Controllers = Controllers;
      Motor.purge = function() {
        priv.clear();
        registers.clear();
      };
    }
    module2.exports = Motor;
  }
});

// node_modules/nanotimer/lib/nanoTimer.js
var require_nanoTimer = __commonJS({
  "node_modules/nanotimer/lib/nanoTimer.js"(exports, module2) {
    function NanoTimer(log) {
      var version = process.version;
      var major = version.split(".")[0];
      major = major.split("v")[1];
      var minor = version.split(".")[1];
      if (major == 0 && minor < 10) {
        console.log("Error: Please update to the latest version of node! This library requires 0.10.x or later");
        process.exit(0);
      }
      this.intervalT1 = null;
      this.timeOutT1 = null;
      this.intervalCount = 1;
      this.deferredInterval = false;
      this.deferredTimeout = false;
      this.deferredTimeoutRef = null;
      this.deferredIntervalRef = null;
      this.timeoutCallbackRef = null;
      this.intervalCallbackRef = null;
      this.timeoutImmediateRef = null;
      this.intervalImmediateRef = null;
      this.intervalErrorChecked = false;
      this.intervalType = "";
      if (log) {
        this.logging = true;
      }
    }
    NanoTimer.prototype.time = function(task, args, format, callback) {
      if (callback) {
        var t1 = process.hrtime();
        if (args) {
          args.push(function() {
            var time = process.hrtime(t1);
            if (format == "s") {
              callback(time[0] + time[1] / 1e9);
            } else if (format == "m") {
              callback(time[0] / 1e3 + time[1] / 1e6);
            } else if (format == "u") {
              callback(time[0] / 1e6 + time[1] / 1e3);
            } else if (format == "n") {
              callback(time[0] / 1e9 + time[1]);
            } else {
              callback(time);
            }
          });
          task.apply(null, args);
        } else {
          task(function() {
            var time = process.hrtime(t1);
            if (format == "s") {
              callback(time[0] + time[1] / 1e9);
            } else if (format == "m") {
              callback(time[0] / 1e3 + time[1] / 1e6);
            } else if (format == "u") {
              callback(time[0] / 1e6 + time[1] / 1e3);
            } else if (format == "n") {
              callback(time[0] / 1e9 + time[1]);
            } else {
              callback(time);
            }
          });
        }
      } else {
        var t1 = process.hrtime();
        if (args) {
          task.apply(null, args);
        } else {
          task();
        }
        var t2 = process.hrtime(t1);
        if (format == "s") {
          return t2[0] + t2[1] / 1e9;
        } else if (format == "m") {
          return t2[0] / 1e3 + t2[1] / 1e6;
        } else if (format == "u") {
          return t2[0] / 1e6 + t2[1] / 1e3;
        } else if (format == "n") {
          return t2[0] / 1e9 + t2[1];
        } else {
          return process.hrtime(t1);
        }
      }
    };
    NanoTimer.prototype.setInterval = function(task, args, interval, callback) {
      if (!this.intervalErrorChecked) {
        if (!task) {
          console.log("A task function must be specified to setInterval");
          process.exit(1);
        } else {
          if (typeof task != "function") {
            console.log("Task argument to setInterval must be a function reference");
            process.exit(1);
          }
        }
        if (!interval) {
          console.log("An interval argument must be specified");
          process.exit(1);
        } else {
          if (typeof interval != "string") {
            console.log("Interval argument to setInterval must be a string specified as an integer followed by 's' for seconds, 'm' for milli, 'u' for micro, and 'n' for nanoseconds. Ex. 2u");
            process.exit(1);
          }
        }
        if (callback) {
          if (typeof callback != "function") {
            console.log("Callback argument to setInterval must be a function reference");
            process.exit(1);
          } else {
            this.intervalCallbackRef = callback;
          }
        }
        this.intervalType = interval[interval.length - 1];
        if (this.intervalType == "s") {
          this.intervalTime = interval.slice(0, interval.length - 1) * 1e9;
        } else if (this.intervalType == "m") {
          this.intervalTime = interval.slice(0, interval.length - 1) * 1e6;
        } else if (this.intervalType == "u") {
          this.intervalTime = interval.slice(0, interval.length - 1) * 1e3;
        } else if (this.intervalType == "n") {
          this.intervalTime = interval.slice(0, interval.length - 1);
        } else {
          console.log("Error with argument: " + interval + ': Incorrect interval format. Format is an integer followed by "s" for seconds, "m" for milli, "u" for micro, and "n" for nanoseconds. Ex. 2u');
          process.exit(1);
        }
        this.intervalErrorChecked = true;
      }
      var thisTimer = this;
      if (this.intervalTime > 0) {
        if (this.intervalT1 == null) {
          this.intervalT1 = process.hrtime();
        }
        if (this.intervalTime * this.intervalCount > 8e15) {
          this.intervalT1 = process.hrtime();
          this.intervalCount = 1;
        }
        this.difArray = process.hrtime(this.intervalT1);
        this.difTime = this.difArray[0] * 1e9 + this.difArray[1];
        if (this.difTime < this.intervalTime * this.intervalCount) {
          if (this.intervalTime > 25e6) {
            if (this.deferredInterval == false) {
              this.deferredInterval = true;
              msDelay = (this.intervalTime - 25e6) / 1e6;
              this.deferredIntervalRef = setTimeout(function() {
                thisTimer.setInterval(task, args, interval, callback);
              }, msDelay);
            } else {
              this.deferredIntervalRef = null;
              this.intervalImmediateRef = setImmediate(function() {
                thisTimer.setInterval(task, args, interval, callback);
              });
            }
          } else {
            this.intervalImmediateRef = setImmediate(function() {
              thisTimer.setInterval(task, args, interval, callback);
            });
          }
        } else {
          this.intervalImmediateRef = null;
          if (this.logging) {
            console.log("nanotimer log: cycle time at - " + this.difTime);
          }
          if (args) {
            task.apply(null, args);
          } else {
            task();
          }
          if (this.intervalT1) {
            this.intervalCount++;
            this.deferredInterval = false;
            this.intervalImmediateRef = setImmediate(function() {
              thisTimer.setInterval(task, args, interval, callback);
            });
          }
        }
      } else {
        if (this.intervalT1 == null) {
          this.intervalT1 = process.hrtime();
          this.intervalContinue = true;
        }
        if (this.intervalContinue == true) {
          if (args) {
            task.apply(null, args);
          } else {
            task();
          }
          setImmediate(function() {
            thisTimer.setInterval(task, args, interval, callback);
          });
        } else {
          this.intervalT1 = null;
          this.intervalCount = 1;
          callback();
        }
      }
    };
    NanoTimer.prototype.setTimeout = function(task, args, delay, callback) {
      if (!task) {
        console.log("A task function must be specified to setTimeout");
        process.exit(1);
      } else {
        if (typeof task != "function") {
          console.log("Task argument to setTimeout must be a function reference");
          process.exit(1);
        }
      }
      if (!delay) {
        console.log("A delay argument must be specified");
        process.exit(1);
      } else {
        if (typeof delay != "string") {
          console.log("Delay argument to setTimeout must be a string specified as an integer followed by 's' for seconds, 'm' for milli, 'u' for micro, and 'n' for nanoseconds. Ex. 2u");
          process.exit(1);
        }
      }
      if (callback) {
        if (typeof callback != "function") {
          console.log("Callback argument to setTimeout must be a function reference");
          process.exit(1);
        } else {
          this.timeoutCallbackRef = callback;
        }
      }
      var thisTimer = this;
      var delayType = delay[delay.length - 1];
      if (delayType == "s") {
        var delayTime = delay.slice(0, delay.length - 1) * 1e9;
      } else if (delayType == "m") {
        var delayTime = delay.slice(0, delay.length - 1) * 1e6;
      } else if (delayType == "u") {
        var delayTime = delay.slice(0, delay.length - 1) * 1e3;
      } else if (delayType == "n") {
        var delayTime = delay.slice(0, delay.length - 1);
      } else {
        console.log("Error with argument: " + delay + ': Incorrect delay format. Format is an integer followed by "s" for seconds, "m" for milli, "u" for micro, and "n" for nanoseconds. Ex. 2u');
        process.exit(1);
      }
      if (this.timeOutT1 == null) {
        this.timeOutT1 = process.hrtime();
      }
      var difArray = process.hrtime(this.timeOutT1);
      var difTime = difArray[0] * 1e9 + difArray[1];
      if (difTime < delayTime) {
        if (delayTime > 25e6) {
          if (this.deferredTimeout == false) {
            this.deferredTimeout = true;
            msDelay = (delayTime - 25e6) / 1e6;
            this.deferredTimeoutRef = setTimeout(function() {
              thisTimer.setTimeout(task, args, delay, callback);
            }, msDelay);
          } else {
            this.deferredTimeoutRef = null;
            this.timeoutImmediateRef = setImmediate(function() {
              thisTimer.setTimeout(task, args, delay, callback);
            });
          }
        } else {
          this.timeoutImmediateRef = setImmediate(function() {
            thisTimer.setTimeout(task, args, delay, callback);
          });
        }
      } else {
        this.timeoutImmediateRef = null;
        this.timeOutT1 = null;
        this.deferredTimeout = false;
        if (this.logging == true) {
          console.log("nanotimer log: actual wait - " + difTime);
        }
        if (args) {
          task.apply(null, args);
        } else {
          task();
        }
        if (callback) {
          var data = { "waitTime": difTime };
          callback(data);
        }
      }
    };
    NanoTimer.prototype.clearInterval = function() {
      if (this.deferredIntervalRef) {
        clearTimeout(this.deferredIntervalRef);
        this.deferredInterval = false;
      }
      if (this.intervalImmediateRef) {
        clearImmediate(this.intervalImmediateRef);
      }
      this.intervalT1 = null;
      this.intervalCount = 1;
      this.intervalErrorChecked = false;
      if (this.intervalCallbackRef) {
        this.intervalCallbackRef();
      }
    };
    NanoTimer.prototype.clearTimeout = function() {
      if (this.deferredTimeoutRef) {
        clearTimeout(this.deferredTimeoutRef);
        var difArray = process.hrtime(this.timeOutT1);
        var difTime = difArray[0] * 1e9 + difArray[1];
        this.deferredTimeout = false;
      }
      if (this.timeoutImmediateRef) {
        clearImmediate(this.timeoutImmediateRef);
      }
      this.timeOutT1 = null;
      if (this.timeoutCallbackRef) {
        var data = { "waitTime": difTime };
        this.timeoutCallbackRef(data);
      }
    };
    module2.exports = NanoTimer;
  }
});

// node_modules/johnny-five/lib/piezo.js
var require_piezo = __commonJS({
  "node_modules/johnny-five/lib/piezo.js"(exports, module2) {
    var Board = require_board();
    var Timer2 = require_nanoTimer();
    var MICROSECONDS_PER_SECOND = 1e6;
    var priv = new Map();
    var defaultOctave = 4;
    function clearTimer(target) {
      if (!target.timer) {
        return target;
      }
      target.timer.clearInterval();
      delete target.timer;
      return target;
    }
    var Controllers = {
      DEFAULT: {
        initialize: {
          writable: true,
          value() {
            this.io.pinMode(this.pin, this.io.MODES.OUTPUT);
          }
        },
        tone: {
          writable: true,
          value(tone, duration) {
            if (isNaN(tone) || isNaN(duration)) {
              throw new Error("Piezo.tone: invalid tone or duration");
            }
            clearTimer(this);
            this.timer = new Timer2();
            let value = 1;
            this.timer.setInterval(() => {
              value = value === 1 ? 0 : 1;
              this.io.digitalWrite(this.pin, value);
              if (this.timer.difTime / 1e6 > duration) {
                clearTimer(this);
              }
            }, null, `${tone}u`, () => {
            });
            return this;
          }
        },
        noTone: {
          writable: true,
          value() {
            this.io.digitalWrite(this.pin, 0);
            return clearTimer(this);
          }
        }
      },
      I2C_BACKPACK: {
        ADDRESSES: {
          value: [10]
        },
        REGISTER: {
          value: {
            NO_TONE: 0,
            TONE: 1
          }
        },
        initialize: {
          writable: true,
          value(options) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const state = priv.get(this);
            this.io.i2cConfig(options);
            state.address = address;
          }
        },
        tone: {
          writable: true,
          value(tone, duration) {
            const state = priv.get(this);
            if (isNaN(tone) || isNaN(duration)) {
              throw new Error("Piezo.tone: invalid tone or duration");
            }
            this.io.i2cWrite(state.address, [
              this.REGISTER.TONE,
              this.pin,
              tone >> 8 & 255,
              tone & 255,
              duration >> 24 & 255,
              duration >> 16 & 255,
              duration >> 8 & 255,
              duration & 255
            ]);
            return this;
          }
        },
        noTone: {
          writable: true,
          value() {
            const state = priv.get(this);
            this.io.i2cWrite(state.address, [
              this.REGISTER.NO_TONE,
              this.pin
            ]);
            return this;
          }
        }
      }
    };
    var Piezo = class {
      constructor(options) {
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {
          isPlaying: false,
          timeout: null,
          address: null
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          isPlaying: {
            get() {
              return state.isPlaying;
            }
          }
        });
        if (typeof this.initialize === "function") {
          this.initialize(options);
        }
      }
      note(note, duration) {
        return this.frequency(Piezo.Parsers.hzFromInput(note), duration);
      }
      tone(tone, duration) {
        return this.frequency(Piezo.ToFrequency(tone), duration);
      }
      frequency(frequency, duration) {
        return this.tone(Piezo.ToTone(frequency), duration);
      }
      play(tune, callback) {
        if (typeof tune !== "object") {
          tune = {
            song: tune
          };
        }
        if (typeof tune.song === "string") {
          tune.song = Piezo.ToSong(tune.song, tune.beats);
        }
        if (tune.song && !Array.isArray(tune.song)) {
          tune.song = [tune.song];
        }
        const state = priv.get(this);
        const tempo = tune.tempo || 250;
        const beatDuration = Math.round(6e4 / tempo);
        const song = tune.song || [];
        let duration;
        let nextNoteIndex = 0;
        const next = () => {
          if (nextNoteIndex === song.length) {
            state.isPlaying = false;
            if (typeof callback === "function") {
              callback(tune);
            }
            return;
          }
          const note = song[nextNoteIndex];
          const hz = Piezo.Parsers.hzFromInput(note);
          const beat = Piezo.Parsers.beatFromNote(note);
          duration = beat * beatDuration;
          nextNoteIndex++;
          if (hz === null) {
            this.noTone();
          } else {
            this.frequency(hz, duration);
          }
          state.timeout = setTimeout(next, duration);
        };
        state.isPlaying = true;
        next();
        return this;
      }
      off() {
        return this.noTone();
      }
      stop() {
        const state = priv.get(this);
        if (state.timeout) {
          clearTimeout(state.timeout);
          state.timeout = null;
        }
        return this;
      }
    };
    Piezo.Notes = {
      "c0": 16,
      "c#0": 17,
      "d0": 18,
      "d#0": 19,
      "e0": 21,
      "f0": 22,
      "f#0": 23,
      "g0": 25,
      "g#0": 26,
      "a0": 28,
      "a#0": 29,
      "b0": 31,
      "c1": 33,
      "c#1": 35,
      "d1": 37,
      "d#1": 39,
      "e1": 41,
      "f1": 44,
      "f#1": 47,
      "g1": 49,
      "g#1": 52,
      "a1": 55,
      "a#1": 58,
      "b1": 62,
      "c2": 65,
      "c#2": 69,
      "d2": 73,
      "d#2": 78,
      "e2": 82,
      "f2": 87,
      "f#2": 93,
      "g2": 98,
      "g#2": 104,
      "a2": 110,
      "a#2": 117,
      "b2": 124,
      "c3": 131,
      "c#3": 139,
      "d3": 147,
      "d#3": 156,
      "e3": 165,
      "f3": 175,
      "f#3": 185,
      "g3": 196,
      "g#3": 208,
      "a3": 220,
      "a#3": 233,
      "b3": 247,
      "c4": 262,
      "c#4": 277,
      "d4": 294,
      "d#4": 311,
      "e4": 330,
      "f4": 349,
      "f#4": 370,
      "g4": 392,
      "g#4": 415,
      "a4": 440,
      "a#4": 466,
      "b4": 494,
      "c5": 523,
      "c#5": 554,
      "d5": 587,
      "d#5": 622,
      "e5": 659,
      "f5": 698,
      "f#5": 740,
      "g5": 784,
      "g#5": 831,
      "a5": 880,
      "a#5": 932,
      "b5": 988,
      "c6": 1047,
      "c#6": 1109,
      "d6": 1175,
      "d#6": 1245,
      "e6": 1319,
      "f6": 1397,
      "f#6": 1480,
      "g6": 1568,
      "g#6": 1661,
      "a6": 1760,
      "a#6": 1865,
      "b6": 1976,
      "c7": 2093,
      "c#7": 2217,
      "d7": 2349,
      "d#7": 2489,
      "e7": 2637,
      "f7": 2794,
      "f#7": 2960,
      "g7": 3136,
      "g#7": 3322,
      "a7": 3520,
      "a#7": 3729,
      "b7": 3951,
      "c8": 4186,
      "c#8": 4435,
      "d8": 4699,
      "d#8": 4978,
      "e8": 5274,
      "f8": 5588,
      "f#8": 5920,
      "g8": 6272,
      "g#8": 6645,
      "a8": 7040,
      "a#8": 7459,
      "b8": 7902
    };
    Piezo.Frequencies = Object.keys(Piezo.Notes).reduce((accum, note) => {
      accum[Piezo.Notes[note]] = note;
      return accum;
    }, {});
    Piezo.Parsers = {};
    Piezo.Parsers.hzFromInput = (input) => {
      let output = input;
      if (Array.isArray(input)) {
        output = input[0];
      }
      if (typeof output === "number" && Piezo.Frequencies[output]) {
        return output;
      }
      if (typeof output === "string") {
        output = output.toLowerCase().trim();
        if (output.endsWith("#") || output.length === 1) {
          output += defaultOctave;
        }
        output = Piezo.Notes[output] || null;
      }
      if (isNaN(output)) {
        output = null;
      }
      return output;
    };
    Piezo.Parsers.beatFromNote = (note) => {
      let beat = 1;
      if (Array.isArray(note) && note[1] !== void 0) {
        beat = note[1];
      }
      return beat;
    };
    Piezo.isValidOctave = (octave) => typeof octave === "number" && (octave >= 0 && octave <= 8);
    Piezo.defaultOctave = (octave) => {
      if (Piezo.isValidOctave(octave)) {
        defaultOctave = octave;
      }
      return defaultOctave;
    };
    Piezo.ToFrequency = (tone) => {
      const toneSeconds = tone / MICROSECONDS_PER_SECOND;
      const period = toneSeconds * 2;
      return Math.round(1 / period);
    };
    Piezo.ToTone = (frequency) => {
      const period = 1 / frequency;
      const duty = period / 2;
      return Math.round(duty * MICROSECONDS_PER_SECOND);
    };
    Piezo.ToSong = (stringSong, beats = 1) => {
      const notes = stringSong.split(" ");
      const song = [];
      let note;
      let lastNote;
      while (notes.length) {
        note = notes.shift();
        if (/^[0-9]+$/.test(note)) {
          note = parseInt(note, 10);
        }
        lastNote = song[song.length - 1];
        if (lastNote && lastNote[0] === note) {
          lastNote[1] += beats;
        } else {
          song.push([note, beats]);
        }
      }
      return song;
    };
    module2.exports = Piezo;
  }
});

// node_modules/johnny-five/lib/proximity.js
var require_proximity = __commonJS({
  "node_modules/johnny-five/lib/proximity.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var EVS = require_evshield();
    var Fn = require_fn();
    var Withinable = require_withinable();
    var Pins = Board.Pins;
    var toFixed = Fn.toFixed;
    var priv = new Map();
    function analogHandler(options, callback) {
      this.io.pinMode(this.pin, this.io.MODES.ANALOG);
      this.io.analogRead(this.pin, (data) => {
        callback.call(this, data);
      });
    }
    var Controllers = {
      GP2Y0A21YK: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(12343.85 * value ** -1.15, 2);
          }
        }
      },
      GP2D120XJ00F: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(2914 / (value + 5) - 1, 2);
          }
        }
      },
      GP2Y0A02YK0F: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(10650.08 * value ** -0.935 - 10, 2);
          }
        }
      },
      GP2Y0A41SK0F: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(2076 / (value - 11), 2);
          }
        }
      },
      GP2Y0A710K0F: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(38631e4 * value ** -2.463343, 0);
          }
        }
      },
      SRF10: {
        ADDRESSES: {
          value: [112]
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const msUntilNextRead = 65;
            this.io.i2cConfig(options);
            this.io.i2cWrite(address, [1, 16]);
            this.io.i2cWrite(address, [2, 255]);
            const read = () => {
              this.io.i2cWrite(address, [0, 81]);
              setTimeout(() => {
                this.io.i2cWrite(address, [2]);
                this.io.i2cReadOnce(address, 2, (data) => callback(data[0] << 8 | data[1]));
                read();
              }, msUntilNextRead);
            };
            read();
          }
        },
        toCm: {
          value(value) {
            return value;
          }
        }
      },
      MB1000: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(value / 2 * 2.54, 2);
          }
        }
      },
      MB1003: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return toFixed(value / 2, 1);
          }
        }
      },
      MB1230: {
        initialize: {
          value: analogHandler
        },
        toCm: {
          value(value) {
            return value >> 0;
          }
        }
      },
      HCSR04: {
        initialize: {
          value(options, callback) {
            let pinValue = options.pinValue;
            const msToNextRead = 65;
            if (Pins.isFirmata(this)) {
              if (typeof pinValue === "string" && (pinValue.length > 1 && pinValue[0] === "A")) {
                pinValue = this.io.analogPins[+pinValue.slice(1)];
              }
              pinValue = +pinValue;
              if (this.io.analogPins.includes(pinValue)) {
                options.pin = pinValue;
              }
              this.pin = options.pin;
            }
            const settings = {
              pin: options.pin,
              value: this.io.HIGH,
              pulseOut: 5
            };
            const read = () => {
              this.io.pingRead(settings, (microseconds) => {
                callback(microseconds);
                setTimeout(read, msToNextRead);
              });
            };
            read();
          }
        },
        toCm: {
          value(value) {
            return toFixed(value / 29.1 / 2, 1);
          }
        }
      },
      HCSR04I2CBACKPACK: {
        ADDRESSES: {
          value: [
            39
          ]
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            const msToNextRead = 90;
            this.io.i2cConfig(options);
            if (typeof options.pin === "undefined") {
              this.pin = 8;
            }
            const read = () => {
              this.io.i2cReadOnce(address, 2, (data) => {
                callback((data[0] << 8) + data[1]);
                setTimeout(read, msToNextRead);
              });
            };
            read();
          }
        },
        toCm: {
          value(value) {
            return toFixed(value / 29.1 / 2, 1);
          }
        }
      },
      LIDARLITE: {
        ADDRESSES: {
          value: [
            98
          ]
        },
        REGISTER: {
          value: {
            ENABLE: 0,
            READ: 143
          }
        },
        initialize: {
          value(options, callback) {
            const { Drivers } = require_sip();
            const address = Drivers.addressResolver(this, options);
            this.io.i2cConfig(options);
            const read = () => {
              this.io.i2cWrite(address, this.REGISTER.ENABLE, 4);
              setTimeout(() => {
                this.io.i2cReadOnce(address, this.REGISTER.READ, 2, (bytes) => {
                  callback((bytes[0] << 8) + bytes[1]);
                  read();
                });
              }, 20);
            };
            read();
          }
        },
        toCm: {
          value(value) {
            return value >> 0;
          }
        }
      },
      EVS_EV3_IR: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_EV3);
            state.ev3.read(state.shield, EVS.Proximity, EVS.Proximity_Bytes, (data) => callback(data[0] | data[1] << 8));
          }
        },
        toCm: {
          value(value) {
            return value;
          }
        }
      },
      EVS_EV3_US: {
        initialize: {
          value(options, callback) {
            const state = priv.get(this);
            state.shield = EVS.shieldPort(options.pin);
            state.ev3 = new EVS(Object.assign(options, {
              io: this.io
            }));
            state.ev3.setup(state.shield, EVS.Type_EV3);
            state.ev3.read(state.shield, EVS.Proximity, EVS.Proximity_Bytes, (data) => callback(data[0] | data[1] << 8));
          }
        },
        toCm: {
          value(value) {
            return value / 10;
          }
        }
      }
    };
    Controllers["2Y0A21"] = Controllers.GP2Y0A21YK;
    Controllers["2D120X"] = Controllers.GP2D120XJ00F;
    Controllers["2Y0A02"] = Controllers.GP2Y0A02YK0F;
    Controllers["0A41"] = Controllers.GP2Y0A41SK0F;
    Controllers["0A21"] = Controllers.GP2Y0A21YK;
    Controllers["0A02"] = Controllers.GP2Y0A02YK0F;
    Controllers["41SK0F"] = Controllers.GP2Y0A41SK0F;
    Controllers["21YK"] = Controllers.GP2Y0A21YK;
    Controllers["2YK0F"] = Controllers.GP2Y0A02YK0F;
    Controllers.MB1010 = Controllers.MB1000;
    Controllers["LV-MaxSonar-EZ"] = Controllers.MB1000;
    Controllers["LV-MaxSonar-EZ0"] = Controllers.MB1000;
    Controllers["LV-MaxSonar-EZ1"] = Controllers.MB1010;
    Controllers["HRLV-MaxSonar-EZ0"] = Controllers.MB1003;
    Controllers["XL-MaxSonar-EZ3"] = Controllers.MB1230;
    [
      "HC-SR04",
      "SR04",
      "SRF05",
      "SRF06",
      "PARALLAXPING",
      "SEEEDPING",
      "GROVEPING",
      "PING_PULSE_IN",
      "ULTRASONIC_PING"
    ].forEach((alias) => {
      Controllers[alias] = Controllers.HCSR04;
    });
    [
      "HCSR04-I2C-BACKPACK",
      "HC-SR04-I2C-BACKPACK",
      "SR04-I2C-BACKPACK",
      "SR04I2CBACKPACK",
      "PINGI2CBACKPACK",
      "PING-I2C-BACKPACK",
      "HCSR04_I2C_BACKPACK",
      "HC_SR04_I2C_BACKPACK",
      "SR04_I2C_BACKPACK",
      "SR04I2CBACKPACK",
      "PINGI2CBACKPACK",
      "PING_I2C_BACKPACK"
    ].forEach((alias) => {
      Controllers[alias] = Controllers.HCSR04I2CBACKPACK;
    });
    Controllers["LIDAR-Lite"] = Controllers.LIDARLITE;
    Controllers.DEFAULT = Controllers["GP2Y0A21YK"];
    var Proximity = class extends Withinable {
      constructor(options) {
        super();
        const pinValue = typeof options === "object" ? options.pin : options;
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const state = {};
        const freq = options.freq || 25;
        let raw = 0;
        let last = 0;
        if (!this.toCm) {
          this.toCm = options.toCm || ((x) => x);
        }
        priv.set(this, state);
        Object.defineProperties(this, {
          centimeters: {
            get() {
              return this.toCm(raw);
            }
          },
          cm: {
            get() {
              return this.centimeters;
            }
          },
          inches: {
            get() {
              return toFixed(this.centimeters * 0.39, 2);
            }
          },
          in: {
            get() {
              return this.inches;
            }
          }
        });
        if (typeof this.initialize === "function") {
          options.pinValue = pinValue;
          this.initialize(options, (data) => raw = data);
        }
        setInterval(() => {
          if (raw === void 0) {
            return;
          }
          const data = {
            cm: this.cm,
            centimeters: this.centimeters,
            in: this.in,
            inches: this.inches
          };
          this.emit("data", data);
          if (raw !== last) {
            last = raw;
            this.emit("change", data);
          }
        }, freq);
      }
    };
    Proximity.Collection = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Proximity;
      }
    };
    Collection.installMethodForwarding(Proximity.Collection.prototype, Proximity.prototype);
    Proximity.Controllers = Object.keys(Controllers);
    if (!!process.env.IS_TEST_MODE) {
      Proximity.Controllers = Controllers;
      Proximity.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Proximity;
  }
});

// node_modules/johnny-five/lib/reflectancearray.js
var require_reflectancearray = __commonJS({
  "node_modules/johnny-five/lib/reflectancearray.js"(exports, module2) {
    var Board = require_board();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var Led = require_led2();
    var Sensor = require_sensor();
    var CALIBRATED_MIN_VALUE = 0;
    var CALIBRATED_MAX_VALUE = 1e3;
    var LINE_ON_THRESHOLD = 200;
    var LINE_NOISE_THRESHOLD = 50;
    var priv = new Map();
    var Controllers = {
      DEFAULT: {
        initialize: {
          value(options) {
            if (typeof options.emitter === "undefined") {
              throw new Error("Emitter pin is required");
            }
            if (!options.pins || options.pins.length === 0) {
              throw new Error("Pins must be defined");
            }
            const state = priv.get(this);
            state.emitter = new Led({
              board: this.board,
              pin: options.emitter
            });
            state.sensorStates = options.pins.map((pin) => {
              const sensor = new Sensor({
                board: this.board,
                freq: state.freq,
                pin
              });
              const sensorState = {
                sensor,
                rawValue: 0,
                dataReceived: false
              };
              sensor.on("data", (value) => {
                onData(this, sensorState, value);
              });
              return sensorState;
            });
          }
        }
      }
    };
    function onData(instance, sensorState, value) {
      const state = priv.get(instance);
      sensorState.dataReceived = true;
      sensorState.rawValue = value;
      const allRead = state.sensorStates.every(({ dataReceived }) => dataReceived);
      if (allRead) {
        instance.emit("data", instance.raw);
        if (state.autoCalibrate) {
          setCalibration(state.calibration, instance.raw);
        }
        if (instance.isCalibrated) {
          instance.emit("calibratedData", instance.values);
          instance.emit("line", instance.line);
        }
        state.sensorStates.forEach((sensorState2) => {
          sensorState2.dataReceived = false;
        });
      }
    }
    function setCalibration(calibration, values) {
      values.forEach((value, i) => {
        if (calibration.min[i] === void 0 || value < calibration.min[i]) {
          calibration.min[i] = value;
        }
        if (calibration.max[i] === void 0 || value > calibration.max[i]) {
          calibration.max[i] = value;
        }
      });
    }
    function calibrationIsValid(calibration, sensors) {
      return calibration && (calibration.max && calibration.max.length === sensors.length) && (calibration.min && calibration.min.length === sensors.length);
    }
    function calibratedValues(instance) {
      return instance.raw.map((value, i) => {
        return Fn.constrain(Fn.scale(value, instance.calibration.min[i], instance.calibration.max[i], CALIBRATED_MIN_VALUE, CALIBRATED_MAX_VALUE), CALIBRATED_MIN_VALUE, CALIBRATED_MAX_VALUE);
      });
    }
    function maxLineValue(instance) {
      return (instance.sensors.length - 1) * CALIBRATED_MAX_VALUE;
    }
    function getLine(instance, whiteLine) {
      const state = priv.get(instance);
      let onLine = false;
      let avg = 0;
      let sum = 0;
      whiteLine = !!whiteLine;
      instance.values.forEach((value, i) => {
        value = whiteLine ? CALIBRATED_MAX_VALUE - value : value;
        if (value > LINE_ON_THRESHOLD) {
          onLine = true;
        }
        if (value > LINE_NOISE_THRESHOLD) {
          avg += value * i * CALIBRATED_MAX_VALUE;
          sum += value;
        }
      });
      if (!onLine) {
        const maxPoint = maxLineValue(instance) + 1;
        const centerPoint = maxPoint / 2;
        return state.lastLine < centerPoint ? 0 : maxPoint;
      }
      return state.lastLine = Math.floor(avg / sum);
    }
    var ReflectanceArray = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        Board.Controller.call(this, Controllers, options);
        const {
          autoCalibrate = false,
          freq = 25
        } = options;
        const state = {
          autoCalibrate,
          freq,
          lastLine: 0,
          isOn: false,
          calibration: {
            min: [],
            max: []
          }
        };
        priv.set(this, state);
        if (typeof this.initialize === "function") {
          this.initialize(options);
        }
        Object.defineProperties(this, {
          isOn: {
            get() {
              return state.emitter.isOn;
            }
          },
          isCalibrated: {
            get() {
              return calibrationIsValid(this.calibration, this.sensors);
            }
          },
          isOnLine: {
            get() {
              const line = this.line;
              return line > CALIBRATED_MIN_VALUE && line < maxLineValue(this);
            }
          },
          sensors: {
            get() {
              return state.sensorStates.map(({ sensor }) => sensor);
            }
          },
          calibration: {
            get() {
              return state.calibration;
            }
          },
          raw: {
            get() {
              return state.sensorStates.map(({ rawValue }) => rawValue);
            }
          },
          values: {
            get() {
              return this.isCalibrated ? calibratedValues(this) : this.raw;
            }
          },
          line: {
            get() {
              return this.isCalibrated ? getLine(this) : 0;
            }
          }
        });
      }
      enable() {
        priv.get(this).emitter.on();
        return this;
      }
      disable() {
        priv.get(this).emitter.off();
        return this;
      }
      calibrate() {
        this.once("data", (values) => {
          setCalibration(priv.get(this).calibration, values);
          this.emit("calibrated");
        });
        return this;
      }
      calibrateUntil(predicate) {
        const loop = () => {
          this.calibrate();
          this.once("calibrated", () => {
            if (!predicate()) {
              loop();
            }
          });
        };
        loop();
        return this;
      }
      loadCalibration(calibration) {
        if (!calibrationIsValid(calibration, this.sensors)) {
          throw new Error("Calibration data not properly set: {min: [], max: []}");
        }
        priv.get(this).calibration = calibration;
        return this;
      }
    };
    module2.exports = ReflectanceArray;
  }
});

// node_modules/johnny-five/lib/relay.js
var require_relay = __commonJS({
  "node_modules/johnny-five/lib/relay.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var Pins = Board.Pins;
    var priv = new Map();
    var Relay = class {
      constructor(options) {
        const pinValue = typeof options === "object" ? options.pin : options;
        Board.Component.call(this, options = Board.Options(options));
        options.type = options.type || "NO";
        const state = {
          isInverted: options.type === "NC",
          isClosed: false,
          value: null
        };
        priv.set(this, state);
        Object.defineProperties(this, {
          value: {
            get() {
              return Number(this.isClosed);
            }
          },
          type: {
            get() {
              return state.isInverted ? "NC" : "NO";
            }
          },
          isClosed: {
            get() {
              return state.isClosed;
            }
          }
        });
        if (Pins.isFirmata(this) && (typeof pinValue === "string" && pinValue[0] === "A")) {
          this.pin = this.io.analogPins[+pinValue.slice(1)];
          this.io.pinMode(this.pin, this.io.MODES.OUTPUT);
        }
      }
      close() {
        const state = priv.get(this);
        this.io.digitalWrite(this.pin, state.isInverted ? this.io.LOW : this.io.HIGH);
        state.isClosed = true;
        return this;
      }
      open() {
        const state = priv.get(this);
        this.io.digitalWrite(this.pin, state.isInverted ? this.io.HIGH : this.io.LOW);
        state.isClosed = false;
        return this;
      }
      toggle() {
        const state = priv.get(this);
        if (state.isClosed) {
          this.open();
        } else {
          this.close();
        }
        return this;
      }
    };
    var Relays = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Relay;
      }
    };
    Collection.installMethodForwarding(Relays.prototype, Relay.prototype);
    Relay.Collection = Relays;
    if (!!process.env.IS_TEST_MODE) {
      Relay.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Relay;
  }
});

// node_modules/johnny-five/lib/servo.js
var require_servo = __commonJS({
  "node_modules/johnny-five/lib/servo.js"(exports, module2) {
    var Board = require_board();
    var Pins = Board.Pins;
    var Expander = require_expander();
    var Collection = require_collection();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var Animation = require_animation();
    var priv = new Map();
    var Controllers = {
      PCA9685: {
        initialize: {
          value({ address, pwmRange, frequency, pin }) {
            const state = priv.get(this);
            this.address = address || 64;
            this.pwmRange = pwmRange || [450, 1850];
            this.frequency = frequency || 50;
            state.expander = Expander.get({
              address: this.address,
              controller: this.controller,
              bus: this.bus,
              pwmRange: this.pwmRange,
              frequency: this.frequency
            });
            this.pin = state.expander.normalize(pin);
          }
        },
        update: {
          writable: true,
          value(microseconds) {
            const state = priv.get(this);
            state.expander.servoWrite(this.pin, microseconds);
          }
        }
      },
      Standard: {
        initialize: {
          value({ debug, pwmRange }) {
            if (debug && !this.board.pins.isServo(this.pin)) {
              Board.Pins.Error({
                pin: this.pin,
                type: "PWM",
                via: "Servo"
              });
            }
            if (Array.isArray(pwmRange)) {
              this.io.servoConfig(this.pin, pwmRange[0], pwmRange[1]);
            } else {
              this.io.pinMode(this.pin, this.mode);
            }
          }
        },
        update: {
          writable: true,
          value(degrees) {
            if (this.last && this.last.degrees === degrees) {
              return this;
            }
            let microseconds = Fn.map(degrees, this.degreeRange[0], this.degreeRange[1], this.pwmRange[0], this.pwmRange[1]);
            microseconds |= 0;
            this.io.servoWrite(this.pin, microseconds);
          }
        }
      }
    };
    Controllers.DEFAULT = Controllers.Standard;
    var Servo = class extends Emitter {
      constructor(options) {
        super();
        const history = [];
        let pinValue = typeof options === "object" ? options.pin : options;
        Board.Component.call(this, options = Board.Options(options));
        this.degreeRange = options.degreeRange || [0, 180];
        this.pwmRange = options.pwmRange || [600, 2400];
        this.range = options.range || this.degreeRange;
        this.deadband = options.deadband || [90, 90];
        this.fps = options.fps || 100;
        this.offset = options.offset || 0;
        this.range = options.range || [0 - this.offset, 180 - this.offset];
        this.mode = this.io.MODES.SERVO;
        this.interval = null;
        this.value = null;
        this.type = options.type || "standard";
        if (options.isInverted) {
          console.warn("The 'isInverted' property has been renamed 'invert'");
        }
        this.invert = options.isInverted || options.invert || false;
        if (typeof options.controller === "undefined" && Pins.isFirmata(this)) {
          if (typeof pinValue === "string" && (pinValue.length > 1 && pinValue[0] === "A")) {
            pinValue = this.io.analogPins[+pinValue.slice(1)];
          }
          pinValue = +pinValue;
          if (!Number.isNaN(pinValue) && this.pin !== pinValue) {
            this.pin = pinValue;
          }
        }
        Board.Controller.call(this, Controllers, options);
        priv.set(this, {
          history
        });
        Object.defineProperties(this, {
          history: {
            get() {
              return history.slice(-5);
            }
          },
          last: {
            get() {
              return history[history.length - 1];
            }
          },
          position: {
            get() {
              return history.length ? history[history.length - 1].degrees : -1;
            }
          }
        });
        this.initialize(options);
        if (typeof options.startAt !== "undefined") {
          this.startAt = options.startAt;
          this.to(options.startAt);
        } else {
          this.startAt = (this.degreeRange[1] - this.degreeRange[0]) / 2 + this.degreeRange[0];
        }
        if (options.center) {
          this.center();
        }
        if (options.type === "continuous") {
          this.stop();
        }
      }
      to(degrees, time, rate) {
        const state = priv.get(this);
        const options = {};
        if (typeof degrees === "object") {
          Object.assign(options, degrees);
          options.duration = degrees.duration || degrees.interval || 1e3;
          options.cuePoints = degrees.cuePoints || [0, 1];
          options.keyFrames = degrees.keyFrames || [
            null,
            {
              value: typeof degrees.degrees === "number" ? degrees.degrees : this.startAt
            }
          ];
          options.oncomplete = () => {
            process.nextTick(() => {
              if (typeof degrees.oncomplete === "function") {
                degrees.oncomplete();
              }
              this.emit("move:complete");
            });
          };
          state.isRunning = true;
          state.animation = state.animation || new Animation(this);
          state.animation.enqueue(options);
        } else {
          const target = degrees;
          degrees = Fn.constrain(degrees, this.range[0], this.range[1]);
          if (typeof time !== "undefined") {
            options.duration = time;
            options.keyFrames = [null, {
              degrees
            }];
            options.fps = rate || this.fps;
            this.to(options);
          } else {
            this.value = degrees;
            degrees += this.offset;
            if (this.invert) {
              degrees = Fn.map(degrees, this.degreeRange[0], this.degreeRange[1], this.degreeRange[1], this.degreeRange[0]);
            }
            this.update(degrees);
            if (state.history.length > 5) {
              state.history.shift();
            }
            state.history.push({
              timestamp: Date.now(),
              degrees,
              target
            });
          }
        }
        return this;
      }
      step(degrees, time) {
        return this.to(this.last.target + degrees, time);
      }
      move(degrees, time) {
        console.warn("Servo.prototype.move has been renamed to Servo.prototype.to");
        return this.to(degrees, time);
      }
      min(time, rate) {
        return this.to(this.range[0], time, rate);
      }
      max(time, rate) {
        return this.to(this.range[1], time, rate);
      }
      center(time, rate) {
        return this.to(Math.abs((this.range[0] + this.range[1]) / 2), time, rate);
      }
      home() {
        return this.to(this.startAt);
      }
      sweep(opts) {
        const options = {
          keyFrames: [{
            value: this.range[0]
          }, {
            value: this.range[1]
          }],
          metronomic: true,
          loop: true,
          easing: "inOutSine"
        };
        if (Array.isArray(opts)) {
          options.keyFrames = rangeToKeyFrames(opts);
        } else {
          if (typeof opts === "object" && opts !== null) {
            Object.assign(options, opts);
            if (Array.isArray(options.range)) {
              options.keyFrames = rangeToKeyFrames(options.range);
            }
          }
        }
        return this.to(options);
      }
      stop() {
        const state = priv.get(this);
        if (state.animation) {
          state.animation.stop();
        }
        if (this.type === "continuous") {
          this.to(this.deadband.reduce((a, b) => Math.round((a + b) / 2)));
        } else {
          clearInterval(this.interval);
        }
        return this;
      }
    };
    Servo.prototype[Animation.normalize] = function(keyFrames) {
      const last = this.last ? this.last.target : this.startAt;
      if (keyFrames[0] === null) {
        keyFrames[0] = {
          value: last
        };
      }
      if (typeof keyFrames[0] === "number") {
        keyFrames[0] = {
          value: last + keyFrames[0]
        };
      }
      return keyFrames.map((frame) => {
        const value = frame;
        if (frame !== null) {
          if (typeof frame === "number") {
            frame = {
              step: value
            };
          } else {
            if (typeof frame.degrees === "number") {
              frame.value = frame.degrees;
              delete frame.degrees;
            }
            if (typeof frame.copyDegrees === "number") {
              frame.copyValue = frame.copyDegrees;
              delete frame.copyDegrees;
            }
          }
          if (!frame.easing) {
            frame.easing = "linear";
          }
        }
        return frame;
      });
    };
    Servo.prototype[Animation.render] = function(position) {
      return this.to(position[0]);
    };
    function rangeToKeyFrames(range) {
      return range.map((value) => ({
        value
      }));
    }
    ["clockWise", "cw", "counterClockwise", "ccw"].forEach((api) => {
      Servo.prototype[api] = function(rate) {
        let range;
        rate = rate === void 0 ? 1 : rate;
        if (this.type !== "continuous") {
          this.board.error("Servo", `Servo.prototype.${api} is only available for continuous servos`);
        }
        if (api === "cw" || api === "clockWise") {
          range = [rate, 0, 1, this.deadband[1] + 1, this.range[1]];
        } else {
          range = [rate, 0, 1, this.deadband[0] - 1, this.range[0]];
        }
        return this.to(Fn.scale.apply(null, range) | 0);
      };
    });
    Servo.Continuous = class extends Servo {
      constructor(pinOrOpts) {
        const options = {};
        if (typeof pinOrOpts === "object") {
          Object.assign(options, pinOrOpts);
        } else {
          options.pin = pinOrOpts;
        }
        options.type = "continuous";
        super(options);
      }
    };
    var Servos = class extends Collection {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Servo;
      }
      [Animation.normalize](keyFrameSet) {
        return keyFrameSet.map((keyFrames, index) => {
          if (keyFrames !== null && Array.isArray(keyFrames)) {
            let servo = this[index];
            if (servo instanceof Servos) {
              servo = servo[0];
            }
            const last = servo.last ? servo.last.target : servo.startAt;
            if (keyFrames[0] === null) {
              keyFrames[0] = {
                value: last
              };
            }
            if (Array.isArray(keyFrames)) {
              if (keyFrames[0] === null) {
                keyFrameSet[index][0] = {
                  value: last
                };
              }
            }
            return this[index][Animation.normalize](keyFrames);
          }
          if (keyFrames && typeof keyFrames.degrees === "number") {
            keyFrames.value = keyFrames.degrees;
            delete keyFrames.degrees;
          }
          return keyFrames;
        });
      }
      [Animation.render](position) {
        return this.each((servo, i) => servo.to(position[i]));
      }
    };
    Collection.installMethodForwarding(Servos.prototype, Servo.prototype, {
      skip: [Animation.normalize, Animation.render]
    });
    Servo.Collection = Servos;
    if (!!process.env.IS_TEST_MODE) {
      Servo.Controllers = Controllers;
      Servo.purge = () => {
        priv.clear();
      };
    }
    module2.exports = Servo;
  }
});

// node_modules/johnny-five/lib/stepper.js
var require_stepper = __commonJS({
  "node_modules/johnny-five/lib/stepper.js"(exports, module2) {
    var Board = require_board();
    var Fn = require_fn();
    var priv = new Map();
    var steppers = new Map();
    var TAU = Fn.TAU;
    var MAXSTEPPERS = 6;
    var Step = class {
      constructor(stepper) {
        this.rpm = 180;
        this.direction = -1;
        this.speed = 0;
        this.accel = 0;
        this.decel = 0;
        this.stepper = stepper;
      }
      move(steps, dir, speed, accel, decel, callback) {
        this.stepper.io.stepperStep.apply(this.stepper.io, [this.stepper.id, dir, steps, speed, accel, decel, callback]);
      }
    };
    Step.PROPERTIES = ["rpm", "direction", "speed", "accel", "decel"];
    Step.DEFAULTS = [180, -1, 0, 0, 0];
    function MotorPins(pins) {
      let k = 0;
      pins = pins.slice();
      while (pins.length) {
        this[`motor${++k}`] = pins.shift();
      }
    }
    function isSupported({ pins, MODES }) {
      return pins.some(({ supportedModes }) => supportedModes.includes(MODES.STEPPER));
    }
    var Stepper = class {
      constructor(options) {
        const params = [];
        let state;
        Board.Component.call(this, options = Board.Options(options));
        if (!isSupported(this.io)) {
          throw new Error("Stepper is not supported");
        }
        if (!options.pins) {
          throw new Error("Stepper requires a `pins` object or array");
        }
        if (!options.stepsPerRev) {
          throw new Error("Stepper requires a `stepsPerRev` number value");
        }
        steppers.set(this.board, steppers.get(this.board) || []);
        this.id = steppers.get(this.board).length;
        if (this.id >= MAXSTEPPERS) {
          throw new Error(`Stepper cannot exceed max steppers (${MAXSTEPPERS})`);
        }
        if (Array.isArray(this.pins)) {
          if (this.pins.length === 2) {
            if (!options.type) {
              throw new Error("Stepper requires a `type` number value (DRIVER, TWO_WIRE)");
            }
          }
          if (options.type === Stepper.TYPE.DRIVER) {
            this.pins = {
              step: this.pins[0],
              dir: this.pins[1]
            };
          } else {
            this.pins = new MotorPins(this.pins);
          }
        }
        if (!options.type) {
          if (this.pins.dir) {
            options.type = Stepper.TYPE.DRIVER;
          } else {
            if (this.pins.motor3) {
              options.type = Stepper.TYPE.FOUR_WIRE;
            } else {
              options.type = Stepper.TYPE.TWO_WIRE;
            }
          }
        }
        params.push(this.id, options.type, options.stepsPerRev);
        if (options.type === Stepper.TYPE.DRIVER) {
          if (typeof this.pins.dir === "undefined" || typeof this.pins.step === "undefined") {
            throw new Error("Stepper.TYPE.DRIVER expects: `pins.dir`, `pins.step`");
          }
          params.push(this.pins.dir, this.pins.step);
        }
        if (options.type === Stepper.TYPE.TWO_WIRE) {
          if (typeof this.pins.motor1 === "undefined" || typeof this.pins.motor2 === "undefined") {
            throw new Error("Stepper.TYPE.TWO_WIRE expects: `pins.motor1`, `pins.motor2`");
          }
          params.push(this.pins.motor1, this.pins.motor2);
        }
        if (options.type === Stepper.TYPE.FOUR_WIRE) {
          if (typeof this.pins.motor1 === "undefined" || typeof this.pins.motor2 === "undefined" || typeof this.pins.motor3 === "undefined" || typeof this.pins.motor4 === "undefined") {
            throw new Error("Stepper.TYPE.FOUR_WIRE expects: `pins.motor1`, `pins.motor2`, `pins.motor3`, `pins.motor4`");
          }
          params.push(this.pins.motor1, this.pins.motor2, this.pins.motor3, this.pins.motor4);
        }
        params.slice(3).forEach((pin) => {
          this.io.pinMode(pin, this.io.MODES.STEPPER);
        });
        this.io.stepperConfig.apply(this.io, params);
        steppers.get(this.board).push(this);
        state = Step.PROPERTIES.reduce((state2, key, i) => (state2[key] = typeof options[key] !== "undefined" ? options[key] : Step.DEFAULTS[i], state2), {
          isRunning: false,
          type: options.type,
          pins: this.pins
        });
        priv.set(this, state);
        Object.defineProperties(this, {
          type: {
            get() {
              return state.type;
            }
          },
          pins: {
            get() {
              return state.pins;
            }
          }
        });
      }
      rpm(rpm) {
        const state = priv.get(this);
        if (typeof rpm === "undefined") {
          return state.rpm;
        }
        state.rpm = rpm;
        state.speed = Math.round(rpm * TAU * 100 / 60);
        return this;
      }
      speed(speed) {
        const state = priv.get(this);
        if (typeof speed === "undefined") {
          return state.speed;
        }
        state.speed = speed;
        state.rpm = Math.round(speed / TAU / 100 * 60);
        return this;
      }
      ccw() {
        return this.direction(0);
      }
      cw() {
        return this.direction(1);
      }
      step(stepsOrOpts, callback) {
        let steps;
        let step;
        let state;
        let params;
        let isValidStep;
        steps = typeof stepsOrOpts === "object" ? stepsOrOpts.steps || 0 : Math.floor(stepsOrOpts);
        step = new Step(this);
        state = priv.get(this);
        params = [];
        isValidStep = true;
        function failback(error) {
          isValidStep = false;
          if (callback) {
            callback(error);
          }
        }
        params.push(steps);
        if (typeof stepsOrOpts === "object") {
          Step.PROPERTIES.forEach((key) => {
            if (typeof stepsOrOpts[key] !== "undefined") {
              this[key](stepsOrOpts[key]);
            }
          });
        }
        if (!state.speed) {
          this.rpm(state.rpm);
          step.speed = this.speed();
        }
        Step.PROPERTIES.slice(1).forEach((key) => {
          params.push(step[key] = this[key]());
        });
        if (steps === 0) {
          failback(new Error("Must set a number of steps when calling `step()`"));
        }
        if (step.direction < 0) {
          failback(new Error("Must set a direction before calling `step()`"));
        }
        if (isValidStep) {
          state.isRunning = true;
          params.push((complete) => {
            state.isRunning = false;
            callback(null, complete);
          });
          step.move.apply(step, params);
        }
        return this;
      }
    };
    Object.defineProperties(Stepper, {
      TYPE: {
        value: Object.freeze({
          DRIVER: 1,
          TWO_WIRE: 2,
          FOUR_WIRE: 4
        })
      },
      RUNSTATE: {
        value: Object.freeze({
          STOP: 0,
          ACCEL: 1,
          DECEL: 2,
          RUN: 3
        })
      },
      DIRECTION: {
        value: Object.freeze({
          CCW: 0,
          CW: 1
        })
      }
    });
    ["direction", "accel", "decel"].forEach((prop) => {
      Stepper.prototype[prop] = function(value) {
        const state = priv.get(this);
        if (typeof value === "undefined") {
          return state[prop];
        }
        state[prop] = value;
        return this;
      };
    });
    module2.exports = Stepper;
  }
});

// node_modules/johnny-five/lib/switch.js
var require_switch = __commonJS({
  "node_modules/johnny-five/lib/switch.js"(exports, module2) {
    var Board = require_board();
    var Collection = require_collection();
    var Emitter = require_emitter();
    var Fn = require_fn();
    var Switch = class extends Emitter {
      constructor(options) {
        super();
        Board.Component.call(this, options = Board.Options(options));
        const trigger = Fn.debounce((type) => this.emit(type, this), 5);
        options.type = options.type || "NO";
        const isNormallyOpen = options.type === "NO";
        let raw = null;
        let invert = typeof options.invert !== "undefined" ? options.invert : isNormallyOpen || false;
        let closeValue = 1;
        let openValue = 0;
        if (invert) {
          closeValue ^= 1;
          openValue ^= 1;
        }
        this.io.pinMode(this.pin, this.io.MODES.INPUT);
        if (isNormallyOpen) {
          this.io.digitalWrite(this.pin, this.io.HIGH);
        }
        this.io.digitalRead(this.pin, (data) => {
          raw = data;
          trigger.call(this, this.isOpen ? "open" : "close");
        });
        Object.defineProperties(this, {
          value: {
            get() {
              return Number(this.isOpen);
            }
          },
          invert: {
            get() {
              return invert;
            },
            set(value) {
              invert = value;
              closeValue = invert ? 0 : 1;
              openValue = invert ? 1 : 0;
            }
          },
          closeValue: {
            get() {
              return closeValue;
            },
            set(value) {
              closeValue = value;
              openValue = value ^ 1;
            }
          },
          openValue: {
            get() {
              return openValue;
            },
            set(value) {
              openValue = value;
              closeValue = value ^ 1;
            }
          },
          isOpen: {
            get() {
              return raw === openValue;
            }
          },
          isClosed: {
            get() {
              return raw === closeValue;
            }
          }
        });
      }
    };
    var Switches = class extends Collection.Emitter {
      constructor(numsOrObjects) {
        super(numsOrObjects);
      }
      get type() {
        return Switch;
      }
    };
    Collection.installMethodForwarding(Switches.prototype, Switch.prototype);
    Switch.Collection = Switches;
    module2.exports = Switch;
  }
});

// node_modules/johnny-five/lib/johnny-five.js
var require_johnny_five = __commonJS({
  "node_modules/johnny-five/lib/johnny-five.js"(exports, module2) {
    module2.exports = {
      CO2: require_co2(),
      Sunlight: require_blokdots_sunlight(),
      Accelerometer: require_accelerometer(),
      Animation: require_animation(),
      Altimeter: require_altimeter(),
      Barometer: require_barometer(),
      Board: require_board(),
      Button: require_button(),
      Color: require_color(),
      Collection: require_collection(),
      Compass: require_compass(),
      ESC: require_esc(),
      Expander: require_expander(),
      Fn: require_fn(),
      GPS: require_gps(),
      Gyro: require_gyro(),
      Hygrometer: require_hygrometer(),
      SIP: require_sip(),
      Keypad: require_keypad(),
      LCD: require_lcd(),
      Led: require_led2(),
      LedControl: require_ledcontrol(),
      Light: require_light(),
      Joystick: require_joystick(),
      Motion: require_motion(),
      Motor: require_motor(),
      Orientation: require_orientation(),
      Piezo: require_piezo(),
      Pin: require_pin(),
      Proximity: require_proximity(),
      ReflectanceArray: require_reflectancearray(),
      Relay: require_relay(),
      Repl: require_repl(),
      Sensor: require_sensor(),
      Servo: require_servo(),
      ShiftRegister: require_shiftregister(),
      Stepper: require_stepper(),
      Switch: require_switch(),
      Thermometer: require_thermometer()
    };
    module2.exports.Board.Virtual = function(options) {
      let temp;
      if (options instanceof module2.exports.Expander) {
        temp = {
          io: options
        };
      } else {
        temp = options;
      }
      return new module2.exports.Board(Object.assign({}, {
        repl: false,
        debug: false,
        sigint: false
      }, temp));
    };
    module2.exports.Sensor.Analog = module2.exports.Sensor;
    module2.exports.Sensor.Digital = function(options) {
      let pin;
      let type = "digital";
      if (typeof options === "number" || typeof options === "string") {
        pin = options;
        options = {
          type,
          pin
        };
      } else {
        options.type = type;
      }
      return new module2.exports.Sensor(options);
    };
    module2.exports.IMU = module2.exports.SIP;
    module2.exports.Multi = module2.exports.SIP;
    module2.exports.Luxmeter = module2.exports.Light;
    module2.exports.Magnetometer = module2.exports.Compass;
    module2.exports.Ping = module2.exports.Proximity;
    module2.exports.Sonar = module2.exports.Proximity;
    module2.exports.Boards = module2.exports.Board.Collection;
    module2.exports.Buttons = module2.exports.Button.Collection;
    module2.exports.ESCs = module2.exports.ESC.Collection;
    module2.exports.Leds = module2.exports.Led.Collection;
    module2.exports.Led.RGBs = module2.exports.Led.RGB.Collection;
    module2.exports.Motors = module2.exports.Motor.Collection;
    module2.exports.Pins = module2.exports.Pin.Collection;
    module2.exports.Relays = module2.exports.Relay.Collection;
    module2.exports.Sensors = module2.exports.Sensor.Collection;
    module2.exports.Servos = module2.exports.Servo.Collection;
    module2.exports.Switches = module2.exports.Switch.Collection;
    module2.exports.Touchpad = module2.exports.Keypad;
  }
});

// node_modules/oled-font-5x7/oled-font-5x7.js
var require_oled_font_5x7 = __commonJS({
  "node_modules/oled-font-5x7/oled-font-5x7.js"(exports, module2) {
    module2.exports = {
      monospace: true,
      width: 5,
      height: 7,
      fontData: [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        95,
        0,
        0,
        0,
        7,
        0,
        7,
        0,
        20,
        127,
        20,
        127,
        20,
        36,
        42,
        127,
        42,
        18,
        35,
        19,
        8,
        100,
        98,
        54,
        73,
        85,
        34,
        80,
        0,
        5,
        3,
        0,
        0,
        0,
        28,
        34,
        65,
        0,
        0,
        65,
        34,
        28,
        0,
        8,
        42,
        28,
        42,
        8,
        8,
        8,
        62,
        8,
        8,
        0,
        80,
        48,
        0,
        0,
        8,
        8,
        8,
        8,
        8,
        0,
        96,
        96,
        0,
        0,
        32,
        16,
        8,
        4,
        2,
        62,
        81,
        73,
        69,
        62,
        0,
        66,
        127,
        64,
        0,
        66,
        97,
        81,
        73,
        70,
        33,
        65,
        69,
        75,
        49,
        24,
        20,
        18,
        127,
        16,
        39,
        69,
        69,
        69,
        57,
        60,
        74,
        73,
        73,
        48,
        1,
        113,
        9,
        5,
        3,
        54,
        73,
        73,
        73,
        54,
        6,
        73,
        73,
        41,
        30,
        0,
        54,
        54,
        0,
        0,
        0,
        86,
        54,
        0,
        0,
        0,
        8,
        20,
        34,
        65,
        20,
        20,
        20,
        20,
        20,
        65,
        34,
        20,
        8,
        0,
        2,
        1,
        81,
        9,
        6,
        50,
        73,
        121,
        65,
        62,
        126,
        17,
        17,
        17,
        126,
        127,
        73,
        73,
        73,
        54,
        62,
        65,
        65,
        65,
        34,
        127,
        65,
        65,
        34,
        28,
        127,
        73,
        73,
        73,
        65,
        127,
        9,
        9,
        1,
        1,
        62,
        65,
        65,
        81,
        50,
        127,
        8,
        8,
        8,
        127,
        0,
        65,
        127,
        65,
        0,
        32,
        64,
        65,
        63,
        1,
        127,
        8,
        20,
        34,
        65,
        127,
        64,
        64,
        64,
        64,
        127,
        2,
        4,
        2,
        127,
        127,
        4,
        8,
        16,
        127,
        62,
        65,
        65,
        65,
        62,
        127,
        9,
        9,
        9,
        6,
        62,
        65,
        81,
        33,
        94,
        127,
        9,
        25,
        41,
        70,
        70,
        73,
        73,
        73,
        49,
        1,
        1,
        127,
        1,
        1,
        63,
        64,
        64,
        64,
        63,
        31,
        32,
        64,
        32,
        31,
        127,
        32,
        24,
        32,
        127,
        99,
        20,
        8,
        20,
        99,
        3,
        4,
        120,
        4,
        3,
        97,
        81,
        73,
        69,
        67,
        125,
        18,
        18,
        125,
        0,
        61,
        66,
        66,
        66,
        61,
        61,
        64,
        64,
        64,
        61,
        0,
        0,
        127,
        65,
        65,
        2,
        4,
        8,
        16,
        32,
        65,
        65,
        127,
        0,
        0,
        4,
        2,
        1,
        2,
        4,
        64,
        64,
        64,
        64,
        64,
        0,
        1,
        2,
        4,
        0,
        32,
        84,
        84,
        84,
        120,
        127,
        72,
        68,
        68,
        56,
        56,
        68,
        68,
        68,
        32,
        56,
        68,
        68,
        72,
        127,
        56,
        84,
        84,
        84,
        24,
        8,
        126,
        9,
        1,
        2,
        8,
        20,
        84,
        84,
        60,
        127,
        8,
        4,
        4,
        120,
        0,
        68,
        125,
        64,
        0,
        32,
        64,
        68,
        61,
        0,
        0,
        127,
        16,
        40,
        68,
        0,
        65,
        127,
        64,
        0,
        124,
        4,
        24,
        4,
        120,
        124,
        8,
        4,
        4,
        120,
        56,
        68,
        68,
        68,
        56,
        124,
        20,
        20,
        20,
        8,
        8,
        20,
        20,
        24,
        124,
        124,
        8,
        4,
        4,
        8,
        72,
        84,
        84,
        84,
        32,
        4,
        63,
        68,
        64,
        32,
        60,
        64,
        64,
        32,
        124,
        28,
        32,
        64,
        32,
        28,
        60,
        64,
        48,
        64,
        60,
        68,
        40,
        16,
        40,
        68,
        12,
        80,
        80,
        80,
        60,
        68,
        100,
        84,
        76,
        68,
        32,
        85,
        84,
        85,
        120,
        58,
        68,
        68,
        58,
        0,
        58,
        64,
        64,
        58,
        0,
        0,
        8,
        54,
        65,
        0,
        0,
        0,
        127,
        0,
        0,
        0,
        65,
        54,
        8,
        0,
        20,
        62,
        85,
        65,
        34,
        8,
        8,
        42,
        28,
        8,
        8,
        28,
        42,
        8,
        8,
        0,
        0,
        7,
        5,
        7
      ],
      lookup: [
        " ",
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "@",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "\xC4",
        "\xD6",
        "\xDC",
        "[",
        "\\",
        "]",
        "^",
        "_",
        "`",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "\xE4",
        "\xF6",
        "\xFC",
        "{",
        "|",
        "}",
        "\u20AC",
        "\u2020",
        "\u2021",
        "\xB0"
      ]
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/encode.js
var require_encode = __commonJS({
  "../oled-js/node_modules/qr-image/lib/encode.js"(exports, module2) {
    "use strict";
    function pushBits(arr, n, value) {
      for (var bit = 1 << n - 1; bit; bit = bit >>> 1) {
        arr.push(bit & value ? 1 : 0);
      }
    }
    function encode_8bit(data) {
      var len = data.length;
      var bits = [];
      for (var i = 0; i < len; i++) {
        pushBits(bits, 8, data[i]);
      }
      var res = {};
      var d = [0, 1, 0, 0];
      pushBits(d, 16, len);
      res.data10 = res.data27 = d.concat(bits);
      if (len < 256) {
        var d = [0, 1, 0, 0];
        pushBits(d, 8, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    var ALPHANUM = function(s) {
      var res = {};
      for (var i = 0; i < s.length; i++) {
        res[s[i]] = i;
      }
      return res;
    }("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
    function encode_alphanum(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 2) {
        var b = 6;
        var n = ALPHANUM[str[i]];
        if (str[i + 1]) {
          b = 11;
          n = n * 45 + ALPHANUM[str[i + 1]];
        }
        pushBits(bits, b, n);
      }
      var res = {};
      var d = [0, 0, 1, 0];
      pushBits(d, 13, len);
      res.data27 = d.concat(bits);
      if (len < 2048) {
        var d = [0, 0, 1, 0];
        pushBits(d, 11, len);
        res.data10 = d.concat(bits);
      }
      if (len < 512) {
        var d = [0, 0, 1, 0];
        pushBits(d, 9, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_numeric(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 3) {
        var s = str.substr(i, 3);
        var b = Math.ceil(s.length * 10 / 3);
        pushBits(bits, b, parseInt(s, 10));
      }
      var res = {};
      var d = [0, 0, 0, 1];
      pushBits(d, 14, len);
      res.data27 = d.concat(bits);
      if (len < 4096) {
        var d = [0, 0, 0, 1];
        pushBits(d, 12, len);
        res.data10 = d.concat(bits);
      }
      if (len < 1024) {
        var d = [0, 0, 0, 1];
        pushBits(d, 10, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_url(str) {
      var slash = str.indexOf("/", 8) + 1 || str.length;
      var res = encode(str.slice(0, slash).toUpperCase(), false);
      if (slash >= str.length) {
        return res;
      }
      var path_res = encode(str.slice(slash), false);
      res.data27 = res.data27.concat(path_res.data27);
      if (res.data10 && path_res.data10) {
        res.data10 = res.data10.concat(path_res.data10);
      }
      if (res.data1 && path_res.data1) {
        res.data1 = res.data1.concat(path_res.data1);
      }
      return res;
    }
    function encode(data, parse_url) {
      var str;
      var t = typeof data;
      if (t == "string" || t == "number") {
        str = "" + data;
        data = new Buffer(str);
      } else if (Buffer.isBuffer(data)) {
        str = data.toString();
      } else if (Array.isArray(data)) {
        data = new Buffer(data);
        str = data.toString();
      } else {
        throw new Error("Bad data");
      }
      if (/^[0-9]+$/.test(str)) {
        if (data.length > 7089) {
          throw new Error("Too much data");
        }
        return encode_numeric(str);
      }
      if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
        if (data.length > 4296) {
          throw new Error("Too much data");
        }
        return encode_alphanum(str);
      }
      if (parse_url && /^https?:/i.test(str)) {
        return encode_url(str);
      }
      if (data.length > 2953) {
        throw new Error("Too much data");
      }
      return encode_8bit(data);
    }
    module2.exports = encode;
  }
});

// ../oled-js/node_modules/qr-image/lib/errorcode.js
var require_errorcode = __commonJS({
  "../oled-js/node_modules/qr-image/lib/errorcode.js"(exports, module2) {
    "use strict";
    var GF256_BASE = 285;
    var EXP_TABLE = [1];
    var LOG_TABLE = [];
    for (i = 1; i < 256; i++) {
      n = EXP_TABLE[i - 1] << 1;
      if (n > 255)
        n = n ^ GF256_BASE;
      EXP_TABLE[i] = n;
    }
    var n;
    var i;
    for (i = 0; i < 255; i++) {
      LOG_TABLE[EXP_TABLE[i]] = i;
    }
    var i;
    function exp(k) {
      while (k < 0)
        k += 255;
      while (k > 255)
        k -= 255;
      return EXP_TABLE[k];
    }
    function log(k) {
      if (k < 1 || k > 255) {
        throw Error("Bad log(" + k + ")");
      }
      return LOG_TABLE[k];
    }
    var POLYNOMIALS = [
      [0],
      [0, 0],
      [0, 25, 1]
    ];
    function generatorPolynomial(num) {
      if (POLYNOMIALS[num]) {
        return POLYNOMIALS[num];
      }
      var prev = generatorPolynomial(num - 1);
      var res = [];
      res[0] = prev[0];
      for (var i2 = 1; i2 <= num; i2++) {
        res[i2] = log(exp(prev[i2]) ^ exp(prev[i2 - 1] + num - 1));
      }
      POLYNOMIALS[num] = res;
      return res;
    }
    module2.exports = function calculate_ec(msg, ec_len) {
      msg = [].slice.call(msg);
      var poly = generatorPolynomial(ec_len);
      for (var i2 = 0; i2 < ec_len; i2++)
        msg.push(0);
      while (msg.length > ec_len) {
        if (!msg[0]) {
          msg.shift();
          continue;
        }
        var log_k = log(msg[0]);
        for (var i2 = 0; i2 <= ec_len; i2++) {
          msg[i2] = msg[i2] ^ exp(poly[i2] + log_k);
        }
        msg.shift();
      }
      return new Buffer(msg);
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/matrix.js
var require_matrix2 = __commonJS({
  "../oled-js/node_modules/qr-image/lib/matrix.js"(exports, module2) {
    "use strict";
    function init(version) {
      var N = version * 4 + 17;
      var matrix = [];
      var zeros = new Buffer(N);
      zeros.fill(0);
      zeros = [].slice.call(zeros);
      for (var i = 0; i < N; i++) {
        matrix[i] = zeros.slice();
      }
      return matrix;
    }
    function fillFinders(matrix) {
      var N = matrix.length;
      for (var i = -3; i <= 3; i++) {
        for (var j = -3; j <= 3; j++) {
          var max = Math.max(i, j);
          var min = Math.min(i, j);
          var pixel = max == 2 && min >= -2 || min == -2 && max <= 2 ? 128 : 129;
          matrix[3 + i][3 + j] = pixel;
          matrix[3 + i][N - 4 + j] = pixel;
          matrix[N - 4 + i][3 + j] = pixel;
        }
      }
      for (var i = 0; i < 8; i++) {
        matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 128;
      }
    }
    function fillAlignAndTiming(matrix) {
      var N = matrix.length;
      if (N > 21) {
        var len = N - 13;
        var delta = Math.round(len / Math.ceil(len / 28));
        if (delta % 2)
          delta++;
        var res = [];
        for (var p = len + 6; p > 10; p -= delta) {
          res.unshift(p);
        }
        res.unshift(6);
        for (var i = 0; i < res.length; i++) {
          for (var j = 0; j < res.length; j++) {
            var x = res[i], y = res[j];
            if (matrix[x][y])
              continue;
            for (var r = -2; r <= 2; r++) {
              for (var c = -2; c <= 2; c++) {
                var max = Math.max(r, c);
                var min = Math.min(r, c);
                var pixel = max == 1 && min >= -1 || min == -1 && max <= 1 ? 128 : 129;
                matrix[x + r][y + c] = pixel;
              }
            }
          }
        }
      }
      for (var i = 8; i < N - 8; i++) {
        matrix[6][i] = matrix[i][6] = i % 2 ? 128 : 129;
      }
    }
    function fillStub(matrix) {
      var N = matrix.length;
      for (var i = 0; i < 8; i++) {
        if (i != 6) {
          matrix[8][i] = matrix[i][8] = 128;
        }
        matrix[8][N - 1 - i] = 128;
        matrix[N - 1 - i][8] = 128;
      }
      matrix[8][8] = 128;
      matrix[N - 8][8] = 129;
      if (N < 45)
        return;
      for (var i = N - 11; i < N - 8; i++) {
        for (var j = 0; j < 6; j++) {
          matrix[i][j] = matrix[j][i] = 128;
        }
      }
    }
    var fillReserved = function() {
      var FORMATS = Array(32);
      var VERSIONS = Array(40);
      var gf15 = 1335;
      var gf18 = 7973;
      var formats_mask = 21522;
      for (var format = 0; format < 32; format++) {
        var res = format << 10;
        for (var i = 5; i > 0; i--) {
          if (res >>> 9 + i) {
            res = res ^ gf15 << i - 1;
          }
        }
        FORMATS[format] = (res | format << 10) ^ formats_mask;
      }
      for (var version = 7; version <= 40; version++) {
        var res = version << 12;
        for (var i = 6; i > 0; i--) {
          if (res >>> 11 + i) {
            res = res ^ gf18 << i - 1;
          }
        }
        VERSIONS[version] = res | version << 12;
      }
      var EC_LEVELS = { L: 1, M: 0, Q: 3, H: 2 };
      return function fillReserved2(matrix, ec_level, mask) {
        var N = matrix.length;
        var format2 = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
        function F(k) {
          return format2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 8; i2++) {
          matrix[8][N - 1 - i2] = F(i2);
          if (i2 < 6)
            matrix[i2][8] = F(i2);
        }
        for (var i2 = 8; i2 < 15; i2++) {
          matrix[N - 15 + i2][8] = F(i2);
          if (i2 > 8)
            matrix[8][14 - i2] = F(i2);
        }
        matrix[7][8] = F(6);
        matrix[8][8] = F(7);
        matrix[8][7] = F(8);
        var version2 = VERSIONS[(N - 17) / 4];
        if (!version2)
          return;
        function V(k) {
          return version2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 6; i2++) {
          for (var j = 0; j < 3; j++) {
            matrix[N - 11 + j][i2] = matrix[i2][N - 11 + j] = V(i2 * 3 + j);
          }
        }
      };
    }();
    var fillData = function() {
      var MASK_FUNCTIONS = [
        function(i, j) {
          return (i + j) % 2 == 0;
        },
        function(i, j) {
          return i % 2 == 0;
        },
        function(i, j) {
          return j % 3 == 0;
        },
        function(i, j) {
          return (i + j) % 3 == 0;
        },
        function(i, j) {
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
        },
        function(i, j) {
          return i * j % 2 + i * j % 3 == 0;
        },
        function(i, j) {
          return (i * j % 2 + i * j % 3) % 2 == 0;
        },
        function(i, j) {
          return (i * j % 3 + (i + j) % 2) % 2 == 0;
        }
      ];
      return function fillData2(matrix, data, mask) {
        var N = matrix.length;
        var row, col, dir = -1;
        row = col = N - 1;
        var mask_fn = MASK_FUNCTIONS[mask];
        var len = data.blocks[data.blocks.length - 1].length;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.blocks.length; b++) {
            if (data.blocks[b].length <= i)
              continue;
            put(data.blocks[b][i]);
          }
        }
        len = data.ec_len;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.ec.length; b++) {
            put(data.ec[b][i]);
          }
        }
        if (col > -1) {
          do {
            matrix[row][col] = mask_fn(row, col) ? 1 : 0;
          } while (next());
        }
        function put(byte) {
          for (var mask2 = 128; mask2; mask2 = mask2 >> 1) {
            var pixel = !!(mask2 & byte);
            if (mask_fn(row, col))
              pixel = !pixel;
            matrix[row][col] = pixel ? 1 : 0;
            next();
          }
        }
        function next() {
          do {
            if (col % 2 ^ col < 6) {
              if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
                col--;
                dir = -dir;
              } else {
                col++;
                row += dir;
              }
            } else {
              col--;
            }
            if (col == 6) {
              col--;
            }
            if (col < 0) {
              return false;
            }
          } while (matrix[row][col] & 240);
          return true;
        }
      };
    }();
    function calculatePenalty(matrix) {
      var N = matrix.length;
      var penalty = 0;
      for (var i = 0; i < N; i++) {
        var pixel = matrix[i][0] & 1;
        var len = 1;
        for (var j = 1; j < N; j++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var j = 0; j < N; j++) {
        var pixel = matrix[0][j] & 1;
        var len = 1;
        for (var i = 1; i < N; i++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var i = 0; i < N - 1; i++) {
        for (var j = 0; j < N - 1; j++) {
          var s = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
          if (s == 0 || s == 4) {
            penalty += 3;
          }
        }
      }
      function I(k) {
        return matrix[i][j + k] & 1;
      }
      ;
      function J(k) {
        return matrix[i + k][j] & 1;
      }
      ;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
            if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
              penalty += 40;
            }
            if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
              penalty += 40;
            }
          }
          if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
            if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
              penalty += 40;
            }
            if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
              penalty += 40;
            }
          }
        }
      }
      var numDark = 0;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j] & 1)
            numDark++;
        }
      }
      penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
      return penalty;
    }
    function getMatrix(data) {
      var matrix = init(data.version);
      fillFinders(matrix);
      fillAlignAndTiming(matrix);
      fillStub(matrix);
      var penalty = Infinity;
      var bestMask = 0;
      for (var mask = 0; mask < 8; mask++) {
        fillData(matrix, data, mask);
        fillReserved(matrix, data.ec_level, mask);
        var p = calculatePenalty(matrix);
        if (p < penalty) {
          penalty = p;
          bestMask = mask;
        }
      }
      fillData(matrix, data, bestMask);
      fillReserved(matrix, data.ec_level, bestMask);
      return matrix.map(function(row) {
        return row.map(function(cell) {
          return cell & 1;
        });
      });
    }
    module2.exports = {
      getMatrix,
      init,
      fillFinders,
      fillAlignAndTiming,
      fillStub,
      fillReserved,
      fillData,
      calculatePenalty
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/qr-base.js
var require_qr_base = __commonJS({
  "../oled-js/node_modules/qr-image/lib/qr-base.js"(exports, module2) {
    "use strict";
    var encode = require_encode();
    var calculateEC = require_errorcode();
    var matrix = require_matrix2();
    function _deepCopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    var EC_LEVELS = ["L", "M", "Q", "H"];
    var versions = [
      [],
      [26, 7, 1, 10, 1, 13, 1, 17, 1],
      [44, 10, 1, 16, 1, 22, 1, 28, 1],
      [70, 15, 1, 26, 1, 36, 2, 44, 2],
      [100, 20, 1, 36, 2, 52, 2, 64, 4],
      [134, 26, 1, 48, 2, 72, 4, 88, 4],
      [172, 36, 2, 64, 4, 96, 4, 112, 4],
      [196, 40, 2, 72, 4, 108, 6, 130, 5],
      [242, 48, 2, 88, 4, 132, 6, 156, 6],
      [292, 60, 2, 110, 5, 160, 8, 192, 8],
      [346, 72, 4, 130, 5, 192, 8, 224, 8],
      [404, 80, 4, 150, 5, 224, 8, 264, 11],
      [466, 96, 4, 176, 8, 260, 10, 308, 11],
      [532, 104, 4, 198, 9, 288, 12, 352, 16],
      [581, 120, 4, 216, 9, 320, 16, 384, 16],
      [655, 132, 6, 240, 10, 360, 12, 432, 18],
      [733, 144, 6, 280, 10, 408, 17, 480, 16],
      [815, 168, 6, 308, 11, 448, 16, 532, 19],
      [901, 180, 6, 338, 13, 504, 18, 588, 21],
      [991, 196, 7, 364, 14, 546, 21, 650, 25],
      [1085, 224, 8, 416, 16, 600, 20, 700, 25],
      [1156, 224, 8, 442, 17, 644, 23, 750, 25],
      [1258, 252, 9, 476, 17, 690, 23, 816, 34],
      [1364, 270, 9, 504, 18, 750, 25, 900, 30],
      [1474, 300, 10, 560, 20, 810, 27, 960, 32],
      [1588, 312, 12, 588, 21, 870, 29, 1050, 35],
      [1706, 336, 12, 644, 23, 952, 34, 1110, 37],
      [1828, 360, 12, 700, 25, 1020, 34, 1200, 40],
      [1921, 390, 13, 728, 26, 1050, 35, 1260, 42],
      [2051, 420, 14, 784, 28, 1140, 38, 1350, 45],
      [2185, 450, 15, 812, 29, 1200, 40, 1440, 48],
      [2323, 480, 16, 868, 31, 1290, 43, 1530, 51],
      [2465, 510, 17, 924, 33, 1350, 45, 1620, 54],
      [2611, 540, 18, 980, 35, 1440, 48, 1710, 57],
      [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60],
      [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63],
      [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66],
      [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70],
      [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74],
      [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77],
      [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]
    ];
    versions = versions.map(function(v, index) {
      if (!index)
        return {};
      var res = {};
      for (var i = 1; i < 8; i += 2) {
        var length = v[0] - v[i];
        var num_template = v[i + 1];
        var ec_level = EC_LEVELS[i / 2 | 0];
        var level = {
          version: index,
          ec_level,
          data_len: length,
          ec_len: v[i] / num_template,
          blocks: [],
          ec: []
        };
        for (var k = num_template, n = length; k > 0; k--) {
          var block = n / k | 0;
          level.blocks.push(block);
          n -= block;
        }
        res[ec_level] = level;
      }
      return res;
    });
    function getTemplate(message, ec_level) {
      var i = 1;
      var len;
      if (message.data1) {
        len = Math.ceil(message.data1.length / 8);
      } else {
        i = 10;
      }
      for (; i < 10; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      if (message.data10) {
        len = Math.ceil(message.data10.length / 8);
      } else {
        i = 27;
      }
      for (; i < 27; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      len = Math.ceil(message.data27.length / 8);
      for (; i < 41; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      throw new Error("Too much data");
    }
    function fillTemplate(message, template) {
      var blocks = new Buffer(template.data_len);
      blocks.fill(0);
      if (template.version < 10) {
        message = message.data1;
      } else if (template.version < 27) {
        message = message.data10;
      } else {
        message = message.data27;
      }
      var len = message.length;
      for (var i = 0; i < len; i += 8) {
        var b = 0;
        for (var j = 0; j < 8; j++) {
          b = b << 1 | (message[i + j] ? 1 : 0);
        }
        blocks[i / 8] = b;
      }
      var pad = 236;
      for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
        blocks[i] = pad;
        pad = pad == 236 ? 17 : 236;
      }
      var offset = 0;
      template.blocks = template.blocks.map(function(n) {
        var b2 = blocks.slice(offset, offset + n);
        offset += n;
        template.ec.push(calculateEC(b2, template.ec_len));
        return b2;
      });
      return template;
    }
    function QR(text, ec_level, parse_url) {
      ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : "M";
      var message = encode(text, parse_url);
      var data = fillTemplate(message, getTemplate(message, ec_level));
      return matrix.getMatrix(data);
    }
    module2.exports = {
      QR,
      getTemplate,
      fillTemplate
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/crc32buffer.js
var require_crc32buffer = __commonJS({
  "../oled-js/node_modules/qr-image/lib/crc32buffer.js"(exports, module2) {
    "use strict";
    var crc_table = [];
    for (n = 0; n < 256; n++) {
      c = crc_table[n] = new Buffer(4);
      c.writeUInt32BE(n, 0);
      for (k = 0; k < 8; k++) {
        b0 = c[0] & 1;
        b1 = c[1] & 1;
        b2 = c[2] & 1;
        b3 = c[3] & 1;
        c[0] = c[0] >> 1 ^ (b3 ? 237 : 0);
        c[1] = c[1] >> 1 ^ (b3 ? 184 : 0) ^ (b0 ? 128 : 0);
        c[2] = c[2] >> 1 ^ (b3 ? 131 : 0) ^ (b1 ? 128 : 0);
        c[3] = c[3] >> 1 ^ (b3 ? 32 : 0) ^ (b2 ? 128 : 0);
      }
    }
    var c;
    var b0;
    var b1;
    var b2;
    var b3;
    var k;
    var n;
    function update(c2, buf) {
      var l = buf.length;
      for (var n2 = 0; n2 < l; n2++) {
        var e = crc_table[c2[3] ^ buf[n2]];
        c2[3] = e[3] ^ c2[2];
        c2[2] = e[2] ^ c2[1];
        c2[1] = e[1] ^ c2[0];
        c2[0] = e[0];
      }
    }
    function crc32() {
      var l = arguments.length;
      var c2 = new Buffer(4);
      c2.fill(255);
      for (var i = 0; i < l; i++) {
        update(c2, new Buffer(arguments[i]));
      }
      c2[0] = c2[0] ^ 255;
      c2[1] = c2[1] ^ 255;
      c2[2] = c2[2] ^ 255;
      c2[3] = c2[3] ^ 255;
      return c2.readUInt32BE(0);
    }
    module2.exports = crc32;
  }
});

// ../oled-js/node_modules/qr-image/lib/crc32.js
var require_crc32 = __commonJS({
  "../oled-js/node_modules/qr-image/lib/crc32.js"(exports, module2) {
    "use strict";
    (function() {
      if (process.arch === "arm") {
        module2.exports = require_crc32buffer();
        return;
      }
      var crc_table = [];
      (function() {
        for (var n = 0; n < 256; n++) {
          var c = n;
          for (var k = 0; k < 8; k++) {
            if (c & 1) {
              c = 3988292384 ^ c >>> 1;
            } else {
              c = c >>> 1;
            }
          }
          crc_table[n] = c >>> 0;
        }
      })();
      function update(c, buf) {
        var l = buf.length;
        for (var n = 0; n < l; n++) {
          c = crc_table[(c ^ buf[n]) & 255] ^ c >>> 8;
        }
        return c;
      }
      function crc32() {
        var l = arguments.length;
        var c = -1;
        for (var i = 0; i < l; i++) {
          c = update(c, new Buffer(arguments[i]));
        }
        c = (c ^ -1) >>> 0;
        return c;
      }
      module2.exports = crc32;
    })();
  }
});

// ../oled-js/node_modules/qr-image/lib/png.js
var require_png = __commonJS({
  "../oled-js/node_modules/qr-image/lib/png.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var crc32 = require_crc32();
    var PNG_HEAD = new Buffer([137, 80, 78, 71, 13, 10, 26, 10]);
    var PNG_IHDR = new Buffer([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0]);
    var PNG_IDAT = new Buffer([0, 0, 0, 0, 73, 68, 65, 84]);
    var PNG_IEND = new Buffer([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
    function png(bitmap2, stream) {
      stream.push(PNG_HEAD);
      var IHDR = Buffer.concat([PNG_IHDR]);
      IHDR.writeUInt32BE(bitmap2.size, 8);
      IHDR.writeUInt32BE(bitmap2.size, 12);
      IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
      stream.push(IHDR);
      var IDAT = Buffer.concat([
        PNG_IDAT,
        zlib.deflateSync(bitmap2.data, { level: 9 }),
        new Buffer(4)
      ]);
      IDAT.writeUInt32BE(IDAT.length - 12, 0);
      IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
      stream.push(IDAT);
      stream.push(PNG_IEND);
      stream.push(null);
    }
    function bitmap(matrix, size, margin) {
      var N = matrix.length;
      var X = (N + 2 * margin) * size;
      var data = new Buffer((X + 1) * X);
      data.fill(255);
      for (var i = 0; i < X; i++) {
        data[i * (X + 1)] = 0;
      }
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j]) {
            var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
            data.fill(0, offset, offset + size);
            for (var c = 1; c < size; c++) {
              data.copy(data, offset + c * (X + 1), offset, offset + size);
            }
          }
        }
      }
      return {
        data,
        size: X
      };
    }
    module2.exports = {
      bitmap,
      png
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/vector.js
var require_vector = __commonJS({
  "../oled-js/node_modules/qr-image/lib/vector.js"(exports, module2) {
    "use strict";
    function matrix2path(matrix) {
      var N = matrix.length;
      var filled = [];
      for (var row = -1; row <= N; row++) {
        filled[row] = [];
      }
      var path = [];
      for (var row = 0; row < N; row++) {
        for (var col = 0; col < N; col++) {
          if (filled[row][col])
            continue;
          filled[row][col] = 1;
          if (isDark(row, col)) {
            if (!isDark(row - 1, col)) {
              path.push(plot(row, col, "right"));
            }
          } else {
            if (isDark(row, col - 1)) {
              path.push(plot(row, col, "down"));
            }
          }
        }
      }
      return path;
      function isDark(row2, col2) {
        if (row2 < 0 || col2 < 0 || row2 >= N || col2 >= N)
          return false;
        return !!matrix[row2][col2];
      }
      function plot(row0, col0, dir) {
        filled[row0][col0] = 1;
        var res = [];
        res.push(["M", col0, row0]);
        var row2 = row0;
        var col2 = col0;
        var len = 0;
        do {
          switch (dir) {
            case "right":
              filled[row2][col2] = 1;
              if (isDark(row2, col2)) {
                filled[row2 - 1][col2] = 1;
                if (isDark(row2 - 1, col2)) {
                  res.push(["h", len]);
                  len = 0;
                  dir = "up";
                } else {
                  len++;
                  col2++;
                }
              } else {
                res.push(["h", len]);
                len = 0;
                dir = "down";
              }
              break;
            case "left":
              filled[row2 - 1][col2 - 1] = 1;
              if (isDark(row2 - 1, col2 - 1)) {
                filled[row2][col2 - 1] = 1;
                if (isDark(row2, col2 - 1)) {
                  res.push(["h", -len]);
                  len = 0;
                  dir = "down";
                } else {
                  len++;
                  col2--;
                }
              } else {
                res.push(["h", -len]);
                len = 0;
                dir = "up";
              }
              break;
            case "down":
              filled[row2][col2 - 1] = 1;
              if (isDark(row2, col2 - 1)) {
                filled[row2][col2] = 1;
                if (isDark(row2, col2)) {
                  res.push(["v", len]);
                  len = 0;
                  dir = "right";
                } else {
                  len++;
                  row2++;
                }
              } else {
                res.push(["v", len]);
                len = 0;
                dir = "left";
              }
              break;
            case "up":
              filled[row2 - 1][col2] = 1;
              if (isDark(row2 - 1, col2)) {
                filled[row2 - 1][col2 - 1] = 1;
                if (isDark(row2 - 1, col2 - 1)) {
                  res.push(["v", -len]);
                  len = 0;
                  dir = "left";
                } else {
                  len++;
                  row2--;
                }
              } else {
                res.push(["v", -len]);
                len = 0;
                dir = "right";
              }
              break;
          }
        } while (row2 != row0 || col2 != col0);
        return res;
      }
    }
    function pushSVGPath(matrix, stream, margin) {
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += "M" + (item[1] + margin) + " " + (item[2] + margin);
              break;
            default:
              res += item.join("");
          }
        }
        res += "z";
        stream.push(res);
      });
    }
    function SVG_object(matrix, margin) {
      var stream = [];
      pushSVGPath(matrix, stream, margin);
      var result = {
        size: matrix.length + 2 * margin,
        path: stream.filter(Boolean).join("")
      };
      return result;
    }
    function SVG(matrix, stream, margin, size) {
      var X = matrix.length + 2 * margin;
      stream.push('<svg xmlns="http://www.w3.org/2000/svg" ');
      if (size > 0) {
        var XY = X * size;
        stream.push('width="' + XY + '" height="' + XY + '" ');
      }
      stream.push('viewBox="0 0 ' + X + " " + X + '">');
      stream.push('<path d="');
      pushSVGPath(matrix, stream, margin);
      stream.push('"/></svg>');
      stream.push(null);
    }
    function EPS(matrix, stream, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      stream.push([
        "%!PS-Adobe-3.0 EPSF-3.0",
        "%%BoundingBox: 0 0 " + X + " " + X,
        "/h { 0 rlineto } bind def",
        "/v { 0 exch neg rlineto } bind def",
        "/M { neg " + (N + margin) + " add moveto } bind def",
        "/z { closepath } bind def",
        scale + " " + scale + " scale",
        ""
      ].join("\n"));
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += item[1] + margin + " " + item[2] + " M ";
              break;
            default:
              res += item[1] + " " + item[0] + " ";
          }
        }
        res += "z\n";
        stream.push(res);
      });
      stream.push("fill\n%%EOF\n");
      stream.push(null);
    }
    function PDF(matrix, stream, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      var data = [
        "%PDF-1.0\n\n",
        "1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n",
        "2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n"
      ];
      data.push("3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> /Contents 4 0 R /MediaBox [ 0 0 " + X + " " + X + " ] >> endobj\n");
      var path = scale + " 0 0 " + scale + " 0 0 cm\n";
      path += matrix2path(matrix).map(function(subpath) {
        var res = "";
        var x, y;
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              x = item[1] + margin;
              y = N - item[2] + margin;
              res += x + " " + y + " m ";
              break;
            case "h":
              x += item[1];
              res += x + " " + y + " l ";
              break;
            case "v":
              y -= item[1];
              res += x + " " + y + " l ";
              break;
          }
        }
        res += "h";
        return res;
      }).join("\n");
      path += "\nf\n";
      data.push("4 0 obj << /Length " + path.length + " >> stream\n" + path + "endstream\nendobj\n");
      var xref = "xref\n0 5\n0000000000 65535 f \n";
      for (var i = 1, l = data[0].length; i < 5; i++) {
        xref += ("0000000000" + l).substr(-10) + " 00000 n \n";
        l += data[i].length;
      }
      data.push(xref, "trailer << /Root 1 0 R /Size 5 >>\n", "startxref\n" + l + "\n%%EOF\n");
      stream.push(data.join(""));
      stream.push(null);
    }
    module2.exports = {
      svg: SVG,
      eps: EPS,
      pdf: PDF,
      svg_object: SVG_object
    };
  }
});

// ../oled-js/node_modules/qr-image/lib/qr.js
var require_qr = __commonJS({
  "../oled-js/node_modules/qr-image/lib/qr.js"(exports, module2) {
    "use strict";
    var Readable2 = require("stream").Readable;
    var QR = require_qr_base().QR;
    var png = require_png();
    var vector = require_vector();
    var fn_noop = function() {
    };
    var BITMAP_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      size: 5,
      margin: 4,
      customize: null
    };
    var VECTOR_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      margin: 1,
      size: 0
    };
    function get_options(options, force_type) {
      if (typeof options === "string") {
        options = { "ec_level": options };
      } else {
        options = options || {};
      }
      var _options = {
        type: String(force_type || options.type || "png").toLowerCase()
      };
      var defaults = _options.type == "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
      for (var k in defaults) {
        _options[k] = k in options ? options[k] : defaults[k];
      }
      return _options;
    }
    function qr_image(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var stream = new Readable2();
      stream._read = fn_noop;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          process.nextTick(function() {
            vector[options.type](matrix, stream, options.margin, options.size);
          });
          break;
        case "svgpath":
          process.nextTick(function() {
            var obj = vector.svg_object(matrix, options.margin, options.size);
            stream.push(obj.path);
            stream.push(null);
          });
          break;
        case "png":
        default:
          process.nextTick(function() {
            var bitmap = png.bitmap(matrix, options.size, options.margin);
            if (options.customize) {
              options.customize(bitmap);
            }
            png.png(bitmap, stream);
          });
      }
      return stream;
    }
    function qr_image_sync(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var stream = [];
      var result;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          vector[options.type](matrix, stream, options.margin, options.size);
          result = stream.filter(Boolean).join("");
          break;
        case "png":
        default:
          var bitmap = png.bitmap(matrix, options.size, options.margin);
          if (options.customize) {
            options.customize(bitmap);
          }
          png.png(bitmap, stream);
          result = Buffer.concat(stream.filter(Boolean));
      }
      return result;
    }
    function svg_object(text, options) {
      options = get_options(options, "svg");
      var matrix = QR(text, options.ec_level);
      return vector.svg_object(matrix, options.margin);
    }
    module2.exports = {
      matrix: QR,
      image: qr_image,
      imageSync: qr_image_sync,
      svgObject: svg_object
    };
  }
});

// ../oled-js/build/oled.js
var require_oled = __commonJS({
  "../oled-js/build/oled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var qr2 = null;
    try {
      qr2 = require_qr();
    } catch (err) {
    }
    var Protocol;
    (function(Protocol2) {
      Protocol2[Protocol2["I2C"] = 0] = "I2C";
      Protocol2[Protocol2["SPI"] = 1] = "SPI";
    })(Protocol || (Protocol = {}));
    var TransferType;
    (function(TransferType2) {
      TransferType2[TransferType2["Command"] = 0] = "Command";
      TransferType2[TransferType2["Data"] = 1] = "Data";
    })(TransferType || (TransferType = {}));
    var Oled2 = function() {
      function Oled3(board, five5, opts) {
        this.HEIGHT = opts.height || 32;
        this.WIDTH = opts.width || 128;
        this.ADDRESS = opts.address || 60;
        this.PROTOCOL = opts.address ? Protocol.I2C : Protocol.SPI;
        this.MICROVIEW = opts.microview || false;
        this.SECONDARYPIN = opts.secondaryPin || 12;
        this.RESETPIN = opts.resetPin === void 0 ? 4 : opts.resetPin;
        this.DATA = opts.data || 64;
        this.COMMAND = opts.command || 0;
        this.cursor_x = 0;
        this.cursor_y = 0;
        this.buffer = Buffer.alloc(this.WIDTH * this.HEIGHT / 8);
        this.buffer.fill(0);
        this.dirtyBytes = [];
        this.board = board;
        this.five = five5;
        var config = {
          "128x32": {
            multiplex: 31,
            compins: 2,
            coloffset: 0
          },
          "128x64": {
            multiplex: 63,
            compins: 18,
            coloffset: 0
          },
          "96x16": {
            multiplex: 15,
            compins: 2,
            coloffset: 0
          },
          "64x48": {
            multiplex: 47,
            compins: 18,
            coloffset: this.MICROVIEW ? 32 : 0
          }
        };
        if (this.MICROVIEW) {
          this.SPIconfig = {
            dcPin: 8,
            ssPin: 10,
            rstPin: 7,
            clkPin: 13,
            mosiPin: 11
          };
        } else if (this.PROTOCOL === Protocol.SPI) {
          this.SPIconfig = {
            dcPin: 11,
            ssPin: this.SECONDARYPIN,
            rstPin: 13,
            clkPin: 10,
            mosiPin: 9
          };
        }
        var screenSize = "".concat(this.WIDTH, "x").concat(this.HEIGHT);
        this.screenConfig = config[screenSize];
        if (this.PROTOCOL === Protocol.I2C) {
          this._setUpI2C(opts);
        } else {
          this._setUpSPI();
        }
        this._initialise();
      }
      Oled3.prototype._initialise = function() {
        var initSeq = [
          Oled3.DISPLAY_OFF,
          Oled3.SET_DISPLAY_CLOCK_DIV,
          128,
          Oled3.SET_MULTIPLEX,
          this.screenConfig.multiplex,
          Oled3.SET_DISPLAY_OFFSET,
          0,
          Oled3.SET_START_LINE,
          Oled3.CHARGE_PUMP,
          20,
          Oled3.MEMORY_MODE,
          0,
          Oled3.SEG_REMAP,
          Oled3.COM_SCAN_DEC,
          Oled3.SET_COM_PINS,
          this.screenConfig.compins,
          Oled3.SET_CONTRAST,
          143,
          Oled3.SET_PRECHARGE,
          241,
          Oled3.SET_VCOM_DETECT,
          64,
          Oled3.DISPLAY_ALL_ON_RESUME,
          Oled3.NORMAL_DISPLAY,
          Oled3.DISPLAY_ON
        ];
        for (var i = 0; i < initSeq.length; i++) {
          this._transfer(TransferType.Command, initSeq[i]);
        }
      };
      Oled3.prototype._setUpSPI = function() {
        this.dcPin = new this.five.Pin(this.SPIconfig.dcPin);
        this.ssPin = new this.five.Pin(this.SPIconfig.ssPin);
        this.clkPin = new this.five.Pin(this.SPIconfig.clkPin);
        this.mosiPin = new this.five.Pin(this.SPIconfig.mosiPin);
        this.rstPin = new this.five.Pin(this.SPIconfig.rstPin);
        this.rstPin.low();
        this.rstPin.high();
        this.ssPin.high();
      };
      Oled3.prototype._setUpI2C = function(opts) {
        this.board.io.i2cConfig(opts);
        if (this.rstPin) {
          this.rstPin = new this.five.Pin({
            pin: this.RESETPIN,
            board: this.board
          });
          this.rstPin.low();
          this.rstPin.high();
        }
      };
      Oled3.prototype._transfer = function(type, val) {
        var control;
        if (type === TransferType.Data) {
          control = this.DATA;
        } else if (type === TransferType.Command) {
          control = this.COMMAND;
        } else {
          return;
        }
        if (this.PROTOCOL === Protocol.I2C) {
          this.board.io.i2cWrite(this.ADDRESS, [control, val]);
        } else {
          this._writeSPI(val, type);
        }
      };
      Oled3.prototype._writeSPI = function(byte, mode) {
        if (mode === TransferType.Command) {
          this.dcPin.low();
        } else {
          this.dcPin.high();
        }
        this.ssPin.low();
        for (var bit = 7; bit >= 0; bit--) {
          this.clkPin.low();
          if (byte & 1 << bit) {
            this.mosiPin.high();
          } else {
            this.mosiPin.low();
          }
          this.clkPin.high();
        }
        this.ssPin.high();
      };
      Oled3.prototype._readI2C = function(fn) {
        this.board.io.i2cReadOnce(this.ADDRESS, 1, function(data) {
          fn(data);
        });
      };
      Oled3.prototype._waitUntilReady = function(callback) {
        var oled = this;
        var tick = function(callback2) {
          oled._readI2C(function(byte) {
            var busy = byte >> 7 & 1;
            if (!busy) {
              callback2();
            } else {
              console.log("I'm busy!");
              setTimeout(tick, 0);
            }
          });
        };
        if (this.PROTOCOL === Protocol.I2C) {
          setTimeout(function() {
            tick(callback);
          }, 0);
        } else {
          callback();
        }
      };
      Oled3.prototype.setCursor = function(x, y) {
        this.cursor_x = x;
        this.cursor_y = y;
      };
      Oled3.prototype._invertColor = function(color) {
        return color === 0 ? 1 : 0;
      };
      Oled3.prototype.writeString = function(font2, size, string, color, wrap, linespacing, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        var wordArr = string.split(" ");
        var len = wordArr.length;
        var offset = this.cursor_x;
        var padding = 0;
        var letspace = 1;
        var leading = linespacing || 2;
        for (var i = 0; i < len; i += 1) {
          if (i < len - 1)
            wordArr[i] += " ";
          var stringArr = wordArr[i].split("");
          var slen = stringArr.length;
          var compare = font2.width * size * slen + size * (len - 1);
          if (wrap && len > 1 && offset >= this.WIDTH - compare) {
            offset = 1;
            this.cursor_y += font2.height * size + size + leading;
            this.setCursor(offset, this.cursor_y);
          }
          for (var i_1 = 0; i_1 < slen; i_1 += 1) {
            var charBuf = this._findCharBuf(font2, stringArr[i_1]);
            var charBytes = this._readCharBytes(charBuf);
            this._drawChar(font2, charBytes, size, color, false);
            this.fillRect(offset - padding, this.cursor_y, padding, font2.height * size, this._invertColor(color), false);
            padding = stringArr[i_1] === " " ? 0 : size + letspace;
            offset += font2.width * size + padding;
            if (wrap && offset >= this.WIDTH - font2.width - letspace) {
              offset = 1;
              this.cursor_y += font2.height * size + size + leading;
            }
            this.setCursor(offset, this.cursor_y);
          }
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype._drawChar = function(font2, byteArray, size, color, sync) {
        var x = this.cursor_x;
        var y = this.cursor_y;
        var c = 0;
        var pagePos = 0;
        for (var i = 0; i < byteArray.length; i += 1) {
          pagePos = Math.floor(i / font2.width) * 8;
          for (var j = 0; j < 8; j += 1) {
            var pixelState = byteArray[i][j] === 1 ? color : this._invertColor(color);
            var xpos = void 0;
            var ypos = void 0;
            if (size === 1) {
              xpos = x + c;
              ypos = y + j + pagePos;
              this.drawPixel([xpos, ypos, pixelState], false);
            } else {
              xpos = x + i * size;
              ypos = y + j * size;
              this.fillRect(xpos, ypos, size, size, pixelState, false);
            }
          }
          c = c < font2.width - 1 ? c += 1 : 0;
        }
      };
      Oled3.prototype._readCharBytes = function(byteArray) {
        var bitArr = [];
        var bitCharArr = [];
        for (var i = 0; i < byteArray.length; i += 1) {
          var byte = byteArray[i];
          for (var j = 0; j < 8; j += 1) {
            var bit = byte >> j & 1;
            bitArr.push(bit);
          }
          bitCharArr.push(bitArr);
          bitArr = [];
        }
        return bitCharArr;
      };
      Oled3.prototype._findCharBuf = function(font2, c) {
        var charLength = Math.ceil(font2.width * font2.height / 8);
        var cBufPos = font2.lookup.indexOf(c) * charLength;
        return font2.fontData.slice(cBufPos, cBufPos + charLength);
      };
      Oled3.prototype.update = function() {
        var _this = this;
        this._waitUntilReady(function() {
          var displaySeq = [
            Oled3.COLUMN_ADDR,
            _this.screenConfig.coloffset,
            _this.screenConfig.coloffset + _this.WIDTH - 1,
            Oled3.PAGE_ADDR,
            0,
            _this.HEIGHT / 8 - 1
          ];
          var displaySeqLen = displaySeq.length;
          var bufferLen = _this.buffer.length;
          for (var i = 0; i < displaySeqLen; i += 1) {
            _this._transfer(TransferType.Command, displaySeq[i]);
          }
          for (var i = 0; i < bufferLen; i += 1) {
            _this._transfer(TransferType.Data, _this.buffer[i]);
          }
        });
        this.dirtyBytes = [];
      };
      Oled3.prototype.updateDirty = function() {
        this._updateDirtyBytes(this.dirtyBytes);
      };
      Oled3.prototype.dimDisplay = function(bool) {
        var contrast;
        if (bool) {
          contrast = 0;
        } else {
          contrast = 207;
        }
        this._transfer(TransferType.Command, Oled3.SET_CONTRAST);
        this._transfer(TransferType.Command, contrast);
      };
      Oled3.prototype.turnOffDisplay = function() {
        this._transfer(TransferType.Command, Oled3.DISPLAY_OFF);
      };
      Oled3.prototype.turnOnDisplay = function() {
        this._transfer(TransferType.Command, Oled3.DISPLAY_ON);
      };
      Oled3.prototype.clearDisplay = function(sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        for (var i = 0; i < this.buffer.length; i += 1) {
          if (this.buffer[i] !== 0) {
            this.buffer[i] = 0;
            if (this.dirtyBytes.indexOf(i) === -1) {
              this.dirtyBytes.push(i);
            }
          }
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype.invertDisplay = function(bool) {
        if (bool) {
          this._transfer(TransferType.Command, Oled3.INVERT_DISPLAY);
        } else {
          this._transfer(TransferType.Command, Oled3.NORMAL_DISPLAY);
        }
      };
      Oled3.prototype.drawBitmap = function(pixels, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        for (var i = 0; i < pixels.length; i++) {
          var x = Math.floor(i % this.WIDTH);
          var y = Math.floor(i / this.WIDTH);
          this.drawPixel([x, y, pixels[i]], false);
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype._isSinglePixel = function(pixels) {
        return typeof pixels[0] !== "object";
      };
      Oled3.prototype.drawPixel = function(pixels, sync) {
        var _this = this;
        var immed = typeof sync === "undefined" ? true : sync;
        if (this._isSinglePixel(pixels))
          pixels = [pixels];
        pixels.forEach(function(el) {
          var x = el[0], y = el[1], color = el[2];
          if (x > _this.WIDTH || y > _this.HEIGHT)
            return;
          var byte = 0;
          var page = Math.floor(y / 8);
          var pageShift = 1 << y - 8 * page;
          page === 0 ? byte = x : byte = x + _this.WIDTH * page;
          if (color === 0) {
            _this.buffer[byte] &= ~pageShift;
          } else {
            _this.buffer[byte] |= pageShift;
          }
          if (_this.dirtyBytes.indexOf(byte) === -1) {
            _this.dirtyBytes.push(byte);
          }
        }, this);
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype._updateDirtyBytes = function(byteArray) {
        var _this = this;
        var blen = byteArray.length;
        this._waitUntilReady(function() {
          var pageStart = Infinity;
          var pageEnd = 0;
          var colStart = Infinity;
          var colEnd = 0;
          var any = false;
          for (var i = 0; i < blen; i += 1) {
            var b = byteArray[i];
            if (b >= 0 && b < _this.buffer.length) {
              var page = b / _this.WIDTH | 0;
              if (page < pageStart)
                pageStart = page;
              if (page > pageEnd)
                pageEnd = page;
              var col = b % _this.WIDTH;
              if (col < colStart)
                colStart = col;
              if (col > colEnd)
                colEnd = col;
              any = true;
            }
          }
          if (!any)
            return;
          var displaySeq = [
            Oled3.COLUMN_ADDR,
            colStart,
            colEnd,
            Oled3.PAGE_ADDR,
            pageStart,
            pageEnd
          ];
          var displaySeqLen = displaySeq.length;
          for (var i = 0; i < displaySeqLen; i += 1) {
            _this._transfer(TransferType.Command, displaySeq[i]);
          }
          for (var i = pageStart; i <= pageEnd; i += 1) {
            for (var j = colStart; j <= colEnd; j += 1) {
              _this._transfer(TransferType.Data, _this.buffer[_this.WIDTH * i + j]);
            }
          }
        });
        this.dirtyBytes = [];
      };
      Oled3.prototype.drawLine = function(x0, y0, x1, y1, color, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        var dx = Math.abs(x1 - x0);
        var sx = x0 < x1 ? 1 : -1;
        var dy = Math.abs(y1 - y0);
        var sy = y0 < y1 ? 1 : -1;
        var err = (dx > dy ? dx : -dy) / 2;
        while (true) {
          this.drawPixel([x0, y0, color], false);
          if (x0 === x1 && y0 === y1)
            break;
          var e2 = err;
          if (e2 > -dx) {
            err -= dy;
            x0 += sx;
          }
          if (e2 < dy) {
            err += dx;
            y0 += sy;
          }
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype.drawRect = function(x, y, w, h, color, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        this.drawLine(x, y, x + w, y, color, false);
        this.drawLine(x, y + 1, x, y + h - 1, color, false);
        this.drawLine(x + w, y + 1, x + w, y + h - 1, color, false);
        this.drawLine(x, y + h - 1, x + w, y + h - 1, color, false);
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype.drawQRCode = function(x, y, data, margin, sync) {
        if (margin === void 0) {
          margin = 4;
        }
        if (qr2) {
          var immed = typeof sync === "undefined" ? true : sync;
          var matrix = qr2.matrix(data);
          var pixels = matrix.flat();
          var bitmap = pixels.map(function(pixel) {
            return pixel ? 0 : 1;
          });
          var width = Math.sqrt(pixels.length);
          this.fillRect(x, y, width + margin * 2, width + margin * 2, 1);
          for (var i = 0; i < bitmap.length; i++) {
            var px = Math.floor(i % width);
            var py = Math.floor(i / width);
            px += margin + x;
            py += margin + y;
            this.drawPixel([px, py, bitmap[i]], false);
          }
          if (immed) {
            this._updateDirtyBytes(this.dirtyBytes);
          }
        } else {
          console.log("Missing optional dependency: qr-image");
        }
      };
      Oled3.prototype.fillRect = function(x, y, w, h, color, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        for (var i = x; i < x + w; i += 1) {
          this.drawLine(i, y, i, y + h - 1, color, false);
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype.drawCircle = function(x0, y0, r, color, sync) {
        var immed = typeof sync === "undefined" ? true : sync;
        var f = 1 - r;
        var ddF_x = 1;
        var ddF_y = -2 * r;
        var x = 0;
        var y = r;
        this.drawPixel([
          [x0, y0 + r, color],
          [x0, y0 - r, color],
          [x0 + r, y0, color],
          [x0 - r, y0, color]
        ], false);
        while (x < y) {
          if (f >= 0) {
            y--;
            ddF_y += 2;
            f += ddF_y;
          }
          x++;
          ddF_x += 2;
          f += ddF_x;
          this.drawPixel([
            [x0 + x, y0 + y, color],
            [x0 - x, y0 + y, color],
            [x0 + x, y0 - y, color],
            [x0 - x, y0 - y, color],
            [x0 + y, y0 + x, color],
            [x0 - y, y0 + x, color],
            [x0 + y, y0 - x, color],
            [x0 - y, y0 - x, color]
          ], false);
        }
        if (immed) {
          this._updateDirtyBytes(this.dirtyBytes);
        }
      };
      Oled3.prototype.startScroll = function(dir, start, stop) {
        var _this = this;
        var cmdSeq = [];
        switch (dir) {
          case "right":
            cmdSeq.push(Oled3.RIGHT_HORIZONTAL_SCROLL);
            break;
          case "left":
            cmdSeq.push(Oled3.LEFT_HORIZONTAL_SCROLL);
            break;
          case "left diagonal":
            cmdSeq.push(Oled3.SET_VERTICAL_SCROLL_AREA, 0, this.HEIGHT, Oled3.VERTICAL_AND_LEFT_HORIZONTAL_SCROLL, 0, start, 0, stop, 1, Oled3.ACTIVATE_SCROLL);
            break;
          case "right diagonal":
            cmdSeq.push(Oled3.SET_VERTICAL_SCROLL_AREA, 0, this.HEIGHT, Oled3.VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL, 0, start, 0, stop, 1, Oled3.ACTIVATE_SCROLL);
            break;
        }
        this._waitUntilReady(function() {
          if (dir === "right" || dir === "left") {
            cmdSeq.push(0, start, 0, stop, 0, 255, Oled3.ACTIVATE_SCROLL);
          }
          for (var i = 0; i < cmdSeq.length; i += 1) {
            _this._transfer(TransferType.Command, cmdSeq[i]);
          }
        });
      };
      Oled3.prototype.stopScroll = function() {
        this._transfer(TransferType.Command, Oled3.DEACTIVATE_SCROLL);
      };
      Oled3.DISPLAY_OFF = 174;
      Oled3.DISPLAY_ON = 175;
      Oled3.SET_DISPLAY_CLOCK_DIV = 213;
      Oled3.SET_MULTIPLEX = 168;
      Oled3.SET_DISPLAY_OFFSET = 211;
      Oled3.SET_START_LINE = 0;
      Oled3.CHARGE_PUMP = 141;
      Oled3.EXTERNAL_VCC = false;
      Oled3.MEMORY_MODE = 32;
      Oled3.SEG_REMAP = 161;
      Oled3.COM_SCAN_DEC = 200;
      Oled3.COM_SCAN_INC = 192;
      Oled3.SET_COM_PINS = 218;
      Oled3.SET_CONTRAST = 129;
      Oled3.SET_PRECHARGE = 217;
      Oled3.SET_VCOM_DETECT = 219;
      Oled3.DISPLAY_ALL_ON_RESUME = 164;
      Oled3.NORMAL_DISPLAY = 166;
      Oled3.COLUMN_ADDR = 33;
      Oled3.PAGE_ADDR = 34;
      Oled3.INVERT_DISPLAY = 167;
      Oled3.ACTIVATE_SCROLL = 47;
      Oled3.DEACTIVATE_SCROLL = 46;
      Oled3.SET_VERTICAL_SCROLL_AREA = 163;
      Oled3.RIGHT_HORIZONTAL_SCROLL = 38;
      Oled3.LEFT_HORIZONTAL_SCROLL = 39;
      Oled3.VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL = 41;
      Oled3.VERTICAL_AND_LEFT_HORIZONTAL_SCROLL = 42;
      return Oled3;
    }();
    exports.default = Oled2;
  }
});

// node_modules/qr-image/lib/encode.js
var require_encode2 = __commonJS({
  "node_modules/qr-image/lib/encode.js"(exports, module2) {
    "use strict";
    function pushBits(arr, n, value) {
      for (var bit = 1 << n - 1; bit; bit = bit >>> 1) {
        arr.push(bit & value ? 1 : 0);
      }
    }
    function encode_8bit(data) {
      var len = data.length;
      var bits = [];
      for (var i = 0; i < len; i++) {
        pushBits(bits, 8, data[i]);
      }
      var res = {};
      var d = [0, 1, 0, 0];
      pushBits(d, 16, len);
      res.data10 = res.data27 = d.concat(bits);
      if (len < 256) {
        var d = [0, 1, 0, 0];
        pushBits(d, 8, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    var ALPHANUM = function(s) {
      var res = {};
      for (var i = 0; i < s.length; i++) {
        res[s[i]] = i;
      }
      return res;
    }("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
    function encode_alphanum(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 2) {
        var b = 6;
        var n = ALPHANUM[str[i]];
        if (str[i + 1]) {
          b = 11;
          n = n * 45 + ALPHANUM[str[i + 1]];
        }
        pushBits(bits, b, n);
      }
      var res = {};
      var d = [0, 0, 1, 0];
      pushBits(d, 13, len);
      res.data27 = d.concat(bits);
      if (len < 2048) {
        var d = [0, 0, 1, 0];
        pushBits(d, 11, len);
        res.data10 = d.concat(bits);
      }
      if (len < 512) {
        var d = [0, 0, 1, 0];
        pushBits(d, 9, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_numeric(str) {
      var len = str.length;
      var bits = [];
      for (var i = 0; i < len; i += 3) {
        var s = str.substr(i, 3);
        var b = Math.ceil(s.length * 10 / 3);
        pushBits(bits, b, parseInt(s, 10));
      }
      var res = {};
      var d = [0, 0, 0, 1];
      pushBits(d, 14, len);
      res.data27 = d.concat(bits);
      if (len < 4096) {
        var d = [0, 0, 0, 1];
        pushBits(d, 12, len);
        res.data10 = d.concat(bits);
      }
      if (len < 1024) {
        var d = [0, 0, 0, 1];
        pushBits(d, 10, len);
        res.data1 = d.concat(bits);
      }
      return res;
    }
    function encode_url(str) {
      var slash = str.indexOf("/", 8) + 1 || str.length;
      var res = encode(str.slice(0, slash).toUpperCase(), false);
      if (slash >= str.length) {
        return res;
      }
      var path_res = encode(str.slice(slash), false);
      res.data27 = res.data27.concat(path_res.data27);
      if (res.data10 && path_res.data10) {
        res.data10 = res.data10.concat(path_res.data10);
      }
      if (res.data1 && path_res.data1) {
        res.data1 = res.data1.concat(path_res.data1);
      }
      return res;
    }
    function encode(data, parse_url) {
      var str;
      var t = typeof data;
      if (t == "string" || t == "number") {
        str = "" + data;
        data = new Buffer(str);
      } else if (Buffer.isBuffer(data)) {
        str = data.toString();
      } else if (Array.isArray(data)) {
        data = new Buffer(data);
        str = data.toString();
      } else {
        throw new Error("Bad data");
      }
      if (/^[0-9]+$/.test(str)) {
        if (data.length > 7089) {
          throw new Error("Too much data");
        }
        return encode_numeric(str);
      }
      if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
        if (data.length > 4296) {
          throw new Error("Too much data");
        }
        return encode_alphanum(str);
      }
      if (parse_url && /^https?:/i.test(str)) {
        return encode_url(str);
      }
      if (data.length > 2953) {
        throw new Error("Too much data");
      }
      return encode_8bit(data);
    }
    module2.exports = encode;
  }
});

// node_modules/qr-image/lib/errorcode.js
var require_errorcode2 = __commonJS({
  "node_modules/qr-image/lib/errorcode.js"(exports, module2) {
    "use strict";
    var GF256_BASE = 285;
    var EXP_TABLE = [1];
    var LOG_TABLE = [];
    for (i = 1; i < 256; i++) {
      n = EXP_TABLE[i - 1] << 1;
      if (n > 255)
        n = n ^ GF256_BASE;
      EXP_TABLE[i] = n;
    }
    var n;
    var i;
    for (i = 0; i < 255; i++) {
      LOG_TABLE[EXP_TABLE[i]] = i;
    }
    var i;
    function exp(k) {
      while (k < 0)
        k += 255;
      while (k > 255)
        k -= 255;
      return EXP_TABLE[k];
    }
    function log(k) {
      if (k < 1 || k > 255) {
        throw Error("Bad log(" + k + ")");
      }
      return LOG_TABLE[k];
    }
    var POLYNOMIALS = [
      [0],
      [0, 0],
      [0, 25, 1]
    ];
    function generatorPolynomial(num) {
      if (POLYNOMIALS[num]) {
        return POLYNOMIALS[num];
      }
      var prev = generatorPolynomial(num - 1);
      var res = [];
      res[0] = prev[0];
      for (var i2 = 1; i2 <= num; i2++) {
        res[i2] = log(exp(prev[i2]) ^ exp(prev[i2 - 1] + num - 1));
      }
      POLYNOMIALS[num] = res;
      return res;
    }
    module2.exports = function calculate_ec(msg, ec_len) {
      msg = [].slice.call(msg);
      var poly = generatorPolynomial(ec_len);
      for (var i2 = 0; i2 < ec_len; i2++)
        msg.push(0);
      while (msg.length > ec_len) {
        if (!msg[0]) {
          msg.shift();
          continue;
        }
        var log_k = log(msg[0]);
        for (var i2 = 0; i2 <= ec_len; i2++) {
          msg[i2] = msg[i2] ^ exp(poly[i2] + log_k);
        }
        msg.shift();
      }
      return new Buffer(msg);
    };
  }
});

// node_modules/qr-image/lib/matrix.js
var require_matrix3 = __commonJS({
  "node_modules/qr-image/lib/matrix.js"(exports, module2) {
    "use strict";
    function init(version) {
      var N = version * 4 + 17;
      var matrix = [];
      var zeros = new Buffer(N);
      zeros.fill(0);
      zeros = [].slice.call(zeros);
      for (var i = 0; i < N; i++) {
        matrix[i] = zeros.slice();
      }
      return matrix;
    }
    function fillFinders(matrix) {
      var N = matrix.length;
      for (var i = -3; i <= 3; i++) {
        for (var j = -3; j <= 3; j++) {
          var max = Math.max(i, j);
          var min = Math.min(i, j);
          var pixel = max == 2 && min >= -2 || min == -2 && max <= 2 ? 128 : 129;
          matrix[3 + i][3 + j] = pixel;
          matrix[3 + i][N - 4 + j] = pixel;
          matrix[N - 4 + i][3 + j] = pixel;
        }
      }
      for (var i = 0; i < 8; i++) {
        matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 128;
      }
    }
    function fillAlignAndTiming(matrix) {
      var N = matrix.length;
      if (N > 21) {
        var len = N - 13;
        var delta = Math.round(len / Math.ceil(len / 28));
        if (delta % 2)
          delta++;
        var res = [];
        for (var p = len + 6; p > 10; p -= delta) {
          res.unshift(p);
        }
        res.unshift(6);
        for (var i = 0; i < res.length; i++) {
          for (var j = 0; j < res.length; j++) {
            var x = res[i], y = res[j];
            if (matrix[x][y])
              continue;
            for (var r = -2; r <= 2; r++) {
              for (var c = -2; c <= 2; c++) {
                var max = Math.max(r, c);
                var min = Math.min(r, c);
                var pixel = max == 1 && min >= -1 || min == -1 && max <= 1 ? 128 : 129;
                matrix[x + r][y + c] = pixel;
              }
            }
          }
        }
      }
      for (var i = 8; i < N - 8; i++) {
        matrix[6][i] = matrix[i][6] = i % 2 ? 128 : 129;
      }
    }
    function fillStub(matrix) {
      var N = matrix.length;
      for (var i = 0; i < 8; i++) {
        if (i != 6) {
          matrix[8][i] = matrix[i][8] = 128;
        }
        matrix[8][N - 1 - i] = 128;
        matrix[N - 1 - i][8] = 128;
      }
      matrix[8][8] = 128;
      matrix[N - 8][8] = 129;
      if (N < 45)
        return;
      for (var i = N - 11; i < N - 8; i++) {
        for (var j = 0; j < 6; j++) {
          matrix[i][j] = matrix[j][i] = 128;
        }
      }
    }
    var fillReserved = function() {
      var FORMATS = Array(32);
      var VERSIONS = Array(40);
      var gf15 = 1335;
      var gf18 = 7973;
      var formats_mask = 21522;
      for (var format = 0; format < 32; format++) {
        var res = format << 10;
        for (var i = 5; i > 0; i--) {
          if (res >>> 9 + i) {
            res = res ^ gf15 << i - 1;
          }
        }
        FORMATS[format] = (res | format << 10) ^ formats_mask;
      }
      for (var version = 7; version <= 40; version++) {
        var res = version << 12;
        for (var i = 6; i > 0; i--) {
          if (res >>> 11 + i) {
            res = res ^ gf18 << i - 1;
          }
        }
        VERSIONS[version] = res | version << 12;
      }
      var EC_LEVELS = { L: 1, M: 0, Q: 3, H: 2 };
      return function fillReserved2(matrix, ec_level, mask) {
        var N = matrix.length;
        var format2 = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
        function F(k) {
          return format2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 8; i2++) {
          matrix[8][N - 1 - i2] = F(i2);
          if (i2 < 6)
            matrix[i2][8] = F(i2);
        }
        for (var i2 = 8; i2 < 15; i2++) {
          matrix[N - 15 + i2][8] = F(i2);
          if (i2 > 8)
            matrix[8][14 - i2] = F(i2);
        }
        matrix[7][8] = F(6);
        matrix[8][8] = F(7);
        matrix[8][7] = F(8);
        var version2 = VERSIONS[(N - 17) / 4];
        if (!version2)
          return;
        function V(k) {
          return version2 >> k & 1 ? 129 : 128;
        }
        ;
        for (var i2 = 0; i2 < 6; i2++) {
          for (var j = 0; j < 3; j++) {
            matrix[N - 11 + j][i2] = matrix[i2][N - 11 + j] = V(i2 * 3 + j);
          }
        }
      };
    }();
    var fillData = function() {
      var MASK_FUNCTIONS = [
        function(i, j) {
          return (i + j) % 2 == 0;
        },
        function(i, j) {
          return i % 2 == 0;
        },
        function(i, j) {
          return j % 3 == 0;
        },
        function(i, j) {
          return (i + j) % 3 == 0;
        },
        function(i, j) {
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
        },
        function(i, j) {
          return i * j % 2 + i * j % 3 == 0;
        },
        function(i, j) {
          return (i * j % 2 + i * j % 3) % 2 == 0;
        },
        function(i, j) {
          return (i * j % 3 + (i + j) % 2) % 2 == 0;
        }
      ];
      return function fillData2(matrix, data, mask) {
        var N = matrix.length;
        var row, col, dir = -1;
        row = col = N - 1;
        var mask_fn = MASK_FUNCTIONS[mask];
        var len = data.blocks[data.blocks.length - 1].length;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.blocks.length; b++) {
            if (data.blocks[b].length <= i)
              continue;
            put(data.blocks[b][i]);
          }
        }
        len = data.ec_len;
        for (var i = 0; i < len; i++) {
          for (var b = 0; b < data.ec.length; b++) {
            put(data.ec[b][i]);
          }
        }
        if (col > -1) {
          do {
            matrix[row][col] = mask_fn(row, col) ? 1 : 0;
          } while (next());
        }
        function put(byte) {
          for (var mask2 = 128; mask2; mask2 = mask2 >> 1) {
            var pixel = !!(mask2 & byte);
            if (mask_fn(row, col))
              pixel = !pixel;
            matrix[row][col] = pixel ? 1 : 0;
            next();
          }
        }
        function next() {
          do {
            if (col % 2 ^ col < 6) {
              if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
                col--;
                dir = -dir;
              } else {
                col++;
                row += dir;
              }
            } else {
              col--;
            }
            if (col == 6) {
              col--;
            }
            if (col < 0) {
              return false;
            }
          } while (matrix[row][col] & 240);
          return true;
        }
      };
    }();
    function calculatePenalty(matrix) {
      var N = matrix.length;
      var penalty = 0;
      for (var i = 0; i < N; i++) {
        var pixel = matrix[i][0] & 1;
        var len = 1;
        for (var j = 1; j < N; j++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var j = 0; j < N; j++) {
        var pixel = matrix[0][j] & 1;
        var len = 1;
        for (var i = 1; i < N; i++) {
          var p = matrix[i][j] & 1;
          if (p == pixel) {
            len++;
            continue;
          }
          if (len >= 5) {
            penalty += len - 2;
          }
          pixel = p;
          len = 1;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
      }
      for (var i = 0; i < N - 1; i++) {
        for (var j = 0; j < N - 1; j++) {
          var s = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
          if (s == 0 || s == 4) {
            penalty += 3;
          }
        }
      }
      function I(k) {
        return matrix[i][j + k] & 1;
      }
      ;
      function J(k) {
        return matrix[i + k][j] & 1;
      }
      ;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
            if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
              penalty += 40;
            }
            if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
              penalty += 40;
            }
          }
          if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
            if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
              penalty += 40;
            }
            if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
              penalty += 40;
            }
          }
        }
      }
      var numDark = 0;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j] & 1)
            numDark++;
        }
      }
      penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
      return penalty;
    }
    function getMatrix(data) {
      var matrix = init(data.version);
      fillFinders(matrix);
      fillAlignAndTiming(matrix);
      fillStub(matrix);
      var penalty = Infinity;
      var bestMask = 0;
      for (var mask = 0; mask < 8; mask++) {
        fillData(matrix, data, mask);
        fillReserved(matrix, data.ec_level, mask);
        var p = calculatePenalty(matrix);
        if (p < penalty) {
          penalty = p;
          bestMask = mask;
        }
      }
      fillData(matrix, data, bestMask);
      fillReserved(matrix, data.ec_level, bestMask);
      return matrix.map(function(row) {
        return row.map(function(cell) {
          return cell & 1;
        });
      });
    }
    module2.exports = {
      getMatrix,
      init,
      fillFinders,
      fillAlignAndTiming,
      fillStub,
      fillReserved,
      fillData,
      calculatePenalty
    };
  }
});

// node_modules/qr-image/lib/qr-base.js
var require_qr_base2 = __commonJS({
  "node_modules/qr-image/lib/qr-base.js"(exports, module2) {
    "use strict";
    var encode = require_encode2();
    var calculateEC = require_errorcode2();
    var matrix = require_matrix3();
    function _deepCopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    var EC_LEVELS = ["L", "M", "Q", "H"];
    var versions = [
      [],
      [26, 7, 1, 10, 1, 13, 1, 17, 1],
      [44, 10, 1, 16, 1, 22, 1, 28, 1],
      [70, 15, 1, 26, 1, 36, 2, 44, 2],
      [100, 20, 1, 36, 2, 52, 2, 64, 4],
      [134, 26, 1, 48, 2, 72, 4, 88, 4],
      [172, 36, 2, 64, 4, 96, 4, 112, 4],
      [196, 40, 2, 72, 4, 108, 6, 130, 5],
      [242, 48, 2, 88, 4, 132, 6, 156, 6],
      [292, 60, 2, 110, 5, 160, 8, 192, 8],
      [346, 72, 4, 130, 5, 192, 8, 224, 8],
      [404, 80, 4, 150, 5, 224, 8, 264, 11],
      [466, 96, 4, 176, 8, 260, 10, 308, 11],
      [532, 104, 4, 198, 9, 288, 12, 352, 16],
      [581, 120, 4, 216, 9, 320, 16, 384, 16],
      [655, 132, 6, 240, 10, 360, 12, 432, 18],
      [733, 144, 6, 280, 10, 408, 17, 480, 16],
      [815, 168, 6, 308, 11, 448, 16, 532, 19],
      [901, 180, 6, 338, 13, 504, 18, 588, 21],
      [991, 196, 7, 364, 14, 546, 21, 650, 25],
      [1085, 224, 8, 416, 16, 600, 20, 700, 25],
      [1156, 224, 8, 442, 17, 644, 23, 750, 25],
      [1258, 252, 9, 476, 17, 690, 23, 816, 34],
      [1364, 270, 9, 504, 18, 750, 25, 900, 30],
      [1474, 300, 10, 560, 20, 810, 27, 960, 32],
      [1588, 312, 12, 588, 21, 870, 29, 1050, 35],
      [1706, 336, 12, 644, 23, 952, 34, 1110, 37],
      [1828, 360, 12, 700, 25, 1020, 34, 1200, 40],
      [1921, 390, 13, 728, 26, 1050, 35, 1260, 42],
      [2051, 420, 14, 784, 28, 1140, 38, 1350, 45],
      [2185, 450, 15, 812, 29, 1200, 40, 1440, 48],
      [2323, 480, 16, 868, 31, 1290, 43, 1530, 51],
      [2465, 510, 17, 924, 33, 1350, 45, 1620, 54],
      [2611, 540, 18, 980, 35, 1440, 48, 1710, 57],
      [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60],
      [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63],
      [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66],
      [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70],
      [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74],
      [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77],
      [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]
    ];
    versions = versions.map(function(v, index) {
      if (!index)
        return {};
      var res = {};
      for (var i = 1; i < 8; i += 2) {
        var length = v[0] - v[i];
        var num_template = v[i + 1];
        var ec_level = EC_LEVELS[i / 2 | 0];
        var level = {
          version: index,
          ec_level,
          data_len: length,
          ec_len: v[i] / num_template,
          blocks: [],
          ec: []
        };
        for (var k = num_template, n = length; k > 0; k--) {
          var block = n / k | 0;
          level.blocks.push(block);
          n -= block;
        }
        res[ec_level] = level;
      }
      return res;
    });
    function getTemplate(message, ec_level) {
      var i = 1;
      var len;
      if (message.data1) {
        len = Math.ceil(message.data1.length / 8);
      } else {
        i = 10;
      }
      for (; i < 10; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      if (message.data10) {
        len = Math.ceil(message.data10.length / 8);
      } else {
        i = 27;
      }
      for (; i < 27; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      len = Math.ceil(message.data27.length / 8);
      for (; i < 41; i++) {
        var version = versions[i][ec_level];
        if (version.data_len >= len) {
          return _deepCopy(version);
        }
      }
      throw new Error("Too much data");
    }
    function fillTemplate(message, template) {
      var blocks = new Buffer(template.data_len);
      blocks.fill(0);
      if (template.version < 10) {
        message = message.data1;
      } else if (template.version < 27) {
        message = message.data10;
      } else {
        message = message.data27;
      }
      var len = message.length;
      for (var i = 0; i < len; i += 8) {
        var b = 0;
        for (var j = 0; j < 8; j++) {
          b = b << 1 | (message[i + j] ? 1 : 0);
        }
        blocks[i / 8] = b;
      }
      var pad = 236;
      for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
        blocks[i] = pad;
        pad = pad == 236 ? 17 : 236;
      }
      var offset = 0;
      template.blocks = template.blocks.map(function(n) {
        var b2 = blocks.slice(offset, offset + n);
        offset += n;
        template.ec.push(calculateEC(b2, template.ec_len));
        return b2;
      });
      return template;
    }
    function QR(text, ec_level, parse_url) {
      ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : "M";
      var message = encode(text, parse_url);
      var data = fillTemplate(message, getTemplate(message, ec_level));
      return matrix.getMatrix(data);
    }
    module2.exports = {
      QR,
      getTemplate,
      fillTemplate
    };
  }
});

// node_modules/qr-image/lib/crc32buffer.js
var require_crc32buffer2 = __commonJS({
  "node_modules/qr-image/lib/crc32buffer.js"(exports, module2) {
    "use strict";
    var crc_table = [];
    for (n = 0; n < 256; n++) {
      c = crc_table[n] = new Buffer(4);
      c.writeUInt32BE(n, 0);
      for (k = 0; k < 8; k++) {
        b0 = c[0] & 1;
        b1 = c[1] & 1;
        b2 = c[2] & 1;
        b3 = c[3] & 1;
        c[0] = c[0] >> 1 ^ (b3 ? 237 : 0);
        c[1] = c[1] >> 1 ^ (b3 ? 184 : 0) ^ (b0 ? 128 : 0);
        c[2] = c[2] >> 1 ^ (b3 ? 131 : 0) ^ (b1 ? 128 : 0);
        c[3] = c[3] >> 1 ^ (b3 ? 32 : 0) ^ (b2 ? 128 : 0);
      }
    }
    var c;
    var b0;
    var b1;
    var b2;
    var b3;
    var k;
    var n;
    function update(c2, buf) {
      var l = buf.length;
      for (var n2 = 0; n2 < l; n2++) {
        var e = crc_table[c2[3] ^ buf[n2]];
        c2[3] = e[3] ^ c2[2];
        c2[2] = e[2] ^ c2[1];
        c2[1] = e[1] ^ c2[0];
        c2[0] = e[0];
      }
    }
    function crc32() {
      var l = arguments.length;
      var c2 = new Buffer(4);
      c2.fill(255);
      for (var i = 0; i < l; i++) {
        update(c2, new Buffer(arguments[i]));
      }
      c2[0] = c2[0] ^ 255;
      c2[1] = c2[1] ^ 255;
      c2[2] = c2[2] ^ 255;
      c2[3] = c2[3] ^ 255;
      return c2.readUInt32BE(0);
    }
    module2.exports = crc32;
  }
});

// node_modules/qr-image/lib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/qr-image/lib/crc32.js"(exports, module2) {
    "use strict";
    (function() {
      if (process.arch === "arm") {
        module2.exports = require_crc32buffer2();
        return;
      }
      var crc_table = [];
      (function() {
        for (var n = 0; n < 256; n++) {
          var c = n;
          for (var k = 0; k < 8; k++) {
            if (c & 1) {
              c = 3988292384 ^ c >>> 1;
            } else {
              c = c >>> 1;
            }
          }
          crc_table[n] = c >>> 0;
        }
      })();
      function update(c, buf) {
        var l = buf.length;
        for (var n = 0; n < l; n++) {
          c = crc_table[(c ^ buf[n]) & 255] ^ c >>> 8;
        }
        return c;
      }
      function crc32() {
        var l = arguments.length;
        var c = -1;
        for (var i = 0; i < l; i++) {
          c = update(c, new Buffer(arguments[i]));
        }
        c = (c ^ -1) >>> 0;
        return c;
      }
      module2.exports = crc32;
    })();
  }
});

// node_modules/qr-image/lib/png.js
var require_png2 = __commonJS({
  "node_modules/qr-image/lib/png.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var crc32 = require_crc322();
    var PNG_HEAD = new Buffer([137, 80, 78, 71, 13, 10, 26, 10]);
    var PNG_IHDR = new Buffer([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0]);
    var PNG_IDAT = new Buffer([0, 0, 0, 0, 73, 68, 65, 84]);
    var PNG_IEND = new Buffer([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
    function png(bitmap2, stream) {
      stream.push(PNG_HEAD);
      var IHDR = Buffer.concat([PNG_IHDR]);
      IHDR.writeUInt32BE(bitmap2.size, 8);
      IHDR.writeUInt32BE(bitmap2.size, 12);
      IHDR.writeUInt32BE(crc32(IHDR.slice(4, -4)), 21);
      stream.push(IHDR);
      var IDAT = Buffer.concat([
        PNG_IDAT,
        zlib.deflateSync(bitmap2.data, { level: 9 }),
        new Buffer(4)
      ]);
      IDAT.writeUInt32BE(IDAT.length - 12, 0);
      IDAT.writeUInt32BE(crc32(IDAT.slice(4, -4)), IDAT.length - 4);
      stream.push(IDAT);
      stream.push(PNG_IEND);
      stream.push(null);
    }
    function bitmap(matrix, size, margin) {
      var N = matrix.length;
      var X = (N + 2 * margin) * size;
      var data = new Buffer((X + 1) * X);
      data.fill(255);
      for (var i = 0; i < X; i++) {
        data[i * (X + 1)] = 0;
      }
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (matrix[i][j]) {
            var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
            data.fill(0, offset, offset + size);
            for (var c = 1; c < size; c++) {
              data.copy(data, offset + c * (X + 1), offset, offset + size);
            }
          }
        }
      }
      return {
        data,
        size: X
      };
    }
    module2.exports = {
      bitmap,
      png
    };
  }
});

// node_modules/qr-image/lib/vector.js
var require_vector2 = __commonJS({
  "node_modules/qr-image/lib/vector.js"(exports, module2) {
    "use strict";
    function matrix2path(matrix) {
      var N = matrix.length;
      var filled = [];
      for (var row = -1; row <= N; row++) {
        filled[row] = [];
      }
      var path = [];
      for (var row = 0; row < N; row++) {
        for (var col = 0; col < N; col++) {
          if (filled[row][col])
            continue;
          filled[row][col] = 1;
          if (isDark(row, col)) {
            if (!isDark(row - 1, col)) {
              path.push(plot(row, col, "right"));
            }
          } else {
            if (isDark(row, col - 1)) {
              path.push(plot(row, col, "down"));
            }
          }
        }
      }
      return path;
      function isDark(row2, col2) {
        if (row2 < 0 || col2 < 0 || row2 >= N || col2 >= N)
          return false;
        return !!matrix[row2][col2];
      }
      function plot(row0, col0, dir) {
        filled[row0][col0] = 1;
        var res = [];
        res.push(["M", col0, row0]);
        var row2 = row0;
        var col2 = col0;
        var len = 0;
        do {
          switch (dir) {
            case "right":
              filled[row2][col2] = 1;
              if (isDark(row2, col2)) {
                filled[row2 - 1][col2] = 1;
                if (isDark(row2 - 1, col2)) {
                  res.push(["h", len]);
                  len = 0;
                  dir = "up";
                } else {
                  len++;
                  col2++;
                }
              } else {
                res.push(["h", len]);
                len = 0;
                dir = "down";
              }
              break;
            case "left":
              filled[row2 - 1][col2 - 1] = 1;
              if (isDark(row2 - 1, col2 - 1)) {
                filled[row2][col2 - 1] = 1;
                if (isDark(row2, col2 - 1)) {
                  res.push(["h", -len]);
                  len = 0;
                  dir = "down";
                } else {
                  len++;
                  col2--;
                }
              } else {
                res.push(["h", -len]);
                len = 0;
                dir = "up";
              }
              break;
            case "down":
              filled[row2][col2 - 1] = 1;
              if (isDark(row2, col2 - 1)) {
                filled[row2][col2] = 1;
                if (isDark(row2, col2)) {
                  res.push(["v", len]);
                  len = 0;
                  dir = "right";
                } else {
                  len++;
                  row2++;
                }
              } else {
                res.push(["v", len]);
                len = 0;
                dir = "left";
              }
              break;
            case "up":
              filled[row2 - 1][col2] = 1;
              if (isDark(row2 - 1, col2)) {
                filled[row2 - 1][col2 - 1] = 1;
                if (isDark(row2 - 1, col2 - 1)) {
                  res.push(["v", -len]);
                  len = 0;
                  dir = "left";
                } else {
                  len++;
                  row2--;
                }
              } else {
                res.push(["v", -len]);
                len = 0;
                dir = "right";
              }
              break;
          }
        } while (row2 != row0 || col2 != col0);
        return res;
      }
    }
    function pushSVGPath(matrix, stream, margin) {
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += "M" + (item[1] + margin) + " " + (item[2] + margin);
              break;
            default:
              res += item.join("");
          }
        }
        res += "z";
        stream.push(res);
      });
    }
    function SVG_object(matrix, margin) {
      var stream = [];
      pushSVGPath(matrix, stream, margin);
      var result = {
        size: matrix.length + 2 * margin,
        path: stream.filter(Boolean).join("")
      };
      return result;
    }
    function SVG(matrix, stream, margin, size) {
      var X = matrix.length + 2 * margin;
      stream.push('<svg xmlns="http://www.w3.org/2000/svg" ');
      if (size > 0) {
        var XY = X * size;
        stream.push('width="' + XY + '" height="' + XY + '" ');
      }
      stream.push('viewBox="0 0 ' + X + " " + X + '">');
      stream.push('<path d="');
      pushSVGPath(matrix, stream, margin);
      stream.push('"/></svg>');
      stream.push(null);
    }
    function EPS(matrix, stream, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      stream.push([
        "%!PS-Adobe-3.0 EPSF-3.0",
        "%%BoundingBox: 0 0 " + X + " " + X,
        "/h { 0 rlineto } bind def",
        "/v { 0 exch neg rlineto } bind def",
        "/M { neg " + (N + margin) + " add moveto } bind def",
        "/z { closepath } bind def",
        scale + " " + scale + " scale",
        ""
      ].join("\n"));
      matrix2path(matrix).forEach(function(subpath) {
        var res = "";
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              res += item[1] + margin + " " + item[2] + " M ";
              break;
            default:
              res += item[1] + " " + item[0] + " ";
          }
        }
        res += "z\n";
        stream.push(res);
      });
      stream.push("fill\n%%EOF\n");
      stream.push(null);
    }
    function PDF(matrix, stream, margin) {
      var N = matrix.length;
      var scale = 9;
      var X = (N + 2 * margin) * scale;
      var data = [
        "%PDF-1.0\n\n",
        "1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n",
        "2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n"
      ];
      data.push("3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> /Contents 4 0 R /MediaBox [ 0 0 " + X + " " + X + " ] >> endobj\n");
      var path = scale + " 0 0 " + scale + " 0 0 cm\n";
      path += matrix2path(matrix).map(function(subpath) {
        var res = "";
        var x, y;
        for (var k = 0; k < subpath.length; k++) {
          var item = subpath[k];
          switch (item[0]) {
            case "M":
              x = item[1] + margin;
              y = N - item[2] + margin;
              res += x + " " + y + " m ";
              break;
            case "h":
              x += item[1];
              res += x + " " + y + " l ";
              break;
            case "v":
              y -= item[1];
              res += x + " " + y + " l ";
              break;
          }
        }
        res += "h";
        return res;
      }).join("\n");
      path += "\nf\n";
      data.push("4 0 obj << /Length " + path.length + " >> stream\n" + path + "endstream\nendobj\n");
      var xref = "xref\n0 5\n0000000000 65535 f \n";
      for (var i = 1, l = data[0].length; i < 5; i++) {
        xref += ("0000000000" + l).substr(-10) + " 00000 n \n";
        l += data[i].length;
      }
      data.push(xref, "trailer << /Root 1 0 R /Size 5 >>\n", "startxref\n" + l + "\n%%EOF\n");
      stream.push(data.join(""));
      stream.push(null);
    }
    module2.exports = {
      svg: SVG,
      eps: EPS,
      pdf: PDF,
      svg_object: SVG_object
    };
  }
});

// node_modules/qr-image/lib/qr.js
var require_qr2 = __commonJS({
  "node_modules/qr-image/lib/qr.js"(exports, module2) {
    "use strict";
    var Readable2 = require("stream").Readable;
    var QR = require_qr_base2().QR;
    var png = require_png2();
    var vector = require_vector2();
    var fn_noop = function() {
    };
    var BITMAP_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      size: 5,
      margin: 4,
      customize: null
    };
    var VECTOR_OPTIONS = {
      parse_url: false,
      ec_level: "M",
      margin: 1,
      size: 0
    };
    function get_options(options, force_type) {
      if (typeof options === "string") {
        options = { "ec_level": options };
      } else {
        options = options || {};
      }
      var _options = {
        type: String(force_type || options.type || "png").toLowerCase()
      };
      var defaults = _options.type == "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
      for (var k in defaults) {
        _options[k] = k in options ? options[k] : defaults[k];
      }
      return _options;
    }
    function qr_image(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var stream = new Readable2();
      stream._read = fn_noop;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          process.nextTick(function() {
            vector[options.type](matrix, stream, options.margin, options.size);
          });
          break;
        case "svgpath":
          process.nextTick(function() {
            var obj = vector.svg_object(matrix, options.margin, options.size);
            stream.push(obj.path);
            stream.push(null);
          });
          break;
        case "png":
        default:
          process.nextTick(function() {
            var bitmap = png.bitmap(matrix, options.size, options.margin);
            if (options.customize) {
              options.customize(bitmap);
            }
            png.png(bitmap, stream);
          });
      }
      return stream;
    }
    function qr_image_sync(text, options) {
      options = get_options(options);
      var matrix = QR(text, options.ec_level, options.parse_url);
      var stream = [];
      var result;
      switch (options.type) {
        case "svg":
        case "pdf":
        case "eps":
          vector[options.type](matrix, stream, options.margin, options.size);
          result = stream.filter(Boolean).join("");
          break;
        case "png":
        default:
          var bitmap = png.bitmap(matrix, options.size, options.margin);
          if (options.customize) {
            options.customize(bitmap);
          }
          png.png(bitmap, stream);
          result = Buffer.concat(stream.filter(Boolean));
      }
      return result;
    }
    function svg_object(text, options) {
      options = get_options(options, "svg");
      var matrix = QR(text, options.ec_level);
      return vector.svg_object(matrix, options.margin);
    }
    module2.exports = {
      matrix: QR,
      image: qr_image,
      imageSync: qr_image_sync,
      svgObject: svg_object
    };
  }
});

// src/index.ts
__export(exports, {
  BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT: () => BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT,
  Counter: () => Counter_default,
  Encoder: () => Encoder_default,
  FigmaIntegration: () => FigmaIntegration_default,
  HapticLabs: () => HapticLabs_default,
  InvertableSensor: () => InvertableSensor_default,
  Joystick: () => Joystick_default,
  Metronome: () => Metronome_default,
  OLED_HEIGHT: () => OLED_HEIGHT,
  OLED_WIDTH: () => OLED_WIDTH,
  Oled: () => OLED_default,
  SignalTower: () => SignalTower_default,
  SocketIOIntegration: () => SocketIOIntegration_default,
  Timer: () => Timer_default,
  addTextToBuffer: () => addTextToBuffer,
  getBlokdotsSocketIOServer: () => BlokdotsSocketIOServer_default,
  getBlokdotsSocketIOServerAddress: () => getBlokdotsSocketIOServerAddress,
  utils: () => utils_default
});

// node_modules/socket.io/wrapper.mjs
var import_dist = __toModule(require_dist2());
var { Server, Namespace, Socket } = import_dist.default;

// src/BlokdotsSocketIOServer/BlokdotsSocketIOServer.ts
var import_ws = __toModule(require_ws3());
var import_os = __toModule(require("os"));

// src/BlokdotsSocketIOServer/setupHttpServer.js
var import_stream = __toModule(require("stream"));
var import_http = __toModule(require("http"));

// src/BlokdotsSocketIOServer/webserver/favicon.ico
var favicon_default = "data:image/x-icon;base64,AAABAAIAICAAAAEAIAAoEQAAJgAAABAQAAABACAAaAQAAE4RAAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAABSAAAAeQAAAIgAAAB+AAAAWwAAACcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAACgAAAA7QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA9gAAALMAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABxAAAA8QAAAP8AAADtAAAArQAAAHwAAABpAAAAdgAAAKIAAADhAAAA/wAAAP0AAACQAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAhwAAAP8AAAD5AAAAiQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUAAABxAAAA6wAAAP8AAACrAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGcAAAD/AAAA7QAAAE0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAA2AAAAP8AAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiAAAA6gAAAPoAAABSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAA6gAAAPsAAABDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIkAAAD/AAAAnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAA/wAAALQAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAA2wAAAPgAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAADiAAAA9gAAACcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0AAAD9AAAAxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEAAAD/AAAAWwAAAAAAAAAAAAAAMQAAAF0AAABcAAAAXAAAAFwAAABcAAAAXAAAAFwAAABZAAAAjgAAAP8AAADHAAAAWQAAAFwAAABcAAAAXAAAAFwAAABcAAAAXAAAAF0AAAAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdgAAAP8AAAB+AAAAAAAAAAAAAACNAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAF8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABpAAAA/wAAAIgAAAAAAAAAAAAAAIkAAAD/AAAAwAAAAJMAAACVAAAAlQAAAJUAAACVAAAAlAAAALIAAAD/AAAA3wAAAJMAAACVAAAAlQAAAJUAAACVAAAAkwAAANMAAAD/AAAAXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsAAAD/AAAAegAAAAAAAAAAAAAAiQAAAP8AAABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgAAAPoAAADRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkQAAAP8AAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArAAAAP8AAABSAAAAAAAAAAAAAACJAAAA/wAAAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAzwAAAPwAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAACVAAAA/wAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0AAADsAAAA7wAAAB0AAAAAAAAAAAAAAIkAAAD/AAAAZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2AAAA/wAAALMAAAACAAAAAAAAAAAAAAAAAAAAAAAAAJUAAAD/AAAAXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAigAAAP8AAACiAAAAAAAAAAAAAAAAAAAAiQAAAP8AAABnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUAAADaAAAA/wAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAlQAAAP8AAABcAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAD2AAAA8gAAAC8AAAAAAAAAAAAAAAAAAACJAAAA/wAAAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEoAAAD4AAAA+wAAAHIAAAACAAAAAAAAAAAAAACVAAAA/wAAAFwAAAAAAAAAAAAAAAAAAABTAAAA7QAAAP8AAABwAAAAAAAAAAAAAAAAAAAAAAAAAIkAAAD/AAAAZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGMAAAD4AAAA/wAAALEAAABBAAAABwAAAJMAAAD/AAAAWAAAAAMAAAAyAAAAmwAAAP0AAAD/AAAAhwAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAiQAAAP8AAABnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEsAAADYAAAA/wAAAP8AAADRAAAA3wAAAP8AAADHAAAAxwAAAPsAAAD/AAAA6QAAAGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJAAAA/wAAAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUAAAB1AAAAzQAAAPsAAAD/AAAA/wAAAP8AAAD/AAAA2QAAAIkAAAAjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIkAAAD/AAAAZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAKwAAALIAAAD/AAAAjgAAADIAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiQAAAP8AAABnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkgAAAP8AAABXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJAAAA/wAAAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACVAAAA/wAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIkAAAD/AAAAZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJUAAAD/AAAAXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiQAAAP8AAABnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlQAAAP8AAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJAAAA/wAAAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACVAAAA/wAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIkAAAD/AAAAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJEAAAD/AAAAXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiQAAAP8AAACkAAAAZgAAAGcAAABnAAAAZwAAAGcAAABnAAAAZwAAAGcAAABnAAAAZwAAAGcAAABnAAAAZwAAAGcAAABmAAAAwAAAAP8AAABcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEkAAACKAAAAiQAAAIkAAACJAAAAiQAAAIkAAACJAAAAiQAAAIkAAACJAAAAiQAAAIkAAACJAAAAiQAAAIkAAACJAAAAiQAAAIkAAACKAAAAMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAABwAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+AAAAsQAAAMsAAADKAAAAxgAAAHkAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXAAAA2QAAAGEAAAAYAAAADwAAADUAAACvAAAArwAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdAAAA1gAAADcAAAAAAAAAAAAAAAAAAAAAAAAAAgAAALEAAAB5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwAAAJcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAyQAAAAgAAAAQAAAAjAAAAJ0AAACdAAAAnAAAANgAAADGAAAAnAAAAJ0AAACbAAAAVwAAAAAAAAAAAAAADQAAAMsAAAAdAAAAHwAAAN8AAABsAAAAZQAAAGQAAAC4AAAAswAAAGMAAABkAAAApwAAAKAAAAAAAAAAAAAAABUAAADNAAAAFQAAAB8AAADIAAAAAgAAAAAAAAAAAAAASgAAAL0AAAAAAAAAAAAAAGAAAACdAAAAAAAAAAAAAABhAAAAtAAAAAEAAAAfAAAAyQAAAAsAAAAAAAAAAAAAAAUAAAC0AAAAjQAAAAIAAABeAAAAmQAAAAAAAAA4AAAA2gAAAD0AAAAAAAAAHwAAAMkAAAALAAAAAAAAAAAAAAAAAAAAFwAAALQAAAC6AAAAsgAAAMYAAACYAAAA1AAAAFcAAAAAAAAAAAAAAB8AAADJAAAACwAAAAAAAAAAAAAAAAAAAAAAAAADAAAATgAAALcAAADXAAAAcQAAAB0AAAAAAAAAAAAAAAAAAAAfAAAAyQAAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfAAAAmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwAAAMkAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8AAADMAAAAFgAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAG0AAACeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAA2QAAAMsAAADJAAAAyQAAAMkAAADJAAAAyQAAAMgAAADYAAAAjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAABoAAAAfAAAAHwAAAB8AAAAfAAAAHwAAAB8AAAAfAAAAHgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";

// src/BlokdotsSocketIOServer/webserver/index.html
var webserver_default = "data:text/html;charset=utf-8;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sPgogIDxoZWFkPgogICAgPG1ldGEgY2hhcnNldD0idXRmLTgiIC8+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCIgLz4KICAgIDx0aXRsZT5ibG9rZG90czwvdGl0bGU+CiAgICA8bGluayByZWw9Imljb24iIGhyZWY9Ii9mYXZpY29uLmljbyIgLz4KCiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIHR5cGU9InRleHQvY3NzIiBocmVmPSJzdHlsZS5jc3MiIC8+CgogICAgPHNjcmlwdCBzcmM9InNvY2tldC1pby5taW4uanMiPjwvc2NyaXB0PgogIDwvaGVhZD4KCiAgPGJvZHk+CiAgICA8ZGl2IGlkPSJ3cmFwcGVyIj4KICAgICAgPGgxPmJsb2tkb3RzPC9oMT4KCiAgICAgIDxwPgogICAgICAgIFRoaXMgcGFnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGludGVybmFsIGJsb2tkb3RzIHNlcnZlci4gWW91IGNhbiBjb25uZWN0CiAgICAgICAgdG8gdGhlIGludGVncmF0aW9ucyBieSBjb25uZWN0aW5nIHdpdGggYSBTb2NrZXQuSU8gY2xpZW50IHRvIHRoaXMKICAgICAgICBhZGRyZXNzLgogICAgICA8L3A+CiAgICAgIDxwPgogICAgICAgIEZvciBtb3JlIGluZm9ybWF0aW9uLCBjaGVjayBvdXQgdGhlCiAgICAgICAgPGEgaHJlZj0iaHR0cHM6Ly9ibG9rZG90cy5jb20vZG9jdW1lbnRhdGlvbi9jb21wb25lbnRzL2ludGVncmF0aW9ucy9zb2NrZXQtaW8tc2VydmVyIgogICAgICAgICAgPmJsb2tkb3RzIGRvY3VtZW50YXRpb248L2EKICAgICAgICA+LgogICAgICA8L3A+CgogICAgICA8YnIgLz4KCiAgICAgIDxoMT5Db25uZWN0aW9uIFN0YXR1czwvaDE+CgogICAgICA8cD4KICAgICAgICBTZXJ2ZXIKICAgICAgICA8c3BhbiBpZD0ic2VydmVyQWRkcmVzcyI+PC9zcGFuPgogICAgICAgIDxzcGFuIGlkPSJjb25uZWN0aW9uU3RhdHVzIj5ub3QgY29ubmVjdGVkPC9zcGFuPgogICAgICA8L3A+CgogICAgICA8aDE+QWN0aXZlIEludGVncmF0aW9uczwvaDE+CiAgICAgIDxkaXYgaWQ9ImFjdGl2ZUludGVncmF0aW9ucyI+PC9kaXY+CgogICAgICA8c2VjdGlvbiBpZD0idGVzdE1lc3NhZ2VzIj4KICAgICAgICA8aDE+VGVzdCBNZXNzYWdlczwvaDE+CgogICAgICAgIDxwPgogICAgICAgICAgWW91IGNhbiBzZW5kIGFuZCByZWNlaXZlIHRlc3QgbWVzc2FnZXMgYmVsb3cuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBhCiAgICAgICAgICBoYXJkd2FyZSBib2FyZCAobGlrZSBBcmR1aW5vKSBpcyBjb25uZWN0ZWQgYW5kIG1hcmtlZCBhcyAiUmVhZHkiIGluCiAgICAgICAgICBibG9rZG90cy4KICAgICAgICA8L3A+CgogICAgICAgIDxkaXYgaWQ9InRlc3RJbnB1dCI+CiAgICAgICAgICA8bGFiZWwKICAgICAgICAgICAgPjxzcGFuPk1lc3NhZ2U6PC9zcGFuPgogICAgICAgICAgICA8aW5wdXQKICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IgogICAgICAgICAgICAgIGlkPSJ0ZXN0TWVzc2FnZSIKICAgICAgICAgICAgICBuYW1lPSJ0ZXN0TWVzc2FnZSIKICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0ibWVzc2FnZSIKICAgICAgICAgICAgLz4KICAgICAgICAgIDwvbGFiZWw+CiAgICAgICAgICA8bGFiZWwKICAgICAgICAgICAgPjxzcGFuPlZhbHVlOjwvc3Bhbj4KICAgICAgICAgICAgPGlucHV0CiAgICAgICAgICAgICAgdHlwZT0idGV4dCIKICAgICAgICAgICAgICBpZD0idGVzdFZhbHVlIgogICAgICAgICAgICAgIG5hbWU9InRlc3RWYWx1ZSIKICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0idmFsdWUiCiAgICAgICAgICAgIC8+CiAgICAgICAgICA8L2xhYmVsPgogICAgICAgICAgPGJ1dHRvbj5TZW5kPC9idXR0b24+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDx1bCBpZD0ic29ja2V0LWhpc3RvcnkiPgogICAgICAgICAgPCEtLSBtZXNzYWdlcyBnbyBoZXJlIC0tPgogICAgICAgIDwvdWw+CiAgICAgIDwvc2VjdGlvbj4KICAgIDwvZGl2PgoKICAgIDxzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij4KICAgICAgY29uc3QgZ2VuZXJhbFNvY2tldCA9IGlvKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pOwoKICAgICAgZ2VuZXJhbFNvY2tldC5vbigiaW5mbyIsIChkYXRhKSA9PiB7CiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7CiAgICAgIH0pOwoKICAgICAgY29uc3Qgc29ja2V0ID0gaW8od2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7CiAgICAgIGNvbnN0IGludGVncmF0aW9uID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZygxKTsKCiAgICAgIGxldCBzb2NrZXRDb250YWluZXIgPSBudWxsOwoKICAgICAgc29ja2V0Lm9uKCJjb25uZWN0IiwgKCkgPT4gewogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIiNjb25uZWN0aW9uU3RhdHVzIikudGV4dENvbnRlbnQgPQogICAgICAgICAgImlzIGNvbm5lY3RlZCI7CiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiI2Nvbm5lY3Rpb25TdGF0dXMiKS5jbGFzc0xpc3QuYWRkKCJvayIpOwogICAgICB9KTsKCiAgICAgIHNvY2tldC5vbigiZGlzY29ubmVjdCIsICgpID0+IHsKICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjY29ubmVjdGlvblN0YXR1cyIpLnRleHRDb250ZW50ID0KICAgICAgICAgICJub3QgY29ubmVjdGVkIjsKICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjY29ubmVjdGlvblN0YXR1cyIpLmNsYXNzTGlzdC5yZW1vdmUoIm9rIik7CiAgICAgIH0pOwoKICAgICAgc29ja2V0Lm9uKCJpbmZvIiwgKHZhbCkgPT4gewogICAgICAgIGlmICh2YWwuYWN0aXZlSW50ZWdyYXRpb25zKSB7CiAgICAgICAgICBjb25zdCBpbnRlZ3JhdGlvbnNIdG1sID0gdmFsLmFjdGl2ZUludGVncmF0aW9ucwogICAgICAgICAgICAubWFwKChpbnRlZ3JhdGlvbk5hbWUpID0+IHsKICAgICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPSJjb2RlICR7CiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbk5hbWUgPT09IGludGVncmF0aW9uID8gIm9rIiA6ICIiCiAgICAgICAgICAgICAgfSI+JHtpbnRlZ3JhdGlvbk5hbWV9PC9zcGFuPmA7CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC5qb2luKCIgIik7CiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjYWN0aXZlSW50ZWdyYXRpb25zIikuaW5uZXJIVE1MID0KICAgICAgICAgICAgaW50ZWdyYXRpb25zSHRtbDsKICAgICAgICB9CiAgICAgIH0pOwoKICAgICAgaWYgKGludGVncmF0aW9uID09PSAiIikgewogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIiN0ZXN0TWVzc2FnZXMiKS5pbm5lckhUTUwgPQogICAgICAgICAgIlBsZWFzZSBvcGVuIHRoaXMgcGFnZSB3aXRoIHRoZSBzcGVjaWZpYyBVUkwgZm9yIGFuIGFjdGl2ZSBpbnRlZ3JhdGlvbi4iOwogICAgICB9CgogICAgICBpZiAoaW50ZWdyYXRpb24gPT09ICJibG9rZG90cyIpIHsKICAgICAgICBzb2NrZXQub24oImJsb2tkb3RzIiwgKHZhbCkgPT4gewogICAgICAgICAgYWRkTWVzc2FnZVRvTGlzdCh2YWwpOwogICAgICAgIH0pOwogICAgICB9CgogICAgICBpZiAoaW50ZWdyYXRpb24gPT09ICJwcm90b3BpZSIpIHsKICAgICAgICBzb2NrZXQub24oInBwTWVzc2FnZSIsICh2YWwpID0+IHsKICAgICAgICAgIGNvbnN0IHBwVmFsID0gewogICAgICAgICAgICBtc2c6IHZhbC5tZXNzYWdlSWQsCiAgICAgICAgICAgIHZhbDogdmFsLnZhbHVlLAogICAgICAgICAgfTsKICAgICAgICAgIGFkZE1lc3NhZ2VUb0xpc3QocHBWYWwpOwogICAgICAgIH0pOwogICAgICB9CgogICAgICBjb25zdCBhZGRNZXNzYWdlVG9MaXN0ID0gKHZhbCwgZGlyID0gImluIikgPT4gewogICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGkiKTsKCiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoRGF0ZS5ub3coKSkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7CiAgICAgICAgY29uc3Qgc2lnbmFsRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTsKICAgICAgICBzaWduYWxEYXRlLmNsYXNzTGlzdC5hZGQoIm1lc3NhZ2VUaW1lIik7CiAgICAgICAgc2lnbmFsRGF0ZS50ZXh0Q29udGVudCA9IHRpbWVzdGFtcDsKICAgICAgICBsaS5hcHBlbmRDaGlsZChzaWduYWxEYXRlKTsKCiAgICAgICAgY29uc3QgYXJyb3dJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpOwogICAgICAgIGFycm93SW1hZ2UuY2xhc3NMaXN0LmFkZCgibWVzc2FnZUFycm93Iik7CiAgICAgICAgYXJyb3dJbWFnZS5zcmMgPSAibG9nLWFycm93LSIgKyBkaXIgKyAiLnN2ZyI7CiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYXJyb3dJbWFnZSk7CgogICAgICAgIGNvbnN0IG1lc3NhZ2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7CiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKCJtZXNzYWdlQ29udGVudERpc3BsYXkiKTsKICAgICAgICBtZXNzYWdlRE9NLnRleHRDb250ZW50ID0gdmFsLm1zZzsKICAgICAgICBsaS5hcHBlbmRDaGlsZChtZXNzYWdlRE9NKTsKCiAgICAgICAgaWYgKHZhbC52YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwudmFsICE9PSBudWxsICYmIHZhbC52YWwgIT09ICIiKSB7CiAgICAgICAgICBjb25zdCB2YWx1ZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTsKICAgICAgICAgIHZhbHVlRE9NLmNsYXNzTGlzdC5hZGQoIm1lc3NhZ2VWYWx1ZURpc3BsYXkiKTsKICAgICAgICAgIGlmICghaXNOYU4odmFsLnZhbCkpIHsKICAgICAgICAgICAgdmFsdWVET00uY2xhc3NMaXN0LmFkZCgibWVzc2FnZVZhbHVlRGlzcGxheS1pcy1udW1iZXIiKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhbHVlRE9NLnRleHRDb250ZW50ID0gdmFsLnZhbDsKICAgICAgICAgIGxpLmFwcGVuZENoaWxkKHZhbHVlRE9NKTsKICAgICAgICB9CgogICAgICAgIHNvY2tldENvbnRhaW5lci5wcmVwZW5kKGxpKTsKICAgICAgfTsKCiAgICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKCkgPT4gewogICAgICAgIGNvbnN0IG1zZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIiN0ZXN0TWVzc2FnZSIpLnZhbHVlOwogICAgICAgIGxldCB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjdGVzdFZhbHVlIikudmFsdWU7CgogICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7CiAgICAgICAgICBtc2csCiAgICAgICAgICB2YWwsCiAgICAgICAgfTsKICAgICAgICBhZGRNZXNzYWdlVG9MaXN0KG1lc3NhZ2UsICJvdXQiKTsKCiAgICAgICAgaWYgKGludGVncmF0aW9uID09PSAiYmxva2RvdHMiKSB7CiAgICAgICAgICBzb2NrZXQuZW1pdCgiYmxva2RvdHMiLCBtZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGludGVncmF0aW9uID09PSAicHJvdG9waWUiKSB7CiAgICAgICAgICBzb2NrZXQuZW1pdCgicHBNZXNzYWdlIiwgeyBtZXNzYWdlSWQ6IG1zZywgdmFsdWU6IHZhbCB9KTsKICAgICAgICB9CiAgICAgIH07CgogICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIiwgKCkgPT4gewogICAgICAgIHNvY2tldENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIiNzb2NrZXQtaGlzdG9yeSIpOwogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIiNzZXJ2ZXJBZGRyZXNzIikudGV4dENvbnRlbnQgPQogICAgICAgICAgd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTsKCiAgICAgICAgaWYgKGludGVncmF0aW9uICE9PSAiIikgewogICAgICAgICAgZG9jdW1lbnQKICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoIiN0ZXN0SW5wdXQgYnV0dG9uIikKICAgICAgICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgc2VuZE1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgfSk7CiAgICA8L3NjcmlwdD4KICA8L2JvZHk+CjwvaHRtbD4K";

// src/BlokdotsSocketIOServer/webserver/log-arrow-in.svg
var log_arrow_in_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgNS43NDIwNUw0LjcyODIyIDEwLjQ4NDFMNS42ODc1NSA5LjUyNDc3TDIuNTQ3NjEgNi4zOTcwNUwxMS4xNjg0IDYuMzk3MDVWNS4wODcwNUwyLjU0NzYxIDUuMDg3MDVMNS42ODc1NSAxLjk1OTMzTDQuNzI4MjMgMUwwIDUuNzQyMDVaIiBmaWxsPSIjQThBOEE4Ii8+Cjwvc3ZnPgo=";

// src/BlokdotsSocketIOServer/webserver/log-arrow-out.svg
var log_arrow_out_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTkuODExOTcgMi4wNjYyNkwzLjExNTQ3IDIuMDU2NDlMMy4xMTU0NyAzLjQxMzE4TDcuNTQ3MzggMy40MDQ1NEwxLjQ1MTU0IDkuNTAwMzhMMi4zNzc4NSAxMC40MjY3TDguNDczNjkgNC4zMzA4NUw4LjQ2NTA1IDguNzYyNzZIOS44MjE3NEw5LjgxMTk3IDIuMDY2MjZaIiBmaWxsPSIjMUFCQzlDIi8+Cjwvc3ZnPgo=";

// src/BlokdotsSocketIOServer/webserver/socket-io.min.js
var socket_io_min_default = "data:text/javascript;charset=utf-8;base64,LyohCiAqIFNvY2tldC5JTyB2NC4yLjAKICogKGMpIDIwMTQtMjAyMSBHdWlsbGVybW8gUmF1Y2gKICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogKi8KIShmdW5jdGlvbiAodCwgZSkgewogICJvYmplY3QiID09IHR5cGVvZiBleHBvcnRzICYmICJvYmplY3QiID09IHR5cGVvZiBtb2R1bGUKICAgID8gKG1vZHVsZS5leHBvcnRzID0gZSgpKQogICAgOiAiZnVuY3Rpb24iID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZAogICAgPyBkZWZpbmUoW10sIGUpCiAgICA6ICJvYmplY3QiID09IHR5cGVvZiBleHBvcnRzCiAgICA/IChleHBvcnRzLmlvID0gZSgpKQogICAgOiAodC5pbyA9IGUoKSk7Cn0pKHNlbGYsIGZ1bmN0aW9uICgpIHsKICByZXR1cm4gKGZ1bmN0aW9uICh0KSB7CiAgICB2YXIgZSA9IHt9OwogICAgZnVuY3Rpb24gbihyKSB7CiAgICAgIGlmIChlW3JdKSByZXR1cm4gZVtyXS5leHBvcnRzOwogICAgICB2YXIgbyA9IChlW3JdID0geyBpOiByLCBsOiAhMSwgZXhwb3J0czoge30gfSk7CiAgICAgIHJldHVybiB0W3JdLmNhbGwoby5leHBvcnRzLCBvLCBvLmV4cG9ydHMsIG4pLCAoby5sID0gITApLCBvLmV4cG9ydHM7CiAgICB9CiAgICByZXR1cm4gKAogICAgICAobi5tID0gdCksCiAgICAgIChuLmMgPSBlKSwKICAgICAgKG4uZCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgbi5vKHQsIGUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IHIgfSk7CiAgICAgIH0pLAogICAgICAobi5yID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAidW5kZWZpbmVkIiAhPSB0eXBlb2YgU3ltYm9sICYmCiAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiYKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICJNb2R1bGUiIH0pLAogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogITAgfSk7CiAgICAgIH0pLAogICAgICAobi50ID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICBpZiAoKDEgJiBlICYmICh0ID0gbih0KSksIDggJiBlKSkgcmV0dXJuIHQ7CiAgICAgICAgaWYgKDQgJiBlICYmICJvYmplY3QiID09IHR5cGVvZiB0ICYmIHQgJiYgdC5fX2VzTW9kdWxlKSByZXR1cm4gdDsKICAgICAgICB2YXIgciA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgICAgaWYgKAogICAgICAgICAgKG4ucihyKSwKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCAiZGVmYXVsdCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiB0IH0pLAogICAgICAgICAgMiAmIGUgJiYgInN0cmluZyIgIT0gdHlwZW9mIHQpCiAgICAgICAgKQogICAgICAgICAgZm9yICh2YXIgbyBpbiB0KQogICAgICAgICAgICBuLmQoCiAgICAgICAgICAgICAgciwKICAgICAgICAgICAgICBvLAogICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdFtlXTsKICAgICAgICAgICAgICB9LmJpbmQobnVsbCwgbykKICAgICAgICAgICAgKTsKICAgICAgICByZXR1cm4gcjsKICAgICAgfSksCiAgICAgIChuLm4gPSBmdW5jdGlvbiAodCkgewogICAgICAgIHZhciBlID0KICAgICAgICAgIHQgJiYgdC5fX2VzTW9kdWxlCiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHQuZGVmYXVsdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgICAgICAgfTsKICAgICAgICByZXR1cm4gbi5kKGUsICJhIiwgZSksIGU7CiAgICAgIH0pLAogICAgICAobi5vID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGUpOwogICAgICB9KSwKICAgICAgKG4ucCA9ICIiKSwKICAgICAgbigobi5zID0gMTgpKQogICAgKTsKICB9KShbCiAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICB0LmV4cG9ydHMgPQogICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBzZWxmCiAgICAgICAgICA/IHNlbGYKICAgICAgICAgIDogInVuZGVmaW5lZCIgIT0gdHlwZW9mIHdpbmRvdwogICAgICAgICAgPyB3aW5kb3cKICAgICAgICAgIDogRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICB2YXIgciA9IG4oMjQpLAogICAgICAgIG8gPSBuKDI1KSwKICAgICAgICBpID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7CiAgICAgIHQuZXhwb3J0cyA9IHsKICAgICAgICBwcm90b2NvbDogNCwKICAgICAgICBlbmNvZGVQYWNrZXQ6IHIsCiAgICAgICAgZW5jb2RlUGF5bG9hZDogZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgIHZhciBuID0gdC5sZW5ndGgsCiAgICAgICAgICAgIG8gPSBuZXcgQXJyYXkobiksCiAgICAgICAgICAgIHMgPSAwOwogICAgICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0LCBjKSB7CiAgICAgICAgICAgIHIodCwgITEsIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgKG9bY10gPSB0KSwgKytzID09PSBuICYmIGUoby5qb2luKGkpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIGRlY29kZVBhY2tldDogbywKICAgICAgICBkZWNvZGVQYXlsb2FkOiBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgZm9yICh2YXIgbiA9IHQuc3BsaXQoaSksIHIgPSBbXSwgcyA9IDA7IHMgPCBuLmxlbmd0aDsgcysrKSB7CiAgICAgICAgICAgIHZhciBjID0gbyhuW3NdLCBlKTsKICAgICAgICAgICAgaWYgKChyLnB1c2goYyksICJlcnJvciIgPT09IGMudHlwZSkpIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHI7CiAgICAgICAgfSwKICAgICAgfTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICBmdW5jdGlvbiByKHQpIHsKICAgICAgICBpZiAodCkKICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgZm9yICh2YXIgZSBpbiByLnByb3RvdHlwZSkgdFtlXSA9IHIucHJvdG90eXBlW2VdOwogICAgICAgICAgICByZXR1cm4gdDsKICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgICh0LmV4cG9ydHMgPSByKSwKICAgICAgICAoci5wcm90b3R5cGUub24gPSByLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0KICAgICAgICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgKHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fSksCiAgICAgICAgICAgICAgKHRoaXMuX2NhbGxiYWNrc1siJCIgKyB0XSA9IHRoaXMuX2NhbGxiYWNrc1siJCIgKyB0XSB8fCBbXSkucHVzaCgKICAgICAgICAgICAgICAgIGUKICAgICAgICAgICAgICApLAogICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgKTsKICAgICAgICAgIH0pLAogICAgICAgIChyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgIGZ1bmN0aW9uIG4oKSB7CiAgICAgICAgICAgIHRoaXMub2ZmKHQsIG4pLCBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKG4uZm4gPSBlKSwgdGhpcy5vbih0LCBuKSwgdGhpczsKICAgICAgICB9KSwKICAgICAgICAoci5wcm90b3R5cGUub2ZmID0KICAgICAgICAgIHIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0KICAgICAgICAgIHIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9CiAgICAgICAgICByLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0KICAgICAgICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAoKHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fSksCiAgICAgICAgICAgICAgICAwID09IGFyZ3VtZW50cy5sZW5ndGgpCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9jYWxsYmFja3MgPSB7fSksIHRoaXM7CiAgICAgICAgICAgICAgdmFyIG4sCiAgICAgICAgICAgICAgICByID0gdGhpcy5fY2FsbGJhY2tzWyIkIiArIHRdOwogICAgICAgICAgICAgIGlmICghcikgcmV0dXJuIHRoaXM7CiAgICAgICAgICAgICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyIkIiArIHRdLCB0aGlzOwogICAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykKICAgICAgICAgICAgICAgIGlmICgobiA9IHJbb10pID09PSBlIHx8IG4uZm4gPT09IGUpIHsKICAgICAgICAgICAgICAgICAgci5zcGxpY2UobywgMSk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiAwID09PSByLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyIkIiArIHRdLCB0aGlzOwogICAgICAgICAgICB9KSwKICAgICAgICAoci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307CiAgICAgICAgICBmb3IgKAogICAgICAgICAgICB2YXIgZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksCiAgICAgICAgICAgICAgbiA9IHRoaXMuX2NhbGxiYWNrc1siJCIgKyB0XSwKICAgICAgICAgICAgICByID0gMTsKICAgICAgICAgICAgciA8IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgICAgIHIrKwogICAgICAgICAgKQogICAgICAgICAgICBlW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTsKICAgICAgICAgIGlmIChuKSB7CiAgICAgICAgICAgIHIgPSAwOwogICAgICAgICAgICBmb3IgKHZhciBvID0gKG4gPSBuLnNsaWNlKDApKS5sZW5ndGg7IHIgPCBvOyArK3IpCiAgICAgICAgICAgICAgbltyXS5hcHBseSh0aGlzLCBlKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0pLAogICAgICAgIChyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgKHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fSksCiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1siJCIgKyB0XSB8fCBbXQogICAgICAgICAgKTsKICAgICAgICB9KSwKICAgICAgICAoci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIHJldHVybiAhIXRoaXMubGlzdGVuZXJzKHQpLmxlbmd0aDsKICAgICAgICB9KTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICB2YXIgciA9IG4oMCk7CiAgICAgIHQuZXhwb3J0cy5waWNrID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICBmb3IgKAogICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KGUgPiAxID8gZSAtIDEgOiAwKSwgciA9IDE7CiAgICAgICAgICByIDwgZTsKICAgICAgICAgIHIrKwogICAgICAgICkKICAgICAgICAgIG5bciAtIDFdID0gYXJndW1lbnRzW3JdOwogICAgICAgIHJldHVybiBuLnJlZHVjZShmdW5jdGlvbiAoZSwgbikgewogICAgICAgICAgcmV0dXJuIHQuaGFzT3duUHJvcGVydHkobikgJiYgKGVbbl0gPSB0W25dKSwgZTsKICAgICAgICB9LCB7fSk7CiAgICAgIH07CiAgICAgIHZhciBvID0gc2V0VGltZW91dCwKICAgICAgICBpID0gY2xlYXJUaW1lb3V0OwogICAgICB0LmV4cG9ydHMuaW5zdGFsbFRpbWVyRnVuY3Rpb25zID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICBlLnVzZU5hdGl2ZVRpbWVycwogICAgICAgICAgPyAoKHQuc2V0VGltZW91dEZuID0gby5iaW5kKHIpKSwgKHQuY2xlYXJUaW1lb3V0Rm4gPSBpLmJpbmQocikpKQogICAgICAgICAgOiAoKHQuc2V0VGltZW91dEZuID0gc2V0VGltZW91dC5iaW5kKHIpKSwKICAgICAgICAgICAgKHQuY2xlYXJUaW1lb3V0Rm4gPSBjbGVhclRpbWVvdXQuYmluZChyKSkpOwogICAgICB9OwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIodCkgewogICAgICAgIHJldHVybiAociA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG8odCwgZSkgewogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgewogICAgICAgICAgdmFyIHIgPSBlW25dOwogICAgICAgICAgKHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSksCiAgICAgICAgICAgIChyLmNvbmZpZ3VyYWJsZSA9ICEwKSwKICAgICAgICAgICAgInZhbHVlIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLAogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgci5rZXksIHIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBpKHQsIGUpIHsKICAgICAgICByZXR1cm4gKGkgPQogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CiAgICAgICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICByZXR1cm4gKHQuX19wcm90b19fID0gZSksIHQ7CiAgICAgICAgICB9KSh0LCBlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzKHQpIHsKICAgICAgICB2YXIgZSA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoInVuZGVmaW5lZCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExOwogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCgKICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkKICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICEwCiAgICAgICAgICAgICk7CiAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgIHJldHVybiAhMTsKICAgICAgICAgIH0KICAgICAgICB9KSgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgciA9IHUodCk7CiAgICAgICAgICBpZiAoZSkgewogICAgICAgICAgICB2YXIgbyA9IHUodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChyLCBhcmd1bWVudHMsIG8pOwogICAgICAgICAgfSBlbHNlIG4gPSByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICByZXR1cm4gYyh0aGlzLCBuKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGModCwgZSkgewogICAgICAgIGlmIChlICYmICgib2JqZWN0IiA9PT0gcihlKSB8fCAiZnVuY3Rpb24iID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7CiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIGEodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYSh0KSB7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigKICAgICAgICAgICAgInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdSh0KSB7CiAgICAgICAgcmV0dXJuICh1ID0gT2JqZWN0LnNldFByb3RvdHlwZU9mCiAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZgogICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7CiAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIHZhciBmID0gbigxKSwKICAgICAgICBsID0gbigyKSwKICAgICAgICBwID0gbigzKS5pbnN0YWxsVGltZXJGdW5jdGlvbnMsCiAgICAgICAgaCA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgIShmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgKHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgZSAmJiBpKHQsIGUpOwogICAgICAgICAgfSkodSwgdCk7CiAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgbiwKICAgICAgICAgICAgciwKICAgICAgICAgICAgYyA9IHModSk7CiAgICAgICAgICBmdW5jdGlvbiB1KHQpIHsKICAgICAgICAgICAgdmFyIGU7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpCiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICAgICAgICAgIH0pKHRoaXMsIHUpLAogICAgICAgICAgICAgIChlID0gYy5jYWxsKHRoaXMpKSwKICAgICAgICAgICAgICBwKGEoZSksIHQpLAogICAgICAgICAgICAgIChlLm9wdHMgPSB0KSwKICAgICAgICAgICAgICAoZS5xdWVyeSA9IHQucXVlcnkpLAogICAgICAgICAgICAgIChlLnJlYWR5U3RhdGUgPSAiIiksCiAgICAgICAgICAgICAgKGUuc29ja2V0ID0gdC5zb2NrZXQpLAogICAgICAgICAgICAgIGUKICAgICAgICAgICAgKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgIChlID0gdSksCiAgICAgICAgICAgIChuID0gWwogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uRXJyb3IiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IEVycm9yKHQpOwogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgIChuLnR5cGUgPSAiVHJhbnNwb3J0RXJyb3IiKSwKICAgICAgICAgICAgICAgICAgICAobi5kZXNjcmlwdGlvbiA9IGUpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgiZXJyb3IiLCBuKSwKICAgICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib3BlbiIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgICgiY2xvc2VkIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmICIiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHx8CiAgICAgICAgICAgICAgICAgICAgICAoKHRoaXMucmVhZHlTdGF0ZSA9ICJvcGVuaW5nIiksIHRoaXMuZG9PcGVuKCkpLAogICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJjbG9zZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgICgib3BlbmluZyIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJgogICAgICAgICAgICAgICAgICAgICAgIm9wZW4iICE9PSB0aGlzLnJlYWR5U3RhdGUpIHx8CiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5kb0Nsb3NlKCksIHRoaXMub25DbG9zZSgpKSwKICAgICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAic2VuZCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgIm9wZW4iID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy53cml0ZSh0KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbk9wZW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgKHRoaXMucmVhZHlTdGF0ZSA9ICJvcGVuIiksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMud3JpdGFibGUgPSAhMCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJvcGVuIik7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25EYXRhIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IGYuZGVjb2RlUGFja2V0KHQsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpOwogICAgICAgICAgICAgICAgICB0aGlzLm9uUGFja2V0KGUpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uUGFja2V0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoInBhY2tldCIsIHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uQ2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgKHRoaXMucmVhZHlTdGF0ZSA9ICJjbG9zZWQiKSwgdGhpcy5lbWl0KCJjbG9zZSIpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICBdKSAmJiBvKGUucHJvdG90eXBlLCBuKSwKICAgICAgICAgICAgciAmJiBvKGUsIHIpLAogICAgICAgICAgICB1CiAgICAgICAgICApOwogICAgICAgIH0pKGwpOwogICAgICB0LmV4cG9ydHMgPSBoOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgIChlLmVuY29kZSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgdmFyIGUgPSAiIjsKICAgICAgICBmb3IgKHZhciBuIGluIHQpCiAgICAgICAgICB0Lmhhc093blByb3BlcnR5KG4pICYmCiAgICAgICAgICAgIChlLmxlbmd0aCAmJiAoZSArPSAiJiIpLAogICAgICAgICAgICAoZSArPSBlbmNvZGVVUklDb21wb25lbnQobikgKyAiPSIgKyBlbmNvZGVVUklDb21wb25lbnQodFtuXSkpKTsKICAgICAgICByZXR1cm4gZTsKICAgICAgfSksCiAgICAgICAgKGUuZGVjb2RlID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGZvciAodmFyIGUgPSB7fSwgbiA9IHQuc3BsaXQoIiYiKSwgciA9IDAsIG8gPSBuLmxlbmd0aDsgciA8IG87IHIrKykgewogICAgICAgICAgICB2YXIgaSA9IG5bcl0uc3BsaXQoIj0iKTsKICAgICAgICAgICAgZVtkZWNvZGVVUklDb21wb25lbnQoaVswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGlbMV0pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGU7CiAgICAgICAgfSk7CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgZnVuY3Rpb24gcih0KSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJiAic3ltYm9sIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yCiAgICAgICAgICAgID8gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0ICYmCiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdCAhPT0gU3ltYm9sLnByb3RvdHlwZQogICAgICAgICAgICAgICAgICA/ICJzeW1ib2wiCiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbyh0LCBlLCBuKSB7CiAgICAgICAgcmV0dXJuIChvID0KICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0CiAgICAgICAgICAgID8gUmVmbGVjdC5nZXQKICAgICAgICAgICAgOiBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKSAmJgogICAgICAgICAgICAgICAgICAgIG51bGwgIT09ICh0ID0gYSh0KSk7CgogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICByZXR1cm4gdDsKICAgICAgICAgICAgICAgIH0pKHQsIGUpOwogICAgICAgICAgICAgICAgaWYgKHIpIHsKICAgICAgICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIGUpOwogICAgICAgICAgICAgICAgICByZXR1cm4gby5nZXQgPyBvLmdldC5jYWxsKG4pIDogby52YWx1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KSh0LCBlLCBuIHx8IHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGkodCwgZSkgewogICAgICAgIHJldHVybiAoaSA9CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKICAgICAgICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIHJldHVybiAodC5fX3Byb3RvX18gPSBlKSwgdDsKICAgICAgICAgIH0pKHQsIGUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHModCkgewogICAgICAgIHZhciBlID0gKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGlmICgidW5kZWZpbmVkIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTsKICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKAogICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KQogICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgITAKICAgICAgICAgICAgKTsKICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgcmV0dXJuICExOwogICAgICAgICAgfQogICAgICAgIH0pKCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBuLAogICAgICAgICAgICByID0gYSh0KTsKICAgICAgICAgIGlmIChlKSB7CiAgICAgICAgICAgIHZhciBvID0gYSh0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KHIsIGFyZ3VtZW50cywgbyk7CiAgICAgICAgICB9IGVsc2UgbiA9IHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIHJldHVybiBjKHRoaXMsIG4pOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYyh0LCBlKSB7CiAgICAgICAgaWYgKGUgJiYgKCJvYmplY3QiID09PSByKGUpIHx8ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsKICAgICAgICBpZiAodm9pZCAwICE9PSBlKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkIgogICAgICAgICAgKTsKICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICBpZiAodm9pZCAwID09PSB0KQogICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoCiAgICAgICAgICAgICAgInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIKICAgICAgICAgICAgKTsKICAgICAgICAgIHJldHVybiB0OwogICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGEodCkgewogICAgICAgIHJldHVybiAoYSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZgogICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YKICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOwogICAgICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1KHQsIGUpIHsKICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmKHQsIGUpIHsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIHZhciByID0gZVtuXTsKICAgICAgICAgIChyLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEpLAogICAgICAgICAgICAoci5jb25maWd1cmFibGUgPSAhMCksCiAgICAgICAgICAgICJ2YWx1ZSIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIua2V5LCByKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbCh0LCBlLCBuKSB7CiAgICAgICAgcmV0dXJuIGUgJiYgZih0LnByb3RvdHlwZSwgZSksIG4gJiYgZih0LCBuKSwgdDsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiAhMCB9KSwKICAgICAgICAoZS5EZWNvZGVyID0gZS5FbmNvZGVyID0gZS5QYWNrZXRUeXBlID0gZS5wcm90b2NvbCA9IHZvaWQgMCk7CiAgICAgIHZhciBwLAogICAgICAgIGggPSBuKDIpLAogICAgICAgIHkgPSBuKDMwKSwKICAgICAgICBkID0gbigxNSk7CiAgICAgIChlLnByb3RvY29sID0gNSksCiAgICAgICAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAodFsodC5DT05ORUNUID0gMCldID0gIkNPTk5FQ1QiKSwKICAgICAgICAgICAgKHRbKHQuRElTQ09OTkVDVCA9IDEpXSA9ICJESVNDT05ORUNUIiksCiAgICAgICAgICAgICh0Wyh0LkVWRU5UID0gMildID0gIkVWRU5UIiksCiAgICAgICAgICAgICh0Wyh0LkFDSyA9IDMpXSA9ICJBQ0siKSwKICAgICAgICAgICAgKHRbKHQuQ09OTkVDVF9FUlJPUiA9IDQpXSA9ICJDT05ORUNUX0VSUk9SIiksCiAgICAgICAgICAgICh0Wyh0LkJJTkFSWV9FVkVOVCA9IDUpXSA9ICJCSU5BUllfRVZFTlQiKSwKICAgICAgICAgICAgKHRbKHQuQklOQVJZX0FDSyA9IDYpXSA9ICJCSU5BUllfQUNLIik7CiAgICAgICAgfSkoKHAgPSBlLlBhY2tldFR5cGUgfHwgKGUuUGFja2V0VHlwZSA9IHt9KSkpOwogICAgICB2YXIgdiA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgZnVuY3Rpb24gdCgpIHsKICAgICAgICAgIHUodGhpcywgdCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoCiAgICAgICAgICBsKHQsIFsKICAgICAgICAgICAgewogICAgICAgICAgICAgIGtleTogImVuY29kZSIsCiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gKHQudHlwZSAhPT0gcC5FVkVOVCAmJiB0LnR5cGUgIT09IHAuQUNLKSB8fAogICAgICAgICAgICAgICAgICAhZC5oYXNCaW5hcnkodCkKICAgICAgICAgICAgICAgICAgPyBbdGhpcy5lbmNvZGVBc1N0cmluZyh0KV0KICAgICAgICAgICAgICAgICAgOiAoKHQudHlwZSA9CiAgICAgICAgICAgICAgICAgICAgICB0LnR5cGUgPT09IHAuRVZFTlQgPyBwLkJJTkFSWV9FVkVOVCA6IHAuQklOQVJZX0FDSyksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVBc0JpbmFyeSh0KSk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgIGtleTogImVuY29kZUFzU3RyaW5nIiwKICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHZhciBlID0gIiIgKyB0LnR5cGU7CiAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAodC50eXBlICE9PSBwLkJJTkFSWV9FVkVOVCAmJiB0LnR5cGUgIT09IHAuQklOQVJZX0FDSykgfHwKICAgICAgICAgICAgICAgICAgICAoZSArPSB0LmF0dGFjaG1lbnRzICsgIi0iKSwKICAgICAgICAgICAgICAgICAgdC5uc3AgJiYgIi8iICE9PSB0Lm5zcCAmJiAoZSArPSB0Lm5zcCArICIsIiksCiAgICAgICAgICAgICAgICAgIG51bGwgIT0gdC5pZCAmJiAoZSArPSB0LmlkKSwKICAgICAgICAgICAgICAgICAgbnVsbCAhPSB0LmRhdGEgJiYgKGUgKz0gSlNPTi5zdHJpbmdpZnkodC5kYXRhKSksCiAgICAgICAgICAgICAgICAgIGUKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgIGtleTogImVuY29kZUFzQmluYXJ5IiwKICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHZhciBlID0geS5kZWNvbnN0cnVjdFBhY2tldCh0KSwKICAgICAgICAgICAgICAgICAgbiA9IHRoaXMuZW5jb2RlQXNTdHJpbmcoZS5wYWNrZXQpLAogICAgICAgICAgICAgICAgICByID0gZS5idWZmZXJzOwogICAgICAgICAgICAgICAgcmV0dXJuIHIudW5zaGlmdChuKSwgcjsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgXSksCiAgICAgICAgICB0CiAgICAgICAgKTsKICAgICAgfSkoKTsKICAgICAgZS5FbmNvZGVyID0gdjsKICAgICAgdmFyIGIgPSAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAhKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAgICJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIKICAgICAgICAgICAgKTsKICAgICAgICAgICh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgewogICAgICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sCiAgICAgICAgICB9KSksCiAgICAgICAgICAgIGUgJiYgaSh0LCBlKTsKICAgICAgICB9KShuLCB0KTsKICAgICAgICB2YXIgZSA9IHMobik7CiAgICAgICAgZnVuY3Rpb24gbigpIHsKICAgICAgICAgIHJldHVybiB1KHRoaXMsIG4pLCBlLmNhbGwodGhpcyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoCiAgICAgICAgICBsKAogICAgICAgICAgICBuLAogICAgICAgICAgICBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiYWRkIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZTsKICAgICAgICAgICAgICAgICAgaWYgKCJzdHJpbmciID09IHR5cGVvZiB0KQogICAgICAgICAgICAgICAgICAgIChlID0gdGhpcy5kZWNvZGVTdHJpbmcodCkpLnR5cGUgPT09IHAuQklOQVJZX0VWRU5UIHx8CiAgICAgICAgICAgICAgICAgICAgZS50eXBlID09PSBwLkJJTkFSWV9BQ0sKICAgICAgICAgICAgICAgICAgICAgID8gKCh0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgbShlKSksCiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IGUuYXR0YWNobWVudHMgJiYKICAgICAgICAgICAgICAgICAgICAgICAgICBvKGEobi5wcm90b3R5cGUpLCAiZW1pdCIsIHRoaXMpLmNhbGwoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImRlY29kZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZQogICAgICAgICAgICAgICAgICAgICAgICAgICkpCiAgICAgICAgICAgICAgICAgICAgICA6IG8oYShuLnByb3RvdHlwZSksICJlbWl0IiwgdGhpcykuY2FsbCgKICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLAogICAgICAgICAgICAgICAgICAgICAgICAgICJkZWNvZGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmICghZC5pc0JpbmFyeSh0KSAmJiAhdC5iYXNlNjQpCiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gdHlwZTogIiArIHQpOwogICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICAiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0IgogICAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICAoZSA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YSh0KSkgJiYKICAgICAgICAgICAgICAgICAgICAgICgodGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbCksCiAgICAgICAgICAgICAgICAgICAgICBvKGEobi5wcm90b3R5cGUpLCAiZW1pdCIsIHRoaXMpLmNhbGwodGhpcywgImRlY29kZWQiLCBlKSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJkZWNvZGVTdHJpbmciLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gMCwKICAgICAgICAgICAgICAgICAgICByID0geyB0eXBlOiBOdW1iZXIodC5jaGFyQXQoMCkpIH07CiAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHBbci50eXBlXSkKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInVua25vd24gcGFja2V0IHR5cGUgIiArIHIudHlwZSk7CiAgICAgICAgICAgICAgICAgIGlmIChyLnR5cGUgPT09IHAuQklOQVJZX0VWRU5UIHx8IHIudHlwZSA9PT0gcC5CSU5BUllfQUNLKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZSArIDE7CiAgICAgICAgICAgICAgICAgICAgICAiLSIgIT09IHQuY2hhckF0KCsrZSkgJiYgZSAhPSB0Lmxlbmd0aDsKCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQuc3Vic3RyaW5nKG8sIGUpOwogICAgICAgICAgICAgICAgICAgIGlmIChpICE9IE51bWJlcihpKSB8fCAiLSIgIT09IHQuY2hhckF0KGUpKQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbGxlZ2FsIGF0dGFjaG1lbnRzIik7CiAgICAgICAgICAgICAgICAgICAgci5hdHRhY2htZW50cyA9IE51bWJlcihpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoIi8iID09PSB0LmNoYXJBdChlICsgMSkpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gZSArIDE7ICsrZTsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIiwiID09PSB0LmNoYXJBdChlKSkgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PT0gdC5sZW5ndGgpIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByLm5zcCA9IHQuc3Vic3RyaW5nKHMsIGUpOwogICAgICAgICAgICAgICAgICB9IGVsc2Ugci5uc3AgPSAiLyI7CiAgICAgICAgICAgICAgICAgIHZhciBjID0gdC5jaGFyQXQoZSArIDEpOwogICAgICAgICAgICAgICAgICBpZiAoIiIgIT09IGMgJiYgTnVtYmVyKGMpID09IGMpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gZSArIDE7ICsrZTsgKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHQuY2hhckF0KGUpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gdSB8fCBOdW1iZXIodSkgIT0gdSkgewogICAgICAgICAgICAgICAgICAgICAgICAtLWU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IHQubGVuZ3RoKSBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgci5pZCA9IE51bWJlcih0LnN1YnN0cmluZyhhLCBlICsgMSkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICh0LmNoYXJBdCgrK2UpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHQpOwogICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSkodC5zdWJzdHIoZSkpOwogICAgICAgICAgICAgICAgICAgIGlmICghbi5pc1BheWxvYWRWYWxpZChyLnR5cGUsIGYpKQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIHBheWxvYWQiKTsKICAgICAgICAgICAgICAgICAgICByLmRhdGEgPSBmOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiByOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImRlc3Ryb3kiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yICYmCiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSwKICAgICAgICAgICAgWwogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImlzUGF5bG9hZFZhbGlkIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIHAuQ09OTkVDVDoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAib2JqZWN0IiA9PT0gcihlKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIHAuRElTQ09OTkVDVDoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGU7CiAgICAgICAgICAgICAgICAgICAgY2FzZSBwLkNPTk5FQ1RfRVJST1I6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gInN0cmluZyIgPT0gdHlwZW9mIGUgfHwgIm9iamVjdCIgPT09IHIoZSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSBwLkVWRU5UOgogICAgICAgICAgICAgICAgICAgIGNhc2UgcC5CSU5BUllfRVZFTlQ6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlKSAmJiBlLmxlbmd0aCA+IDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSBwLkFDSzoKICAgICAgICAgICAgICAgICAgICBjYXNlIHAuQklOQVJZX0FDSzoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIF0KICAgICAgICAgICksCiAgICAgICAgICBuCiAgICAgICAgKTsKICAgICAgfSkoaCk7CiAgICAgIGUuRGVjb2RlciA9IGI7CiAgICAgIHZhciBtID0gKGZ1bmN0aW9uICgpIHsKICAgICAgICBmdW5jdGlvbiB0KGUpIHsKICAgICAgICAgIHUodGhpcywgdCksCiAgICAgICAgICAgICh0aGlzLnBhY2tldCA9IGUpLAogICAgICAgICAgICAodGhpcy5idWZmZXJzID0gW10pLAogICAgICAgICAgICAodGhpcy5yZWNvblBhY2sgPSBlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuICgKICAgICAgICAgIGwodCwgWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAga2V5OiAidGFrZUJpbmFyeURhdGEiLAogICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgICAodGhpcy5idWZmZXJzLnB1c2godCksCiAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKQogICAgICAgICAgICAgICAgKSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0geS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpLCBlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgIGtleTogImZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24iLAogICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAodGhpcy5yZWNvblBhY2sgPSBudWxsKSwgKHRoaXMuYnVmZmVycyA9IFtdKTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgXSksCiAgICAgICAgICB0CiAgICAgICAgKTsKICAgICAgfSkoKTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICB2YXIgbiA9CiAgICAgICAgICAvXig/Oig/IVteOkBdKzpbXjpAXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcL1wvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XC8/I10qKSg/OjooXGQqKSk/KSgoKFwvKD86W14/I10oPyFbXj8jXC9dKlwuW14/I1wvLl0rKD86Wz8jXXwkKSkpKlwvPyk/KFtePyNcL10qKSkoPzpcPyhbXiNdKikpPyg/OiMoLiopKT8pLywKICAgICAgICByID0gWwogICAgICAgICAgInNvdXJjZSIsCiAgICAgICAgICAicHJvdG9jb2wiLAogICAgICAgICAgImF1dGhvcml0eSIsCiAgICAgICAgICAidXNlckluZm8iLAogICAgICAgICAgInVzZXIiLAogICAgICAgICAgInBhc3N3b3JkIiwKICAgICAgICAgICJob3N0IiwKICAgICAgICAgICJwb3J0IiwKICAgICAgICAgICJyZWxhdGl2ZSIsCiAgICAgICAgICAicGF0aCIsCiAgICAgICAgICAiZGlyZWN0b3J5IiwKICAgICAgICAgICJmaWxlIiwKICAgICAgICAgICJxdWVyeSIsCiAgICAgICAgICAiYW5jaG9yIiwKICAgICAgICBdOwogICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCkgewogICAgICAgIHZhciBlID0gdCwKICAgICAgICAgIG8gPSB0LmluZGV4T2YoIlsiKSwKICAgICAgICAgIGkgPSB0LmluZGV4T2YoIl0iKTsKICAgICAgICAtMSAhPSBvICYmCiAgICAgICAgICAtMSAhPSBpICYmCiAgICAgICAgICAodCA9CiAgICAgICAgICAgIHQuc3Vic3RyaW5nKDAsIG8pICsKICAgICAgICAgICAgdC5zdWJzdHJpbmcobywgaSkucmVwbGFjZSgvOi9nLCAiOyIpICsKICAgICAgICAgICAgdC5zdWJzdHJpbmcoaSwgdC5sZW5ndGgpKTsKICAgICAgICBmb3IgKHZhciBzLCBjLCBhID0gbi5leGVjKHQgfHwgIiIpLCB1ID0ge30sIGYgPSAxNDsgZi0tOyApCiAgICAgICAgICB1W3JbZl1dID0gYVtmXSB8fCAiIjsKICAgICAgICByZXR1cm4gKAogICAgICAgICAgLTEgIT0gbyAmJgogICAgICAgICAgICAtMSAhPSBpICYmCiAgICAgICAgICAgICgodS5zb3VyY2UgPSBlKSwKICAgICAgICAgICAgKHUuaG9zdCA9IHUuaG9zdAogICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSwgdS5ob3N0Lmxlbmd0aCAtIDEpCiAgICAgICAgICAgICAgLnJlcGxhY2UoLzsvZywgIjoiKSksCiAgICAgICAgICAgICh1LmF1dGhvcml0eSA9IHUuYXV0aG9yaXR5CiAgICAgICAgICAgICAgLnJlcGxhY2UoIlsiLCAiIikKICAgICAgICAgICAgICAucmVwbGFjZSgiXSIsICIiKQogICAgICAgICAgICAgIC5yZXBsYWNlKC87L2csICI6IikpLAogICAgICAgICAgICAodS5pcHY2dXJpID0gITApKSwKICAgICAgICAgICh1LnBhdGhOYW1lcyA9IChmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICB2YXIgbiA9IGUucmVwbGFjZSgvXC97Miw5fS9nLCAiLyIpLnNwbGl0KCIvIik7CiAgICAgICAgICAgICgiLyIgIT0gZS5zdWJzdHIoMCwgMSkgJiYgMCAhPT0gZS5sZW5ndGgpIHx8IG4uc3BsaWNlKDAsIDEpOwogICAgICAgICAgICAiLyIgPT0gZS5zdWJzdHIoZS5sZW5ndGggLSAxLCAxKSAmJiBuLnNwbGljZShuLmxlbmd0aCAtIDEsIDEpOwogICAgICAgICAgICByZXR1cm4gbjsKICAgICAgICAgIH0pKDAsIHUucGF0aCkpLAogICAgICAgICAgKHUucXVlcnlLZXkgPQogICAgICAgICAgICAoKHMgPSB1LnF1ZXJ5KSwKICAgICAgICAgICAgKGMgPSB7fSksCiAgICAgICAgICAgIHMucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgICAgICAgICAgZSAmJiAoY1tlXSA9IG4pOwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgYykpLAogICAgICAgICAgdQogICAgICAgICk7CiAgICAgIH07CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgZnVuY3Rpb24gcih0KSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJiAic3ltYm9sIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yCiAgICAgICAgICAgID8gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0ICYmCiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdCAhPT0gU3ltYm9sLnByb3RvdHlwZQogICAgICAgICAgICAgICAgICA/ICJzeW1ib2wiCiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbyh0LCBlKSB7CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7CiAgICAgICAgICB2YXIgciA9IGVbbl07CiAgICAgICAgICAoci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExKSwKICAgICAgICAgICAgKHIuY29uZmlndXJhYmxlID0gITApLAogICAgICAgICAgICAidmFsdWUiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksCiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCByLmtleSwgcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGkodCwgZSkgewogICAgICAgIHJldHVybiAoaSA9CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKICAgICAgICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIHJldHVybiAodC5fX3Byb3RvX18gPSBlKSwgdDsKICAgICAgICAgIH0pKHQsIGUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHModCkgewogICAgICAgIHZhciBlID0gKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGlmICgidW5kZWZpbmVkIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTsKICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKAogICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KQogICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgITAKICAgICAgICAgICAgKTsKICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgcmV0dXJuICExOwogICAgICAgICAgfQogICAgICAgIH0pKCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBuLAogICAgICAgICAgICByID0gdSh0KTsKICAgICAgICAgIGlmIChlKSB7CiAgICAgICAgICAgIHZhciBvID0gdSh0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KHIsIGFyZ3VtZW50cywgbyk7CiAgICAgICAgICB9IGVsc2UgbiA9IHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIHJldHVybiBjKHRoaXMsIG4pOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYyh0LCBlKSB7CiAgICAgICAgaWYgKGUgJiYgKCJvYmplY3QiID09PSByKGUpIHx8ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsKICAgICAgICBpZiAodm9pZCAwICE9PSBlKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkIgogICAgICAgICAgKTsKICAgICAgICByZXR1cm4gYSh0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhKHQpIHsKICAgICAgICBpZiAodm9pZCAwID09PSB0KQogICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKAogICAgICAgICAgICAidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIgogICAgICAgICAgKTsKICAgICAgICByZXR1cm4gdDsKICAgICAgfQogICAgICBmdW5jdGlvbiB1KHQpIHsKICAgICAgICByZXR1cm4gKHUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YKICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mCiAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsKICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogITAgfSksCiAgICAgICAgKGUuTWFuYWdlciA9IHZvaWQgMCk7CiAgICAgIHZhciBmID0gbigyMCksCiAgICAgICAgbCA9IG4oMyksCiAgICAgICAgcCA9IG4oMTQpLAogICAgICAgIGggPSBuKDYpLAogICAgICAgIHkgPSBuKDE2KSwKICAgICAgICBkID0gbigzMSksCiAgICAgICAgdiA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgIShmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgKHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgZSAmJiBpKHQsIGUpOwogICAgICAgICAgfSkodiwgdCk7CiAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgbiwKICAgICAgICAgICAgYywKICAgICAgICAgICAgdSA9IHModik7CiAgICAgICAgICBmdW5jdGlvbiB2KHQsIGUpIHsKICAgICAgICAgICAgdmFyIG4sIG87CiAgICAgICAgICAgICEoZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICAgICAgfSkodGhpcywgdiksCiAgICAgICAgICAgICAgKChuID0gdS5jYWxsKHRoaXMpKS5uc3BzID0ge30pLAogICAgICAgICAgICAgIChuLnN1YnMgPSBbXSksCiAgICAgICAgICAgICAgdCAmJiAib2JqZWN0IiA9PT0gcih0KSAmJiAoKGUgPSB0KSwgKHQgPSB2b2lkIDApKSwKICAgICAgICAgICAgICAoKGUgPSBlIHx8IHt9KS5wYXRoID0gZS5wYXRoIHx8ICIvc29ja2V0LmlvIiksCiAgICAgICAgICAgICAgKG4ub3B0cyA9IGUpLAogICAgICAgICAgICAgICgwLCBsLmluc3RhbGxUaW1lckZ1bmN0aW9ucykoYShuKSwgZSksCiAgICAgICAgICAgICAgbi5yZWNvbm5lY3Rpb24oITEgIT09IGUucmVjb25uZWN0aW9uKSwKICAgICAgICAgICAgICBuLnJlY29ubmVjdGlvbkF0dGVtcHRzKGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgMSAvIDApLAogICAgICAgICAgICAgIG4ucmVjb25uZWN0aW9uRGVsYXkoZS5yZWNvbm5lY3Rpb25EZWxheSB8fCAxZTMpLAogICAgICAgICAgICAgIG4ucmVjb25uZWN0aW9uRGVsYXlNYXgoZS5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1ZTMpLAogICAgICAgICAgICAgIG4ucmFuZG9taXphdGlvbkZhY3RvcigKICAgICAgICAgICAgICAgIG51bGwgIT09IChvID0gZS5yYW5kb21pemF0aW9uRmFjdG9yKSAmJiB2b2lkIDAgIT09IG8gPyBvIDogMC41CiAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAobi5iYWNrb2ZmID0gbmV3IGQoewogICAgICAgICAgICAgICAgbWluOiBuLnJlY29ubmVjdGlvbkRlbGF5KCksCiAgICAgICAgICAgICAgICBtYXg6IG4ucmVjb25uZWN0aW9uRGVsYXlNYXgoKSwKICAgICAgICAgICAgICAgIGppdHRlcjogbi5yYW5kb21pemF0aW9uRmFjdG9yKCksCiAgICAgICAgICAgICAgfSkpLAogICAgICAgICAgICAgIG4udGltZW91dChudWxsID09IGUudGltZW91dCA/IDJlNCA6IGUudGltZW91dCksCiAgICAgICAgICAgICAgKG4uX3JlYWR5U3RhdGUgPSAiY2xvc2VkIiksCiAgICAgICAgICAgICAgKG4udXJpID0gdCk7CiAgICAgICAgICAgIHZhciBpID0gZS5wYXJzZXIgfHwgaDsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAobi5lbmNvZGVyID0gbmV3IGkuRW5jb2RlcigpKSwKICAgICAgICAgICAgICAobi5kZWNvZGVyID0gbmV3IGkuRGVjb2RlcigpKSwKICAgICAgICAgICAgICAobi5fYXV0b0Nvbm5lY3QgPSAhMSAhPT0gZS5hdXRvQ29ubmVjdCksCiAgICAgICAgICAgICAgbi5fYXV0b0Nvbm5lY3QgJiYgbi5vcGVuKCksCiAgICAgICAgICAgICAgbgogICAgICAgICAgICApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgKGUgPSB2KSwKICAgICAgICAgICAgKG4gPSBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAicmVjb25uZWN0aW9uIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgID8gKCh0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXQpLCB0aGlzKQogICAgICAgICAgICAgICAgICAgIDogdGhpcy5fcmVjb25uZWN0aW9uOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInJlY29ubmVjdGlvbkF0dGVtcHRzIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0CiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cwogICAgICAgICAgICAgICAgICAgIDogKCh0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHQpLCB0aGlzKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJyZWNvbm5lY3Rpb25EZWxheSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGU7CiAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQKICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5CiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdCksCiAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSAoZSA9IHRoaXMuYmFja29mZikgfHwKICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBlIHx8CiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0TWluKHQpLAogICAgICAgICAgICAgICAgICAgICAgdGhpcyk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAicmFuZG9taXphdGlvbkZhY3RvciIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGU7CiAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQKICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IKICAgICAgICAgICAgICAgICAgICA6ICgodGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHQpLAogICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gKGUgPSB0aGlzLmJhY2tvZmYpIHx8CiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZSB8fAogICAgICAgICAgICAgICAgICAgICAgICBlLnNldEppdHRlcih0KSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInJlY29ubmVjdGlvbkRlbGF5TWF4IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdAogICAgICAgICAgICAgICAgICAgID8gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXgKICAgICAgICAgICAgICAgICAgICA6ICgodGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB0KSwKICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IChlID0gdGhpcy5iYWNrb2ZmKSB8fAogICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUgfHwKICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRNYXgodCksCiAgICAgICAgICAgICAgICAgICAgICB0aGlzKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJ0aW1lb3V0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgID8gKCh0aGlzLl90aW1lb3V0ID0gdCksIHRoaXMpCiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90aW1lb3V0OwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm1heWJlUmVjb25uZWN0T25PcGVuIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICF0aGlzLl9yZWNvbm5lY3RpbmcgJiYKICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gJiYKICAgICAgICAgICAgICAgICAgICAwID09PSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgJiYKICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9wZW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpczsKICAgICAgICAgICAgICAgICAgaWYgKH50aGlzLl9yZWFkeVN0YXRlLmluZGV4T2YoIm9wZW4iKSkgcmV0dXJuIHRoaXM7CiAgICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZih0aGlzLnVyaSwgdGhpcy5vcHRzKTsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmVuZ2luZSwKICAgICAgICAgICAgICAgICAgICByID0gdGhpczsKICAgICAgICAgICAgICAgICAgKHRoaXMuX3JlYWR5U3RhdGUgPSAib3BlbmluZyIpLCAodGhpcy5za2lwUmVjb25uZWN0ID0gITEpOwogICAgICAgICAgICAgICAgICB2YXIgbyA9ICgwLCB5Lm9uKShuLCAib3BlbiIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgIHIub25vcGVuKCksIHQgJiYgdCgpOwogICAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAgIGkgPSAoMCwgeS5vbikobiwgImVycm9yIiwgZnVuY3Rpb24gKG4pIHsKICAgICAgICAgICAgICAgICAgICAgIHIuY2xlYW51cCgpLAogICAgICAgICAgICAgICAgICAgICAgICAoci5fcmVhZHlTdGF0ZSA9ICJjbG9zZWQiKSwKICAgICAgICAgICAgICAgICAgICAgICAgZS5lbWl0UmVzZXJ2ZWQoImVycm9yIiwgbiksCiAgICAgICAgICAgICAgICAgICAgICAgIHQgPyB0KG4pIDogci5tYXliZVJlY29ubmVjdE9uT3BlbigpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICBpZiAoITEgIT09IHRoaXMuX3RpbWVvdXQpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX3RpbWVvdXQ7CiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcyAmJiBvKCk7CiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnNldFRpbWVvdXRGbihmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICBvKCksIG4uY2xvc2UoKSwgbi5lbWl0KCJlcnJvciIsIG5ldyBFcnJvcigidGltZW91dCIpKTsKICAgICAgICAgICAgICAgICAgICB9LCBzKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuYXV0b1VucmVmICYmIGMudW5yZWYoKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGMpOwogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Vicy5wdXNoKG8pLCB0aGlzLnN1YnMucHVzaChpKSwgdGhpczsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJjb25uZWN0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuKHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9ub3BlbiIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5fcmVhZHlTdGF0ZSA9ICJvcGVuIiksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoIm9wZW4iKTsKICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmVuZ2luZTsKICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goCiAgICAgICAgICAgICAgICAgICAgKDAsIHkub24pKHQsICJwaW5nIiwgdGhpcy5vbnBpbmcuYmluZCh0aGlzKSksCiAgICAgICAgICAgICAgICAgICAgKDAsIHkub24pKHQsICJkYXRhIiwgdGhpcy5vbmRhdGEuYmluZCh0aGlzKSksCiAgICAgICAgICAgICAgICAgICAgKDAsIHkub24pKHQsICJlcnJvciIsIHRoaXMub25lcnJvci5iaW5kKHRoaXMpKSwKICAgICAgICAgICAgICAgICAgICAoMCwgeS5vbikodCwgImNsb3NlIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLAogICAgICAgICAgICAgICAgICAgICgwLCB5Lm9uKSgKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlciwKICAgICAgICAgICAgICAgICAgICAgICJkZWNvZGVkIiwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25kZWNvZGVkLmJpbmQodGhpcykKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25waW5nIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJwaW5nIik7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25kYXRhIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uZGVjb2RlZCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoInBhY2tldCIsIHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uZXJyb3IiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJlcnJvciIsIHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInNvY2tldCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm5zcHNbdF07CiAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgbiB8fCAoKG4gPSBuZXcgcC5Tb2NrZXQodGhpcywgdCwgZSkpLCAodGhpcy5uc3BzW3RdID0gbikpLCBuCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiX2Rlc3Ryb3kiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSAwLCBuID0gT2JqZWN0LmtleXModGhpcy5uc3BzKTsKICAgICAgICAgICAgICAgICAgICBlIDwgbi5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgZSsrCiAgICAgICAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgICAgIHZhciByID0gbltlXTsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uc3BzW3JdLmFjdGl2ZSkgcmV0dXJuOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiX3BhY2tldCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMuZW5jb2Rlci5lbmNvZGUodCksIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykKICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS53cml0ZShlW25dLCB0Lm9wdGlvbnMpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImNsZWFudXAiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCgpOwogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5zdWJzLmxlbmd0aCA9IDApLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiX2Nsb3NlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICh0aGlzLnNraXBSZWNvbm5lY3QgPSAhMCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3JlY29ubmVjdGluZyA9ICExKSwKICAgICAgICAgICAgICAgICAgICAib3BlbmluZyIgPT09IHRoaXMuX3JlYWR5U3RhdGUgJiYgdGhpcy5jbGVhbnVwKCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3JlYWR5U3RhdGUgPSAiY2xvc2VkIiksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuY2xvc2UoKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJkaXNjb25uZWN0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uY2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLl9yZWFkeVN0YXRlID0gImNsb3NlZCIpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJjbG9zZSIsIHQpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbiAmJgogICAgICAgICAgICAgICAgICAgICAgIXRoaXMuc2tpcFJlY29ubmVjdCAmJgogICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJyZWNvbm5lY3QiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzOwogICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpczsKICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykKICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJyZWNvbm5lY3RfZmFpbGVkIiksCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5fcmVjb25uZWN0aW5nID0gITEpOwogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9ICEwOwogICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5zZXRUaW1lb3V0Rm4oZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgZS5za2lwUmVjb25uZWN0IHx8CiAgICAgICAgICAgICAgICAgICAgICAgICh0LmVtaXRSZXNlcnZlZCgKICAgICAgICAgICAgICAgICAgICAgICAgICAicmVjb25uZWN0X2F0dGVtcHQiLAogICAgICAgICAgICAgICAgICAgICAgICAgIGUuYmFja29mZi5hdHRlbXB0cwogICAgICAgICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgICAgICAgICBlLnNraXBSZWNvbm5lY3QgfHwKICAgICAgICAgICAgICAgICAgICAgICAgICBlLm9wZW4oZnVuY3Rpb24gKG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKGUuX3JlY29ubmVjdGluZyA9ICExKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnJlY29ubmVjdCgpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZW1pdFJlc2VydmVkKCJyZWNvbm5lY3RfZXJyb3IiLCBuKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlLm9ucmVjb25uZWN0KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgIH0sIG4pOwogICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5hdXRvVW5yZWYgJiYgci51bnJlZigpLAogICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocik7CiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9ucmVjb25uZWN0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzOwogICAgICAgICAgICAgICAgICAodGhpcy5fcmVjb25uZWN0aW5nID0gITEpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJyZWNvbm5lY3QiLCB0KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSkgJiYgbyhlLnByb3RvdHlwZSwgbiksCiAgICAgICAgICAgIGMgJiYgbyhlLCBjKSwKICAgICAgICAgICAgdgogICAgICAgICAgKTsKICAgICAgICB9KShuKDE3KS5TdHJpY3RFdmVudEVtaXR0ZXIpOwogICAgICBlLk1hbmFnZXIgPSB2OwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIHZhciByID0gbigxMCksCiAgICAgICAgbyA9IG4oMjMpLAogICAgICAgIGkgPSBuKDI3KSwKICAgICAgICBzID0gbigyOCk7CiAgICAgIChlLnBvbGxpbmcgPSBmdW5jdGlvbiAodCkgewogICAgICAgIHZhciBlID0gITEsCiAgICAgICAgICBuID0gITEsCiAgICAgICAgICBzID0gITEgIT09IHQuanNvbnA7CiAgICAgICAgaWYgKCJ1bmRlZmluZWQiICE9IHR5cGVvZiBsb2NhdGlvbikgewogICAgICAgICAgdmFyIGMgPSAiaHR0cHM6IiA9PT0gbG9jYXRpb24ucHJvdG9jb2wsCiAgICAgICAgICAgIGEgPSBsb2NhdGlvbi5wb3J0OwogICAgICAgICAgYSB8fCAoYSA9IGMgPyA0NDMgOiA4MCksCiAgICAgICAgICAgIChlID0gdC5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgYSAhPT0gdC5wb3J0KSwKICAgICAgICAgICAgKG4gPSB0LnNlY3VyZSAhPT0gYyk7CiAgICAgICAgfQogICAgICAgIGlmICgKICAgICAgICAgICgodC54ZG9tYWluID0gZSksCiAgICAgICAgICAodC54c2NoZW1lID0gbiksCiAgICAgICAgICAib3BlbiIgaW4gbmV3IHIodCkgJiYgIXQuZm9yY2VKU09OUCkKICAgICAgICApCiAgICAgICAgICByZXR1cm4gbmV3IG8odCk7CiAgICAgICAgaWYgKCFzKSB0aHJvdyBuZXcgRXJyb3IoIkpTT05QIGRpc2FibGVkIik7CiAgICAgICAgcmV0dXJuIG5ldyBpKHQpOwogICAgICB9KSwKICAgICAgICAoZS53ZWJzb2NrZXQgPSBzKTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICB2YXIgciA9IG4oMjIpLAogICAgICAgIG8gPSBuKDApOwogICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCkgewogICAgICAgIHZhciBlID0gdC54ZG9tYWluLAogICAgICAgICAgbiA9IHQueHNjaGVtZSwKICAgICAgICAgIGkgPSB0LmVuYWJsZXNYRFI7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCFlIHx8IHIpKQogICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCJ1bmRlZmluZWQiICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAhbiAmJiBpKQogICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7CiAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICBpZiAoIWUpCiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gbmV3IG9bWyJBY3RpdmUiXS5jb25jYXQoIk9iamVjdCIpLmpvaW4oIlgiKV0oCiAgICAgICAgICAgICAgIk1pY3Jvc29mdC5YTUxIVFRQIgogICAgICAgICAgICApOwogICAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgfTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICBmdW5jdGlvbiByKHQpIHsKICAgICAgICByZXR1cm4gKHIgPQogICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgU3ltYm9sICYmICJzeW1ib2wiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IKICAgICAgICAgICAgPyBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHQgJiYKICAgICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0ICE9PSBTeW1ib2wucHJvdG90eXBlCiAgICAgICAgICAgICAgICAgID8gInN5bWJvbCIKICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvKHQsIGUpIHsKICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpKHQsIGUpIHsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIHZhciByID0gZVtuXTsKICAgICAgICAgIChyLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEpLAogICAgICAgICAgICAoci5jb25maWd1cmFibGUgPSAhMCksCiAgICAgICAgICAgICJ2YWx1ZSIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIua2V5LCByKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcyh0LCBlKSB7CiAgICAgICAgcmV0dXJuIChzID0KICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAogICAgICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgcmV0dXJuICh0Ll9fcHJvdG9fXyA9IGUpLCB0OwogICAgICAgICAgfSkodCwgZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYyh0KSB7CiAgICAgICAgdmFyIGUgPSAoZnVuY3Rpb24gKCkgewogICAgICAgICAgaWYgKCJ1bmRlZmluZWQiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExOwogICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTsKICAgICAgICAgIGlmICgiZnVuY3Rpb24iID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoCiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pCiAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAhMAogICAgICAgICAgICApOwogICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICByZXR1cm4gITE7CiAgICAgICAgICB9CiAgICAgICAgfSkoKTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIG4sCiAgICAgICAgICAgIHIgPSB1KHQpOwogICAgICAgICAgaWYgKGUpIHsKICAgICAgICAgICAgdmFyIG8gPSB1KHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QociwgYXJndW1lbnRzLCBvKTsKICAgICAgICAgIH0gZWxzZSBuID0gci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgcmV0dXJuIGEodGhpcywgbik7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhKHQsIGUpIHsKICAgICAgICBpZiAoZSAmJiAoIm9iamVjdCIgPT09IHIoZSkgfHwgImZ1bmN0aW9uIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOwogICAgICAgIGlmICh2b2lkIDAgIT09IGUpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiCiAgICAgICAgICApOwogICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpCiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigKICAgICAgICAgICAgICAidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIgogICAgICAgICAgICApOwogICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdSh0KSB7CiAgICAgICAgcmV0dXJuICh1ID0gT2JqZWN0LnNldFByb3RvdHlwZU9mCiAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZgogICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7CiAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIHZhciBmID0gbig0KSwKICAgICAgICBsID0gbig1KSwKICAgICAgICBwID0gbigxKSwKICAgICAgICBoID0gbigxMyksCiAgICAgICAgeSA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgIShmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgKHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgZSAmJiBzKHQsIGUpOwogICAgICAgICAgfSkodSwgdCk7CiAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgbiwKICAgICAgICAgICAgciwKICAgICAgICAgICAgYSA9IGModSk7CiAgICAgICAgICBmdW5jdGlvbiB1KCkgewogICAgICAgICAgICByZXR1cm4gbyh0aGlzLCB1KSwgYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgKGUgPSB1KSwKICAgICAgICAgICAgKG4gPSBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAibmFtZSIsCiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICJwb2xsaW5nIjsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJkb09wZW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAicGF1c2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpczsKICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gInBhdXNpbmciOwogICAgICAgICAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAoZS5yZWFkeVN0YXRlID0gInBhdXNlZCIpLCB0KCk7CiAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgciA9IDA7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsaW5nICYmCiAgICAgICAgICAgICAgICAgICAgICAocisrLAogICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKCJwb2xsQ29tcGxldGUiLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC0tciB8fCBuKCk7CiAgICAgICAgICAgICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlIHx8CiAgICAgICAgICAgICAgICAgICAgICAgIChyKyssCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZSgiZHJhaW4iLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgLS1yIHx8IG4oKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgbigpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInBvbGwiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgKHRoaXMucG9sbGluZyA9ICEwKSwgdGhpcy5kb1BvbGwoKSwgdGhpcy5lbWl0KCJwb2xsIik7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25EYXRhIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7CiAgICAgICAgICAgICAgICAgIHAKICAgICAgICAgICAgICAgICAgICAuZGVjb2RlUGF5bG9hZCh0LCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKQogICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICAgICAgICgib3BlbmluZyIgPT09IGUucmVhZHlTdGF0ZSAmJgogICAgICAgICAgICAgICAgICAgICAgICAgICJvcGVuIiA9PT0gdC50eXBlICYmCiAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vbk9wZW4oKSwKICAgICAgICAgICAgICAgICAgICAgICAgImNsb3NlIiA9PT0gdC50eXBlKQogICAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5vbkNsb3NlKCksICExOwogICAgICAgICAgICAgICAgICAgICAgZS5vblBhY2tldCh0KTsKICAgICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAiY2xvc2VkIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmCiAgICAgICAgICAgICAgICAgICAgICAoKHRoaXMucG9sbGluZyA9ICExKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgicG9sbENvbXBsZXRlIiksCiAgICAgICAgICAgICAgICAgICAgICAib3BlbiIgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnBvbGwoKSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZG9DbG9zZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsCiAgICAgICAgICAgICAgICAgICAgZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgIHQud3JpdGUoW3sgdHlwZTogImNsb3NlIiB9XSk7CiAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgIm9wZW4iID09PSB0aGlzLnJlYWR5U3RhdGUgPyBlKCkgOiB0aGlzLm9uY2UoIm9wZW4iLCBlKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJ3cml0ZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzOwogICAgICAgICAgICAgICAgICAodGhpcy53cml0YWJsZSA9ICExKSwKICAgICAgICAgICAgICAgICAgICBwLmVuY29kZVBheWxvYWQodCwgZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIGUuZG9Xcml0ZSh0LCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIChlLndyaXRhYmxlID0gITApLCBlLmVtaXQoImRyYWluIik7CiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJ1cmkiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnF1ZXJ5IHx8IHt9LAogICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLm9wdHMuc2VjdXJlID8gImh0dHBzIiA6ICJodHRwIiwKICAgICAgICAgICAgICAgICAgICBuID0gIiI7CiAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgITEgIT09IHRoaXMub3B0cy50aW1lc3RhbXBSZXF1ZXN0cyAmJgogICAgICAgICAgICAgICAgICAgICAgKHRbdGhpcy5vcHRzLnRpbWVzdGFtcFBhcmFtXSA9IGgoKSksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSB8fCB0LnNpZCB8fCAodC5iNjQgPSAxKSwKICAgICAgICAgICAgICAgICAgICAodCA9IGwuZW5jb2RlKHQpKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMucG9ydCAmJgogICAgICAgICAgICAgICAgICAgICAgKCgiaHR0cHMiID09PSBlICYmIDQ0MyAhPT0gTnVtYmVyKHRoaXMub3B0cy5wb3J0KSkgfHwKICAgICAgICAgICAgICAgICAgICAgICAgKCJodHRwIiA9PT0gZSAmJiA4MCAhPT0gTnVtYmVyKHRoaXMub3B0cy5wb3J0KSkpICYmCiAgICAgICAgICAgICAgICAgICAgICAobiA9ICI6IiArIHRoaXMub3B0cy5wb3J0KSwKICAgICAgICAgICAgICAgICAgICB0Lmxlbmd0aCAmJiAodCA9ICI/IiArIHQpLAogICAgICAgICAgICAgICAgICAgIGUgKwogICAgICAgICAgICAgICAgICAgICAgIjovLyIgKwogICAgICAgICAgICAgICAgICAgICAgKC0xICE9PSB0aGlzLm9wdHMuaG9zdG5hbWUuaW5kZXhPZigiOiIpCiAgICAgICAgICAgICAgICAgICAgICAgID8gIlsiICsgdGhpcy5vcHRzLmhvc3RuYW1lICsgIl0iCiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRzLmhvc3RuYW1lKSArCiAgICAgICAgICAgICAgICAgICAgICBuICsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICsKICAgICAgICAgICAgICAgICAgICAgIHQKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSkgJiYgaShlLnByb3RvdHlwZSwgbiksCiAgICAgICAgICAgIHIgJiYgaShlLCByKSwKICAgICAgICAgICAgdQogICAgICAgICAgKTsKICAgICAgICB9KShmKTsKICAgICAgdC5leHBvcnRzID0geTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICAgIChuLm9wZW4gPSAiMCIpLAogICAgICAgIChuLmNsb3NlID0gIjEiKSwKICAgICAgICAobi5waW5nID0gIjIiKSwKICAgICAgICAobi5wb25nID0gIjMiKSwKICAgICAgICAobi5tZXNzYWdlID0gIjQiKSwKICAgICAgICAobi51cGdyYWRlID0gIjUiKSwKICAgICAgICAobi5ub29wID0gIjYiKTsKICAgICAgdmFyIHIgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgcltuW3RdXSA9IHQ7CiAgICAgIH0pOwogICAgICB0LmV4cG9ydHMgPSB7CiAgICAgICAgUEFDS0VUX1RZUEVTOiBuLAogICAgICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFOiByLAogICAgICAgIEVSUk9SX1BBQ0tFVDogeyB0eXBlOiAiZXJyb3IiLCBkYXRhOiAicGFyc2VyIGVycm9yIiB9LAogICAgICB9OwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIHZhciByLAogICAgICAgIG8gPQogICAgICAgICAgIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8iLnNwbGl0KAogICAgICAgICAgICAiIgogICAgICAgICAgKSwKICAgICAgICBpID0ge30sCiAgICAgICAgcyA9IDAsCiAgICAgICAgYyA9IDA7CiAgICAgIGZ1bmN0aW9uIGEodCkgewogICAgICAgIHZhciBlID0gIiI7CiAgICAgICAgZG8gewogICAgICAgICAgKGUgPSBvW3QgJSA2NF0gKyBlKSwgKHQgPSBNYXRoLmZsb29yKHQgLyA2NCkpOwogICAgICAgIH0gd2hpbGUgKHQgPiAwKTsKICAgICAgICByZXR1cm4gZTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1KCkgewogICAgICAgIHZhciB0ID0gYSgrbmV3IERhdGUoKSk7CiAgICAgICAgcmV0dXJuIHQgIT09IHIgPyAoKHMgPSAwKSwgKHIgPSB0KSkgOiB0ICsgIi4iICsgYShzKyspOwogICAgICB9CiAgICAgIGZvciAoOyBjIDwgNjQ7IGMrKykgaVtvW2NdXSA9IGM7CiAgICAgICh1LmVuY29kZSA9IGEpLAogICAgICAgICh1LmRlY29kZSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB2YXIgZSA9IDA7CiAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgdC5sZW5ndGg7IGMrKykgZSA9IDY0ICogZSArIGlbdC5jaGFyQXQoYyldOwogICAgICAgICAgcmV0dXJuIGU7CiAgICAgICAgfSksCiAgICAgICAgKHQuZXhwb3J0cyA9IHUpOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIodCkgewogICAgICAgIHJldHVybiAociA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG8odCwgZSkgewogICAgICAgIHZhciBuID0KICAgICAgICAgICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgU3ltYm9sICYmIHRbU3ltYm9sLml0ZXJhdG9yXSkgfHwKICAgICAgICAgIHRbIkBAaXRlcmF0b3IiXTsKICAgICAgICBpZiAoIW4pIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0KSB8fAogICAgICAgICAgICAobiA9IChmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuOwogICAgICAgICAgICAgIGlmICgic3RyaW5nIiA9PSB0eXBlb2YgdCkgcmV0dXJuIGkodCwgZSk7CiAgICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwgLTEpOwogICAgICAgICAgICAgICJPYmplY3QiID09PSBuICYmIHQuY29uc3RydWN0b3IgJiYgKG4gPSB0LmNvbnN0cnVjdG9yLm5hbWUpOwogICAgICAgICAgICAgIGlmICgiTWFwIiA9PT0gbiB8fCAiU2V0IiA9PT0gbikgcmV0dXJuIEFycmF5LmZyb20odCk7CiAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgIkFyZ3VtZW50cyIgPT09IG4gfHwKICAgICAgICAgICAgICAgIC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgcmV0dXJuIGkodCwgZSk7CiAgICAgICAgICAgIH0pKHQpKSB8fAogICAgICAgICAgICAoZSAmJiB0ICYmICJudW1iZXIiID09IHR5cGVvZiB0Lmxlbmd0aCkKICAgICAgICAgICkgewogICAgICAgICAgICBuICYmICh0ID0gbik7CiAgICAgICAgICAgIHZhciByID0gMCwKICAgICAgICAgICAgICBvID0gZnVuY3Rpb24gKCkge307CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgczogbywKICAgICAgICAgICAgICBuOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gciA+PSB0Lmxlbmd0aAogICAgICAgICAgICAgICAgICA/IHsgZG9uZTogITAgfQogICAgICAgICAgICAgICAgICA6IHsgZG9uZTogITEsIHZhbHVlOiB0W3IrK10gfTsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIGU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICB0aHJvdyB0OwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgZjogbywKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIgogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgdmFyIHMsCiAgICAgICAgICBjID0gITAsCiAgICAgICAgICBhID0gITE7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHM6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgbiA9IG4uY2FsbCh0KTsKICAgICAgICAgIH0sCiAgICAgICAgICBuOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHZhciB0ID0gbi5uZXh0KCk7CiAgICAgICAgICAgIHJldHVybiAoYyA9IHQuZG9uZSksIHQ7CiAgICAgICAgICB9LAogICAgICAgICAgZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgKGEgPSAhMCksIChzID0gdCk7CiAgICAgICAgICB9LAogICAgICAgICAgZjogZnVuY3Rpb24gKCkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGMgfHwgbnVsbCA9PSBuLnJldHVybiB8fCBuLnJldHVybigpOwogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgIGlmIChhKSB0aHJvdyBzOwogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaSh0LCBlKSB7CiAgICAgICAgKG51bGwgPT0gZSB8fCBlID4gdC5sZW5ndGgpICYmIChlID0gdC5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIG4gPSAwLCByID0gbmV3IEFycmF5KGUpOyBuIDwgZTsgbisrKSByW25dID0gdFtuXTsKICAgICAgICByZXR1cm4gcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzKHQsIGUpIHsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIHZhciByID0gZVtuXTsKICAgICAgICAgIChyLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEpLAogICAgICAgICAgICAoci5jb25maWd1cmFibGUgPSAhMCksCiAgICAgICAgICAgICJ2YWx1ZSIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIua2V5LCByKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYyh0LCBlLCBuKSB7CiAgICAgICAgcmV0dXJuIChjID0KICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0CiAgICAgICAgICAgID8gUmVmbGVjdC5nZXQKICAgICAgICAgICAgOiBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKSAmJgogICAgICAgICAgICAgICAgICAgIG51bGwgIT09ICh0ID0gbCh0KSk7CgogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICByZXR1cm4gdDsKICAgICAgICAgICAgICAgIH0pKHQsIGUpOwogICAgICAgICAgICAgICAgaWYgKHIpIHsKICAgICAgICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIGUpOwogICAgICAgICAgICAgICAgICByZXR1cm4gby5nZXQgPyBvLmdldC5jYWxsKG4pIDogby52YWx1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KSh0LCBlLCBuIHx8IHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGEodCwgZSkgewogICAgICAgIHJldHVybiAoYSA9CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwKICAgICAgICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIHJldHVybiAodC5fX3Byb3RvX18gPSBlKSwgdDsKICAgICAgICAgIH0pKHQsIGUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHUodCkgewogICAgICAgIHZhciBlID0gKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGlmICgidW5kZWZpbmVkIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTsKICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKAogICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KQogICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgITAKICAgICAgICAgICAgKTsKICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgcmV0dXJuICExOwogICAgICAgICAgfQogICAgICAgIH0pKCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBuLAogICAgICAgICAgICByID0gbCh0KTsKICAgICAgICAgIGlmIChlKSB7CiAgICAgICAgICAgIHZhciBvID0gbCh0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KHIsIGFyZ3VtZW50cywgbyk7CiAgICAgICAgICB9IGVsc2UgbiA9IHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIHJldHVybiBmKHRoaXMsIG4pOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZih0LCBlKSB7CiAgICAgICAgaWYgKGUgJiYgKCJvYmplY3QiID09PSByKGUpIHx8ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsKICAgICAgICBpZiAodm9pZCAwICE9PSBlKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkIgogICAgICAgICAgKTsKICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICBpZiAodm9pZCAwID09PSB0KQogICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoCiAgICAgICAgICAgICAgInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIKICAgICAgICAgICAgKTsKICAgICAgICAgIHJldHVybiB0OwogICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGwodCkgewogICAgICAgIHJldHVybiAobCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZgogICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YKICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOwogICAgICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiAhMCB9KSwKICAgICAgICAoZS5Tb2NrZXQgPSB2b2lkIDApOwogICAgICB2YXIgcCA9IG4oNiksCiAgICAgICAgaCA9IG4oMTYpLAogICAgICAgIHkgPSBuKDE3KSwKICAgICAgICBkID0gT2JqZWN0LmZyZWV6ZSh7CiAgICAgICAgICBjb25uZWN0OiAxLAogICAgICAgICAgY29ubmVjdF9lcnJvcjogMSwKICAgICAgICAgIGRpc2Nvbm5lY3Q6IDEsCiAgICAgICAgICBkaXNjb25uZWN0aW5nOiAxLAogICAgICAgICAgbmV3TGlzdGVuZXI6IDEsCiAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogMSwKICAgICAgICB9KSwKICAgICAgICB2ID0gKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAhKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIGlmICgiZnVuY3Rpb24iICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpCiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIKICAgICAgICAgICAgICApOwogICAgICAgICAgICAodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsKICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sCiAgICAgICAgICAgIH0pKSwKICAgICAgICAgICAgICBlICYmIGEodCwgZSk7CiAgICAgICAgICB9KShmLCB0KTsKICAgICAgICAgIHZhciBlLAogICAgICAgICAgICBuLAogICAgICAgICAgICByLAogICAgICAgICAgICBpID0gdShmKTsKICAgICAgICAgIGZ1bmN0aW9uIGYodCwgZSwgbikgewogICAgICAgICAgICB2YXIgcjsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAoZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBlKSkKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgICAgICAgfSkodGhpcywgZiksCiAgICAgICAgICAgICAgKChyID0gaS5jYWxsKHRoaXMpKS5jb25uZWN0ZWQgPSAhMSksCiAgICAgICAgICAgICAgKHIuZGlzY29ubmVjdGVkID0gITApLAogICAgICAgICAgICAgIChyLnJlY2VpdmVCdWZmZXIgPSBbXSksCiAgICAgICAgICAgICAgKHIuc2VuZEJ1ZmZlciA9IFtdKSwKICAgICAgICAgICAgICAoci5pZHMgPSAwKSwKICAgICAgICAgICAgICAoci5hY2tzID0ge30pLAogICAgICAgICAgICAgIChyLmZsYWdzID0ge30pLAogICAgICAgICAgICAgIChyLmlvID0gdCksCiAgICAgICAgICAgICAgKHIubnNwID0gZSksCiAgICAgICAgICAgICAgbiAmJiBuLmF1dGggJiYgKHIuYXV0aCA9IG4uYXV0aCksCiAgICAgICAgICAgICAgci5pby5fYXV0b0Nvbm5lY3QgJiYgci5vcGVuKCksCiAgICAgICAgICAgICAgcgogICAgICAgICAgICApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgKGUgPSBmKSwKICAgICAgICAgICAgKG4gPSBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAic3ViRXZlbnRzIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdWJzKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlvOwogICAgICAgICAgICAgICAgICAgIHRoaXMuc3VicyA9IFsKICAgICAgICAgICAgICAgICAgICAgICgwLCBoLm9uKSh0LCAib3BlbiIsIHRoaXMub25vcGVuLmJpbmQodGhpcykpLAogICAgICAgICAgICAgICAgICAgICAgKDAsIGgub24pKHQsICJwYWNrZXQiLCB0aGlzLm9ucGFja2V0LmJpbmQodGhpcykpLAogICAgICAgICAgICAgICAgICAgICAgKDAsIGgub24pKHQsICJlcnJvciIsIHRoaXMub25lcnJvci5iaW5kKHRoaXMpKSwKICAgICAgICAgICAgICAgICAgICAgICgwLCBoLm9uKSh0LCAiY2xvc2UiLCB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKSksCiAgICAgICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImFjdGl2ZSIsCiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5zdWJzOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImNvbm5lY3QiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCB8fAogICAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3ViRXZlbnRzKCksCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlvLl9yZWNvbm5lY3RpbmcgfHwgdGhpcy5pby5vcGVuKCksCiAgICAgICAgICAgICAgICAgICAgICAib3BlbiIgPT09IHRoaXMuaW8uX3JlYWR5U3RhdGUgJiYgdGhpcy5vbm9wZW4oKSksCiAgICAgICAgICAgICAgICAgICAgdGhpcwogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9wZW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCgpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInNlbmQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIGUgPSBuZXcgQXJyYXkodCksIG4gPSAwOwogICAgICAgICAgICAgICAgICAgIG4gPCB0OwogICAgICAgICAgICAgICAgICAgIG4rKwogICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZVtuXSA9IGFyZ3VtZW50c1tuXTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudW5zaGlmdCgibWVzc2FnZSIpLCB0aGlzLmVtaXQuYXBwbHkodGhpcywgZSksIHRoaXM7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZW1pdCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgaWYgKGQuaGFzT3duUHJvcGVydHkodCkpCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCciJyArIHQgKyAnIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWUnKTsKICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICAgICAgICAgICAgICBuID0gbmV3IEFycmF5KGUgPiAxID8gZSAtIDEgOiAwKSwKICAgICAgICAgICAgICAgICAgICAgIHIgPSAxOwogICAgICAgICAgICAgICAgICAgIHIgPCBlOwogICAgICAgICAgICAgICAgICAgIHIrKwogICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgbltyIC0gMV0gPSBhcmd1bWVudHNbcl07CiAgICAgICAgICAgICAgICAgIG4udW5zaGlmdCh0KTsKICAgICAgICAgICAgICAgICAgdmFyIG8gPSB7IHR5cGU6IHAuUGFja2V0VHlwZS5FVkVOVCwgZGF0YTogbiwgb3B0aW9uczoge30gfTsKICAgICAgICAgICAgICAgICAgKG8ub3B0aW9ucy5jb21wcmVzcyA9ICExICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzKSwKICAgICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBuW24ubGVuZ3RoIC0gMV0gJiYKICAgICAgICAgICAgICAgICAgICAgICgodGhpcy5hY2tzW3RoaXMuaWRzXSA9IG4ucG9wKCkpLCAoby5pZCA9IHRoaXMuaWRzKyspKTsKICAgICAgICAgICAgICAgICAgdmFyIGkgPQogICAgICAgICAgICAgICAgICAgICAgdGhpcy5pby5lbmdpbmUgJiYKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW8uZW5naW5lLnRyYW5zcG9ydCAmJgogICAgICAgICAgICAgICAgICAgICAgdGhpcy5pby5lbmdpbmUudHJhbnNwb3J0LndyaXRhYmxlLAogICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLmZsYWdzLnZvbGF0aWxlICYmICghaSB8fCAhdGhpcy5jb25uZWN0ZWQpOwogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgIHMgfHwKICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNvbm5lY3RlZAogICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFja2V0KG8pCiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZW5kQnVmZmVyLnB1c2gobykpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLmZsYWdzID0ge30pLAogICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJwYWNrZXQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICh0Lm5zcCA9IHRoaXMubnNwKSwgdGhpcy5pby5fcGFja2V0KHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9ub3BlbiIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7CiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIHRoaXMuYXV0aAogICAgICAgICAgICAgICAgICAgID8gdGhpcy5hdXRoKGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHQucGFja2V0KHsgdHlwZTogcC5QYWNrZXRUeXBlLkNPTk5FQ1QsIGRhdGE6IGUgfSk7CiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgIDogdGhpcy5wYWNrZXQoewogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwLlBhY2tldFR5cGUuQ09OTkVDVCwKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5hdXRoLAogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25lcnJvciIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5lbWl0UmVzZXJ2ZWQoImNvbm5lY3RfZXJyb3IiLCB0KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbmNsb3NlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAodGhpcy5jb25uZWN0ZWQgPSAhMSksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGlzY29ubmVjdGVkID0gITApLAogICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlkLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKCJkaXNjb25uZWN0IiwgdCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25wYWNrZXQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIGlmICh0Lm5zcCA9PT0gdGhpcy5uc3ApCiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LnR5cGUpIHsKICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcC5QYWNrZXRUeXBlLkNPTk5FQ1Q6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmRhdGEgJiYgdC5kYXRhLnNpZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdC5kYXRhLnNpZDsKICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY29ubmVjdChlKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY29ubmVjdF9lcnJvciIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byByZWFjaCBhIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdjIueCB3aXRoIGEgdjMueCBjbGllbnQsIGJ1dCB0aGV5IGFyZSBub3QgY29tcGF0aWJsZSAobW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL3NvY2tldC5pby9kb2NzL3YzL21pZ3JhdGluZy1mcm9tLTIteC10by0zLTAvKSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcC5QYWNrZXRUeXBlLkVWRU5UOgogICAgICAgICAgICAgICAgICAgICAgY2FzZSBwLlBhY2tldFR5cGUuQklOQVJZX0VWRU5UOgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXZlbnQodCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgY2FzZSBwLlBhY2tldFR5cGUuQUNLOgogICAgICAgICAgICAgICAgICAgICAgY2FzZSBwLlBhY2tldFR5cGUuQklOQVJZX0FDSzoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmFjayh0KTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICBjYXNlIHAuUGFja2V0VHlwZS5ESVNDT05ORUNUOgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcC5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IEVycm9yKHQuZGF0YS5tZXNzYWdlKTsKICAgICAgICAgICAgICAgICAgICAgICAgKG4uZGF0YSA9IHQuZGF0YS5kYXRhKSwKICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZCgiY29ubmVjdF9lcnJvciIsIG4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbmV2ZW50IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IHQuZGF0YSB8fCBbXTsKICAgICAgICAgICAgICAgICAgbnVsbCAhPSB0LmlkICYmIGUucHVzaCh0aGlzLmFjayh0LmlkKSksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQKICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5lbWl0RXZlbnQoZSkKICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goT2JqZWN0LmZyZWV6ZShlKSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZW1pdEV2ZW50IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW55TGlzdGVuZXJzICYmIHRoaXMuX2FueUxpc3RlbmVycy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgICAgICAgICAgIG4gPSBvKHRoaXMuX2FueUxpc3RlbmVycy5zbGljZSgpKTsKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgZm9yIChuLnMoKTsgIShlID0gbi5uKCkpLmRvbmU7ICkgZS52YWx1ZS5hcHBseSh0aGlzLCB0KTsKICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgICAgICAgICAgICBuLmUodCk7CiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgICAgICAgIG4uZigpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjKGwoZi5wcm90b3R5cGUpLCAiZW1pdCIsIHRoaXMpLmFwcGx5KHRoaXMsIHQpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImFjayIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLAogICAgICAgICAgICAgICAgICAgIG4gPSAhMTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoIW4pIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSAhMDsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShyKSwgaSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGkgPCByOwogICAgICAgICAgICAgICAgICAgICAgICBpKysKICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgb1tpXSA9IGFyZ3VtZW50c1tpXTsKICAgICAgICAgICAgICAgICAgICAgIGUucGFja2V0KHsgdHlwZTogcC5QYWNrZXRUeXBlLkFDSywgaWQ6IHQsIGRhdGE6IG8gfSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uYWNrIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuYWNrc1t0LmlkXTsKICAgICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgZSAmJgogICAgICAgICAgICAgICAgICAgIChlLmFwcGx5KHRoaXMsIHQuZGF0YSksIGRlbGV0ZSB0aGlzLmFja3NbdC5pZF0pOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uY29ubmVjdCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgKHRoaXMuaWQgPSB0KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5jb25uZWN0ZWQgPSAhMCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGlzY29ubmVjdGVkID0gITEpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkKCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoImNvbm5lY3QiKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJlbWl0QnVmZmVyZWQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzOwogICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmVtaXRFdmVudChlKTsKICAgICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQucGFja2V0KGUpOwogICAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAgICh0aGlzLnNlbmRCdWZmZXIgPSBbXSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25kaXNjb25uZWN0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpLCB0aGlzLm9uY2xvc2UoImlvIHNlcnZlciBkaXNjb25uZWN0Iik7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZGVzdHJveSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB0aGlzLnN1YnMgJiYKICAgICAgICAgICAgICAgICAgICAodGhpcy5zdWJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0KCk7CiAgICAgICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3VicyA9IHZvaWQgMCkpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuaW8uX2Rlc3Ryb3kodGhpcyk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZGlzY29ubmVjdCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkICYmCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHAuUGFja2V0VHlwZS5ESVNDT05ORUNUIH0pLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkICYmIHRoaXMub25jbG9zZSgiaW8gY2xpZW50IGRpc2Nvbm5lY3QiKSwKICAgICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiY2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdCgpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImNvbXByZXNzIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MuY29tcHJlc3MgPSB0KSwgdGhpczsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJ2b2xhdGlsZSIsCiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzLnZvbGF0aWxlID0gITApLCB0aGlzOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uQW55IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgICh0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW10pLAogICAgICAgICAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKHQpLAogICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJwcmVwZW5kQW55IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgICh0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW10pLAogICAgICAgICAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy51bnNoaWZ0KHQpLAogICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvZmZBbnkiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW55TGlzdGVuZXJzKSByZXR1cm4gdGhpczsKICAgICAgICAgICAgICAgICAgaWYgKHQpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5fYW55TGlzdGVuZXJzLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspCiAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gZVtuXSkgcmV0dXJuIGUuc3BsaWNlKG4sIDEpLCB0aGlzOwogICAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fYW55TGlzdGVuZXJzID0gW107CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImxpc3RlbmVyc0FueSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICBdKSAmJiBzKGUucHJvdG90eXBlLCBuKSwKICAgICAgICAgICAgciAmJiBzKGUsIHIpLAogICAgICAgICAgICBmCiAgICAgICAgICApOwogICAgICAgIH0pKHkuU3RyaWN0RXZlbnRFbWl0dGVyKTsKICAgICAgZS5Tb2NrZXQgPSB2OwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIodCkgewogICAgICAgIHJldHVybiAociA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6ICEwIH0pLAogICAgICAgIChlLmhhc0JpbmFyeSA9IGUuaXNCaW5hcnkgPSB2b2lkIDApOwogICAgICB2YXIgbyA9ICJmdW5jdGlvbiIgPT0gdHlwZW9mIEFycmF5QnVmZmVyLAogICAgICAgIGkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLAogICAgICAgIHMgPQogICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgQmxvYiB8fAogICAgICAgICAgKCJ1bmRlZmluZWQiICE9IHR5cGVvZiBCbG9iICYmCiAgICAgICAgICAgICJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0iID09PSBpLmNhbGwoQmxvYikpLAogICAgICAgIGMgPQogICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgRmlsZSB8fAogICAgICAgICAgKCJ1bmRlZmluZWQiICE9IHR5cGVvZiBGaWxlICYmCiAgICAgICAgICAgICJbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0iID09PSBpLmNhbGwoRmlsZSkpOwogICAgICBmdW5jdGlvbiBhKHQpIHsKICAgICAgICByZXR1cm4gKAogICAgICAgICAgKG8gJiYKICAgICAgICAgICAgKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fAogICAgICAgICAgICAgIChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgcmV0dXJuICJmdW5jdGlvbiIgPT0gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldwogICAgICAgICAgICAgICAgICA/IEFycmF5QnVmZmVyLmlzVmlldyh0KQogICAgICAgICAgICAgICAgICA6IHQuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7CiAgICAgICAgICAgICAgfSkodCkpKSB8fAogICAgICAgICAgKHMgJiYgdCBpbnN0YW5jZW9mIEJsb2IpIHx8CiAgICAgICAgICAoYyAmJiB0IGluc3RhbmNlb2YgRmlsZSkKICAgICAgICApOwogICAgICB9CiAgICAgIChlLmlzQmluYXJ5ID0gYSksCiAgICAgICAgKGUuaGFzQmluYXJ5ID0gZnVuY3Rpb24gdChlLCBuKSB7CiAgICAgICAgICBpZiAoIWUgfHwgIm9iamVjdCIgIT09IHIoZSkpIHJldHVybiAhMTsKICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7CiAgICAgICAgICAgIGZvciAodmFyIG8gPSAwLCBpID0gZS5sZW5ndGg7IG8gPCBpOyBvKyspIGlmICh0KGVbb10pKSByZXR1cm4gITA7CiAgICAgICAgICAgIHJldHVybiAhMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhKGUpKSByZXR1cm4gITA7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgIGUudG9KU09OICYmCiAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIGUudG9KU09OICYmCiAgICAgICAgICAgIDEgPT09IGFyZ3VtZW50cy5sZW5ndGgKICAgICAgICAgICkKICAgICAgICAgICAgcmV0dXJuIHQoZS50b0pTT04oKSwgITApOwogICAgICAgICAgZm9yICh2YXIgcyBpbiBlKQogICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHMpICYmIHQoZVtzXSkpCiAgICAgICAgICAgICAgcmV0dXJuICEwOwogICAgICAgICAgcmV0dXJuICExOwogICAgICAgIH0pOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6ICEwIH0pLAogICAgICAgIChlLm9uID0gdm9pZCAwKSwKICAgICAgICAoZS5vbiA9IGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICB0Lm9uKGUsIG4pLAogICAgICAgICAgICBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdC5vZmYoZSwgbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICk7CiAgICAgICAgfSk7CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgZnVuY3Rpb24gcih0KSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJiAic3ltYm9sIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yCiAgICAgICAgICAgID8gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0ICYmCiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdCAhPT0gU3ltYm9sLnByb3RvdHlwZQogICAgICAgICAgICAgICAgICA/ICJzeW1ib2wiCiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbyh0LCBlKSB7CiAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaSh0LCBlKSB7CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7CiAgICAgICAgICB2YXIgciA9IGVbbl07CiAgICAgICAgICAoci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExKSwKICAgICAgICAgICAgKHIuY29uZmlndXJhYmxlID0gITApLAogICAgICAgICAgICAidmFsdWUiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksCiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCByLmtleSwgcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHModCwgZSwgbikgewogICAgICAgIHJldHVybiAocyA9CiAgICAgICAgICAidW5kZWZpbmVkIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldAogICAgICAgICAgICA/IFJlZmxlY3QuZ2V0CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgZSkgJiYKICAgICAgICAgICAgICAgICAgICBudWxsICE9PSAodCA9IGYodCkpOwoKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgICAgICAgICB9KSh0LCBlKTsKICAgICAgICAgICAgICAgIGlmIChyKSB7CiAgICAgICAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLCBlKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uZ2V0ID8gby5nZXQuY2FsbChuKSA6IG8udmFsdWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSkodCwgZSwgbiB8fCB0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjKHQsIGUpIHsKICAgICAgICByZXR1cm4gKGMgPQogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CiAgICAgICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICByZXR1cm4gKHQuX19wcm90b19fID0gZSksIHQ7CiAgICAgICAgICB9KSh0LCBlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhKHQpIHsKICAgICAgICB2YXIgZSA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoInVuZGVmaW5lZCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExOwogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCgKICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkKICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICEwCiAgICAgICAgICAgICk7CiAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgIHJldHVybiAhMTsKICAgICAgICAgIH0KICAgICAgICB9KSgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgciA9IGYodCk7CiAgICAgICAgICBpZiAoZSkgewogICAgICAgICAgICB2YXIgbyA9IGYodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChyLCBhcmd1bWVudHMsIG8pOwogICAgICAgICAgfSBlbHNlIG4gPSByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICByZXR1cm4gdSh0aGlzLCBuKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHUodCwgZSkgewogICAgICAgIGlmIChlICYmICgib2JqZWN0IiA9PT0gcihlKSB8fCAiZnVuY3Rpb24iID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7CiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodCkgewogICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkKICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKAogICAgICAgICAgICAgICJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiCiAgICAgICAgICAgICk7CiAgICAgICAgICByZXR1cm4gdDsKICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmKHQpIHsKICAgICAgICByZXR1cm4gKGYgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YKICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mCiAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsKICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogITAgfSksCiAgICAgICAgKGUuU3RyaWN0RXZlbnRFbWl0dGVyID0gdm9pZCAwKTsKICAgICAgdmFyIGwgPSAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAhKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAgICJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIKICAgICAgICAgICAgKTsKICAgICAgICAgICh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgewogICAgICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sCiAgICAgICAgICB9KSksCiAgICAgICAgICAgIGUgJiYgYyh0LCBlKTsKICAgICAgICB9KShsLCB0KTsKICAgICAgICB2YXIgZSwKICAgICAgICAgIG4sCiAgICAgICAgICByLAogICAgICAgICAgdSA9IGEobCk7CiAgICAgICAgZnVuY3Rpb24gbCgpIHsKICAgICAgICAgIHJldHVybiBvKHRoaXMsIGwpLCB1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoCiAgICAgICAgICAoZSA9IGwpLAogICAgICAgICAgKG4gPSBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICBrZXk6ICJvbiIsCiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcyhmKGwucHJvdG90eXBlKSwgIm9uIiwgdGhpcykuY2FsbCh0aGlzLCB0LCBlKSwgdGhpczsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAga2V5OiAib25jZSIsCiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcyhmKGwucHJvdG90eXBlKSwgIm9uY2UiLCB0aGlzKS5jYWxsKHRoaXMsIHQsIGUpLCB0aGlzOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICBrZXk6ICJlbWl0IiwKICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICAgIHZhciBlLAogICAgICAgICAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLAogICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobiA+IDEgPyBuIC0gMSA6IDApLAogICAgICAgICAgICAgICAgICAgIG8gPSAxOwogICAgICAgICAgICAgICAgICBvIDwgbjsKICAgICAgICAgICAgICAgICAgbysrCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgIHJbbyAtIDFdID0gYXJndW1lbnRzW29dOwogICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgKGUgPSBzKGYobC5wcm90b3R5cGUpLCAiZW1pdCIsIHRoaXMpKS5jYWxsLmFwcGx5KAogICAgICAgICAgICAgICAgICAgIGUsCiAgICAgICAgICAgICAgICAgICAgW3RoaXMsIHRdLmNvbmNhdChyKQogICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgICB0aGlzCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICBrZXk6ICJlbWl0UmVzZXJ2ZWQiLAogICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgdmFyIGUsCiAgICAgICAgICAgICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGgsCiAgICAgICAgICAgICAgICAgICAgciA9IG5ldyBBcnJheShuID4gMSA/IG4gLSAxIDogMCksCiAgICAgICAgICAgICAgICAgICAgbyA9IDE7CiAgICAgICAgICAgICAgICAgIG8gPCBuOwogICAgICAgICAgICAgICAgICBvKysKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgcltvIC0gMV0gPSBhcmd1bWVudHNbb107CiAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAoZSA9IHMoZihsLnByb3RvdHlwZSksICJlbWl0IiwgdGhpcykpLmNhbGwuYXBwbHkoCiAgICAgICAgICAgICAgICAgICAgZSwKICAgICAgICAgICAgICAgICAgICBbdGhpcywgdF0uY29uY2F0KHIpCiAgICAgICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgIGtleTogImxpc3RlbmVycyIsCiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcyhmKGwucHJvdG90eXBlKSwgImxpc3RlbmVycyIsIHRoaXMpLmNhbGwodGhpcywgdCk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgIF0pICYmIGkoZS5wcm90b3R5cGUsIG4pLAogICAgICAgICAgciAmJiBpKGUsIHIpLAogICAgICAgICAgbAogICAgICAgICk7CiAgICAgIH0pKG4oMikpOwogICAgICBlLlN0cmljdEV2ZW50RW1pdHRlciA9IGw7CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgZnVuY3Rpb24gcih0KSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJiAic3ltYm9sIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yCiAgICAgICAgICAgID8gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0ICYmCiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdCAhPT0gU3ltYm9sLnByb3RvdHlwZQogICAgICAgICAgICAgICAgICA/ICJzeW1ib2wiCiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogITAgfSksCiAgICAgICAgKGUuaW8gPSBlLlNvY2tldCA9IGUuTWFuYWdlciA9IGUucHJvdG9jb2wgPSB2b2lkIDApOwogICAgICB2YXIgbyA9IG4oMTkpLAogICAgICAgIGkgPSBuKDgpOwogICAgICB0LmV4cG9ydHMgPSBlID0gYzsKICAgICAgdmFyIHMgPSAoZS5tYW5hZ2VycyA9IHt9KTsKICAgICAgZnVuY3Rpb24gYyh0LCBlKSB7CiAgICAgICAgIm9iamVjdCIgPT09IHIodCkgJiYgKChlID0gdCksICh0ID0gdm9pZCAwKSksIChlID0gZSB8fCB7fSk7CiAgICAgICAgdmFyIG4sCiAgICAgICAgICBjID0gKDAsIG8udXJsKSh0LCBlLnBhdGggfHwgIi9zb2NrZXQuaW8iKSwKICAgICAgICAgIGEgPSBjLnNvdXJjZSwKICAgICAgICAgIHUgPSBjLmlkLAogICAgICAgICAgZiA9IGMucGF0aCwKICAgICAgICAgIGwgPSBzW3VdICYmIGYgaW4gc1t1XS5uc3BzOwogICAgICAgIHJldHVybiAoCiAgICAgICAgICBlLmZvcmNlTmV3IHx8IGVbImZvcmNlIG5ldyBjb25uZWN0aW9uIl0gfHwgITEgPT09IGUubXVsdGlwbGV4IHx8IGwKICAgICAgICAgICAgPyAobiA9IG5ldyBpLk1hbmFnZXIoYSwgZSkpCiAgICAgICAgICAgIDogKHNbdV0gfHwgKHNbdV0gPSBuZXcgaS5NYW5hZ2VyKGEsIGUpKSwgKG4gPSBzW3VdKSksCiAgICAgICAgICBjLnF1ZXJ5ICYmICFlLnF1ZXJ5ICYmIChlLnF1ZXJ5ID0gYy5xdWVyeUtleSksCiAgICAgICAgICBuLnNvY2tldChjLnBhdGgsIGUpCiAgICAgICAgKTsKICAgICAgfQogICAgICBlLmlvID0gYzsKICAgICAgdmFyIGEgPSBuKDYpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgInByb3RvY29sIiwgewogICAgICAgIGVudW1lcmFibGU6ICEwLAogICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGEucHJvdG9jb2w7CiAgICAgICAgfSwKICAgICAgfSksCiAgICAgICAgKGUuY29ubmVjdCA9IGMpOwogICAgICB2YXIgdSA9IG4oOCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAiTWFuYWdlciIsIHsKICAgICAgICBlbnVtZXJhYmxlOiAhMCwKICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiB1Lk1hbmFnZXI7CiAgICAgICAgfSwKICAgICAgfSk7CiAgICAgIHZhciBmID0gbigxNCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAiU29ja2V0IiwgewogICAgICAgIGVudW1lcmFibGU6ICEwLAogICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGYuU29ja2V0OwogICAgICAgIH0sCiAgICAgIH0pLAogICAgICAgIChlLmRlZmF1bHQgPSBjKTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiAhMCB9KSwgKGUudXJsID0gdm9pZCAwKTsKICAgICAgdmFyIHIgPSBuKDcpOwogICAgICBlLnVybCA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgdmFyIGUgPQogICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6ICIiLAogICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwLAogICAgICAgICAgbyA9IHQ7CiAgICAgICAgKG4gPSBuIHx8ICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgbG9jYXRpb24gJiYgbG9jYXRpb24pKSwKICAgICAgICAgIG51bGwgPT0gdCAmJiAodCA9IG4ucHJvdG9jb2wgKyAiLy8iICsgbi5ob3N0KSwKICAgICAgICAgICJzdHJpbmciID09IHR5cGVvZiB0ICYmCiAgICAgICAgICAgICgiLyIgPT09IHQuY2hhckF0KDApICYmCiAgICAgICAgICAgICAgKHQgPSAiLyIgPT09IHQuY2hhckF0KDEpID8gbi5wcm90b2NvbCArIHQgOiBuLmhvc3QgKyB0KSwKICAgICAgICAgICAgL14oaHR0cHM/fHdzcz8pOlwvXC8vLnRlc3QodCkgfHwKICAgICAgICAgICAgICAodCA9IHZvaWQgMCAhPT0gbiA/IG4ucHJvdG9jb2wgKyAiLy8iICsgdCA6ICJodHRwczovLyIgKyB0KSwKICAgICAgICAgICAgKG8gPSByKHQpKSksCiAgICAgICAgICBvLnBvcnQgfHwKICAgICAgICAgICAgKC9eKGh0dHB8d3MpJC8udGVzdChvLnByb3RvY29sKQogICAgICAgICAgICAgID8gKG8ucG9ydCA9ICI4MCIpCiAgICAgICAgICAgICAgOiAvXihodHRwfHdzKXMkLy50ZXN0KG8ucHJvdG9jb2wpICYmIChvLnBvcnQgPSAiNDQzIikpLAogICAgICAgICAgKG8ucGF0aCA9IG8ucGF0aCB8fCAiLyIpOwogICAgICAgIHZhciBpID0gLTEgIT09IG8uaG9zdC5pbmRleE9mKCI6IiksCiAgICAgICAgICBzID0gaSA/ICJbIiArIG8uaG9zdCArICJdIiA6IG8uaG9zdDsKICAgICAgICByZXR1cm4gKAogICAgICAgICAgKG8uaWQgPSBvLnByb3RvY29sICsgIjovLyIgKyBzICsgIjoiICsgby5wb3J0ICsgZSksCiAgICAgICAgICAoby5ocmVmID0KICAgICAgICAgICAgby5wcm90b2NvbCArCiAgICAgICAgICAgICI6Ly8iICsKICAgICAgICAgICAgcyArCiAgICAgICAgICAgIChuICYmIG4ucG9ydCA9PT0gby5wb3J0ID8gIiIgOiAiOiIgKyBvLnBvcnQpKSwKICAgICAgICAgIG8KICAgICAgICApOwogICAgICB9OwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIHZhciByID0gbigyMSk7CiAgICAgICh0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgIHJldHVybiBuZXcgcih0LCBlKTsKICAgICAgfSksCiAgICAgICAgKHQuZXhwb3J0cy5Tb2NrZXQgPSByKSwKICAgICAgICAodC5leHBvcnRzLnByb3RvY29sID0gci5wcm90b2NvbCksCiAgICAgICAgKHQuZXhwb3J0cy5UcmFuc3BvcnQgPSBuKDQpKSwKICAgICAgICAodC5leHBvcnRzLnRyYW5zcG9ydHMgPSBuKDkpKSwKICAgICAgICAodC5leHBvcnRzLnBhcnNlciA9IG4oMSkpOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIoKSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgIE9iamVjdC5hc3NpZ24gfHwKICAgICAgICAgIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7CiAgICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHNbZV07CiAgICAgICAgICAgICAgZm9yICh2YXIgciBpbiBuKQogICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmICh0W3JdID0gbltyXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG8odCkgewogICAgICAgIHJldHVybiAobyA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGkodCwgZSkgewogICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBlKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHModCwgZSkgewogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgewogICAgICAgICAgdmFyIHIgPSBlW25dOwogICAgICAgICAgKHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSksCiAgICAgICAgICAgIChyLmNvbmZpZ3VyYWJsZSA9ICEwKSwKICAgICAgICAgICAgInZhbHVlIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLAogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgci5rZXksIHIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjKHQsIGUpIHsKICAgICAgICByZXR1cm4gKGMgPQogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CiAgICAgICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICByZXR1cm4gKHQuX19wcm90b19fID0gZSksIHQ7CiAgICAgICAgICB9KSh0LCBlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhKHQpIHsKICAgICAgICB2YXIgZSA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoInVuZGVmaW5lZCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExOwogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCgKICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkKICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICEwCiAgICAgICAgICAgICk7CiAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgIHJldHVybiAhMTsKICAgICAgICAgIH0KICAgICAgICB9KSgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgciA9IGwodCk7CiAgICAgICAgICBpZiAoZSkgewogICAgICAgICAgICB2YXIgbyA9IGwodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChyLCBhcmd1bWVudHMsIG8pOwogICAgICAgICAgfSBlbHNlIG4gPSByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICByZXR1cm4gdSh0aGlzLCBuKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHUodCwgZSkgewogICAgICAgIGlmIChlICYmICgib2JqZWN0IiA9PT0gbyhlKSB8fCAiZnVuY3Rpb24iID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7CiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIGYodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZih0KSB7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigKICAgICAgICAgICAgInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbCh0KSB7CiAgICAgICAgcmV0dXJuIChsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mCiAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZgogICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7CiAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIHZhciBwID0gbig5KSwKICAgICAgICBoID0gbigyKSwKICAgICAgICB5ID0gbigxKSwKICAgICAgICBkID0gbig3KSwKICAgICAgICB2ID0gbig1KSwKICAgICAgICBiID0gbigzKS5pbnN0YWxsVGltZXJGdW5jdGlvbnMsCiAgICAgICAgbSA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgIShmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgKHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgZSAmJiBjKHQsIGUpOwogICAgICAgICAgfSkoaCwgdCk7CiAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgbiwKICAgICAgICAgICAgdSwKICAgICAgICAgICAgbCA9IGEoaCk7CiAgICAgICAgICBmdW5jdGlvbiBoKHQpIHsKICAgICAgICAgICAgdmFyIGUsCiAgICAgICAgICAgICAgbiA9CiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXQogICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50c1sxXQogICAgICAgICAgICAgICAgICA6IHt9OwogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIGkodGhpcywgaCksCiAgICAgICAgICAgICAgKGUgPSBsLmNhbGwodGhpcykpLAogICAgICAgICAgICAgIHQgJiYgIm9iamVjdCIgPT09IG8odCkgJiYgKChuID0gdCksICh0ID0gbnVsbCkpLAogICAgICAgICAgICAgIHQKICAgICAgICAgICAgICAgID8gKCh0ID0gZCh0KSksCiAgICAgICAgICAgICAgICAgIChuLmhvc3RuYW1lID0gdC5ob3N0KSwKICAgICAgICAgICAgICAgICAgKG4uc2VjdXJlID0gImh0dHBzIiA9PT0gdC5wcm90b2NvbCB8fCAid3NzIiA9PT0gdC5wcm90b2NvbCksCiAgICAgICAgICAgICAgICAgIChuLnBvcnQgPSB0LnBvcnQpLAogICAgICAgICAgICAgICAgICB0LnF1ZXJ5ICYmIChuLnF1ZXJ5ID0gdC5xdWVyeSkpCiAgICAgICAgICAgICAgICA6IG4uaG9zdCAmJiAobi5ob3N0bmFtZSA9IGQobi5ob3N0KS5ob3N0KSwKICAgICAgICAgICAgICBiKGYoZSksIG4pLAogICAgICAgICAgICAgIChlLnNlY3VyZSA9CiAgICAgICAgICAgICAgICBudWxsICE9IG4uc2VjdXJlCiAgICAgICAgICAgICAgICAgID8gbi5zZWN1cmUKICAgICAgICAgICAgICAgICAgOiAidW5kZWZpbmVkIiAhPSB0eXBlb2YgbG9jYXRpb24gJiYKICAgICAgICAgICAgICAgICAgICAiaHR0cHM6IiA9PT0gbG9jYXRpb24ucHJvdG9jb2wpLAogICAgICAgICAgICAgIG4uaG9zdG5hbWUgJiYgIW4ucG9ydCAmJiAobi5wb3J0ID0gZS5zZWN1cmUgPyAiNDQzIiA6ICI4MCIpLAogICAgICAgICAgICAgIChlLmhvc3RuYW1lID0KICAgICAgICAgICAgICAgIG4uaG9zdG5hbWUgfHwKICAgICAgICAgICAgICAgICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgbG9jYXRpb24KICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5ob3N0bmFtZQogICAgICAgICAgICAgICAgICA6ICJsb2NhbGhvc3QiKSksCiAgICAgICAgICAgICAgKGUucG9ydCA9CiAgICAgICAgICAgICAgICBuLnBvcnQgfHwKICAgICAgICAgICAgICAgICgidW5kZWZpbmVkIiAhPSB0eXBlb2YgbG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydAogICAgICAgICAgICAgICAgICA/IGxvY2F0aW9uLnBvcnQKICAgICAgICAgICAgICAgICAgOiBlLnNlY3VyZQogICAgICAgICAgICAgICAgICA/IDQ0MwogICAgICAgICAgICAgICAgICA6IDgwKSksCiAgICAgICAgICAgICAgKGUudHJhbnNwb3J0cyA9IG4udHJhbnNwb3J0cyB8fCBbInBvbGxpbmciLCAid2Vic29ja2V0Il0pLAogICAgICAgICAgICAgIChlLnJlYWR5U3RhdGUgPSAiIiksCiAgICAgICAgICAgICAgKGUud3JpdGVCdWZmZXIgPSBbXSksCiAgICAgICAgICAgICAgKGUucHJldkJ1ZmZlckxlbiA9IDApLAogICAgICAgICAgICAgIChlLm9wdHMgPSByKAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBwYXRoOiAiL2VuZ2luZS5pbyIsCiAgICAgICAgICAgICAgICAgIGFnZW50OiAhMSwKICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiAhMSwKICAgICAgICAgICAgICAgICAgdXBncmFkZTogITAsCiAgICAgICAgICAgICAgICAgIGpzb25wOiAhMCwKICAgICAgICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06ICJ0IiwKICAgICAgICAgICAgICAgICAgcmVtZW1iZXJVcGdyYWRlOiAhMSwKICAgICAgICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiAhMCwKICAgICAgICAgICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IHsgdGhyZXNob2xkOiAxMDI0IH0sCiAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnM6IHt9LAogICAgICAgICAgICAgICAgICBjbG9zZU9uQmVmb3JldW5sb2FkOiAhMCwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBuCiAgICAgICAgICAgICAgKSksCiAgICAgICAgICAgICAgKGUub3B0cy5wYXRoID0gZS5vcHRzLnBhdGgucmVwbGFjZSgvXC8kLywgIiIpICsgIi8iKSwKICAgICAgICAgICAgICAic3RyaW5nIiA9PSB0eXBlb2YgZS5vcHRzLnF1ZXJ5ICYmCiAgICAgICAgICAgICAgICAoZS5vcHRzLnF1ZXJ5ID0gdi5kZWNvZGUoZS5vcHRzLnF1ZXJ5KSksCiAgICAgICAgICAgICAgKGUuaWQgPSBudWxsKSwKICAgICAgICAgICAgICAoZS51cGdyYWRlcyA9IG51bGwpLAogICAgICAgICAgICAgIChlLnBpbmdJbnRlcnZhbCA9IG51bGwpLAogICAgICAgICAgICAgIChlLnBpbmdUaW1lb3V0ID0gbnVsbCksCiAgICAgICAgICAgICAgKGUucGluZ1RpbWVvdXRUaW1lciA9IG51bGwpLAogICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgJiYKICAgICAgICAgICAgICAgIChlLm9wdHMuY2xvc2VPbkJlZm9yZXVubG9hZCAmJgogICAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKAogICAgICAgICAgICAgICAgICAgICJiZWZvcmV1bmxvYWQiLAogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgIGUudHJhbnNwb3J0ICYmCiAgICAgICAgICAgICAgICAgICAgICAgIChlLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKSwgZS50cmFuc3BvcnQuY2xvc2UoKSk7CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAhMQogICAgICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICAgImxvY2FsaG9zdCIgIT09IGUuaG9zdG5hbWUgJiYKICAgICAgICAgICAgICAgICAgKChlLm9mZmxpbmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgIGUub25DbG9zZSgidHJhbnNwb3J0IGNsb3NlIik7CiAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCJvZmZsaW5lIiwgZS5vZmZsaW5lRXZlbnRMaXN0ZW5lciwgITEpKSksCiAgICAgICAgICAgICAgZS5vcGVuKCksCiAgICAgICAgICAgICAgZQogICAgICAgICAgICApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgKGUgPSBoKSwKICAgICAgICAgICAgKG4gPSBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiY3JlYXRlVHJhbnNwb3J0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAgIHZhciBlID0ge307CiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiB0KSB0Lmhhc093blByb3BlcnR5KG4pICYmIChlW25dID0gdFtuXSk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7CiAgICAgICAgICAgICAgICAgIH0pKHRoaXMub3B0cy5xdWVyeSk7CiAgICAgICAgICAgICAgICAgIChlLkVJTyA9IHkucHJvdG9jb2wpLAogICAgICAgICAgICAgICAgICAgIChlLnRyYW5zcG9ydCA9IHQpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgJiYgKGUuc2lkID0gdGhpcy5pZCk7CiAgICAgICAgICAgICAgICAgIHZhciBuID0gcih7fSwgdGhpcy5vcHRzLnRyYW5zcG9ydE9wdGlvbnNbdF0sIHRoaXMub3B0cywgewogICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBlLAogICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGhpcywKICAgICAgICAgICAgICAgICAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSwKICAgICAgICAgICAgICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLAogICAgICAgICAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCwKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcFt0XShuKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvcGVuIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0LAogICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzOwogICAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnJlbWVtYmVyVXBncmFkZSAmJgogICAgICAgICAgICAgICAgICAgIGgucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmCiAgICAgICAgICAgICAgICAgICAgLTEgIT09IHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCJ3ZWJzb2NrZXQiKQogICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgdCA9ICJ3ZWJzb2NrZXQiOwogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIHRoaXMuc2V0VGltZW91dEZuKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZS5lbWl0KCJlcnJvciIsICJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZSIpOwogICAgICAgICAgICAgICAgICAgICAgfSwgMCk7CiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMudHJhbnNwb3J0c1swXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAib3BlbmluZyI7CiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHQpOwogICAgICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpLCB2b2lkIHRoaXMub3BlbigpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHQub3BlbigpLCB0aGlzLnNldFRyYW5zcG9ydCh0KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJzZXRUcmFuc3BvcnQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpczsKICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgJiYgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHJhbnNwb3J0ID0gdCksCiAgICAgICAgICAgICAgICAgICAgdAogICAgICAgICAgICAgICAgICAgICAgLm9uKCJkcmFpbiIsIHRoaXMub25EcmFpbi5iaW5kKHRoaXMpKQogICAgICAgICAgICAgICAgICAgICAgLm9uKCJwYWNrZXQiLCB0aGlzLm9uUGFja2V0LmJpbmQodGhpcykpCiAgICAgICAgICAgICAgICAgICAgICAub24oImVycm9yIiwgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpCiAgICAgICAgICAgICAgICAgICAgICAub24oImNsb3NlIiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICBlLm9uQ2xvc2UoInRyYW5zcG9ydCBjbG9zZSIpOwogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAicHJvYmUiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcywKICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodCwgeyBwcm9iZTogMSB9KSwKICAgICAgICAgICAgICAgICAgICByID0gITE7CiAgICAgICAgICAgICAgICAgIGgucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gITE7CiAgICAgICAgICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgIHIgfHwKICAgICAgICAgICAgICAgICAgICAgIChuLnNlbmQoW3sgdHlwZTogInBpbmciLCBkYXRhOiAicHJvYmUiIH1dKSwKICAgICAgICAgICAgICAgICAgICAgIG4ub25jZSgicGFja2V0IiwgZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyKQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgicG9uZyIgPT09IHQudHlwZSAmJiAicHJvYmUiID09PSB0LmRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChlLnVwZ3JhZGluZyA9ICEwKSwgZS5lbWl0KCJ1cGdyYWRpbmciLCBuKSwgIW4pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIChoLnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICJ3ZWJzb2NrZXQiID09PSBuLm5hbWUpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciB8fAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCJjbG9zZWQiICE9PSBlLnJlYWR5U3RhdGUgJiYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRUcmFuc3BvcnQobiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uc2VuZChbeyB0eXBlOiAidXBncmFkZSIgfV0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVtaXQoInVwZ3JhZGUiLCBuKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG4gPSBudWxsKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUudXBncmFkaW5nID0gITEpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmZsdXNoKCkpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gbmV3IEVycm9yKCJwcm9iZSBlcnJvciIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgKG8udHJhbnNwb3J0ID0gbi5uYW1lKSwgZS5lbWl0KCJ1cGdyYWRlRXJyb3IiLCBvKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoKSB7CiAgICAgICAgICAgICAgICAgICAgciB8fCAoKHIgPSAhMCksIGYoKSwgbi5jbG9zZSgpLCAobiA9IG51bGwpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgcyA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgRXJyb3IoInByb2JlIGVycm9yOiAiICsgdCk7CiAgICAgICAgICAgICAgICAgICAgKHIudHJhbnNwb3J0ID0gbi5uYW1lKSwgaSgpLCBlLmVtaXQoInVwZ3JhZGVFcnJvciIsIHIpOwogICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKCkgewogICAgICAgICAgICAgICAgICAgIHMoInRyYW5zcG9ydCBjbG9zZWQiKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKCkgewogICAgICAgICAgICAgICAgICAgIHMoInNvY2tldCBjbG9zZWQiKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KHQpIHsKICAgICAgICAgICAgICAgICAgICBuICYmIHQubmFtZSAhPT0gbi5uYW1lICYmIGkoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICBuLnJlbW92ZUxpc3RlbmVyKCJvcGVuIiwgbyksCiAgICAgICAgICAgICAgICAgICAgICBuLnJlbW92ZUxpc3RlbmVyKCJlcnJvciIsIHMpLAogICAgICAgICAgICAgICAgICAgICAgbi5yZW1vdmVMaXN0ZW5lcigiY2xvc2UiLCBjKSwKICAgICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlTGlzdGVuZXIoImNsb3NlIiwgYSksCiAgICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUxpc3RlbmVyKCJ1cGdyYWRpbmciLCB1KTsKICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgbi5vbmNlKCJvcGVuIiwgbyksCiAgICAgICAgICAgICAgICAgICAgbi5vbmNlKCJlcnJvciIsIHMpLAogICAgICAgICAgICAgICAgICAgIG4ub25jZSgiY2xvc2UiLCBjKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoImNsb3NlIiwgYSksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKCJ1cGdyYWRpbmciLCB1KSwKICAgICAgICAgICAgICAgICAgICBuLm9wZW4oKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbk9wZW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgICAgICgodGhpcy5yZWFkeVN0YXRlID0gIm9wZW4iKSwKICAgICAgICAgICAgICAgICAgICAoaC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPQogICAgICAgICAgICAgICAgICAgICAgIndlYnNvY2tldCIgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWUpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgib3BlbiIpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKSwKICAgICAgICAgICAgICAgICAgICAib3BlbiIgPT09IHRoaXMucmVhZHlTdGF0ZSAmJgogICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnVwZ3JhZGUgJiYKICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnBhdXNlKQogICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgdCA8IGU7IHQrKykKICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1t0XSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25QYWNrZXQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICAgICAib3BlbmluZyIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fAogICAgICAgICAgICAgICAgICAgICJvcGVuIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8CiAgICAgICAgICAgICAgICAgICAgImNsb3NpbmciID09PSB0aGlzLnJlYWR5U3RhdGUKICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5lbWl0KCJwYWNrZXQiLCB0KSwgdGhpcy5lbWl0KCJoZWFydGJlYXQiKSwgdC50eXBlKQogICAgICAgICAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgICAgICAgY2FzZSAib3BlbiI6CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZSh0LmRhdGEpKTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICBjYXNlICJwaW5nIjoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCksCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KCJwb25nIiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJwaW5nIiksCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJwb25nIik7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgY2FzZSAiZXJyb3IiOgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcigic2VydmVyIGVycm9yIik7CiAgICAgICAgICAgICAgICAgICAgICAgIChlLmNvZGUgPSB0LmRhdGEpLCB0aGlzLm9uRXJyb3IoZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgY2FzZSAibWVzc2FnZSI6CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgiZGF0YSIsIHQuZGF0YSksIHRoaXMuZW1pdCgibWVzc2FnZSIsIHQuZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uSGFuZHNoYWtlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoImhhbmRzaGFrZSIsIHQpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLmlkID0gdC5zaWQpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSB0LnNpZCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKHQudXBncmFkZXMpKSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5waW5nSW50ZXJ2YWwgPSB0LnBpbmdJbnRlcnZhbCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMucGluZ1RpbWVvdXQgPSB0LnBpbmdUaW1lb3V0KSwKICAgICAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbigpLAogICAgICAgICAgICAgICAgICAgICJjbG9zZWQiICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAicmVzZXRQaW5nVGltZW91dCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7CiAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGhpcy5waW5nVGltZW91dFRpbWVyKSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5waW5nVGltZW91dFRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgdC5vbkNsb3NlKCJwaW5nIHRpbWVvdXQiKTsKICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCArIHRoaXMucGluZ1RpbWVvdXQpKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuYXV0b1VucmVmICYmIHRoaXMucGluZ1RpbWVvdXRUaW1lci51bnJlZigpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uRHJhaW4iLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5wcmV2QnVmZmVyTGVuID0gMCksCiAgICAgICAgICAgICAgICAgICAgMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5lbWl0KCJkcmFpbiIpCiAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZmx1c2goKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJmbHVzaCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAiY2xvc2VkIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmCiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiYKICAgICAgICAgICAgICAgICAgICAhdGhpcy51cGdyYWRpbmcgJiYKICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCAmJgogICAgICAgICAgICAgICAgICAgICh0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJmbHVzaCIpKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJ3cml0ZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFBhY2tldCgibWVzc2FnZSIsIHQsIGUsIG4pLCB0aGlzOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInNlbmQiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRQYWNrZXQoIm1lc3NhZ2UiLCB0LCBlLCBuKSwgdGhpczsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJzZW5kUGFja2V0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSwgbiwgcikgewogICAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICAgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIGUgJiYgKChyID0gZSksIChlID0gdm9pZCAwKSksCiAgICAgICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgbiAmJiAoKHIgPSBuKSwgKG4gPSBudWxsKSksCiAgICAgICAgICAgICAgICAgICAgImNsb3NpbmciICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYKICAgICAgICAgICAgICAgICAgICAgICJjbG9zZWQiICE9PSB0aGlzLnJlYWR5U3RhdGUpCiAgICAgICAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgICAgIChuID0gbiB8fCB7fSkuY29tcHJlc3MgPSAhMSAhPT0gbi5jb21wcmVzczsKICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHsgdHlwZTogdCwgZGF0YTogZSwgb3B0aW9uczogbiB9OwogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgicGFja2V0Q3JlYXRlIiwgbyksCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnB1c2gobyksCiAgICAgICAgICAgICAgICAgICAgICByICYmIHRoaXMub25jZSgiZmx1c2giLCByKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImNsb3NlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcywKICAgICAgICAgICAgICAgICAgICBlID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgdC5vbkNsb3NlKCJmb3JjZWQgY2xvc2UiKSwgdC50cmFuc3BvcnQuY2xvc2UoKTsKICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIG4gPSBmdW5jdGlvbiBuKCkgewogICAgICAgICAgICAgICAgICAgICAgdC5yZW1vdmVMaXN0ZW5lcigidXBncmFkZSIsIG4pLAogICAgICAgICAgICAgICAgICAgICAgICB0LnJlbW92ZUxpc3RlbmVyKCJ1cGdyYWRlRXJyb3IiLCBuKSwKICAgICAgICAgICAgICAgICAgICAgICAgZSgpOwogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgciA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgIHQub25jZSgidXBncmFkZSIsIG4pLCB0Lm9uY2UoInVwZ3JhZGVFcnJvciIsIG4pOwogICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgKCJvcGVuaW5nIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmCiAgICAgICAgICAgICAgICAgICAgICAib3BlbiIgIT09IHRoaXMucmVhZHlTdGF0ZSkgfHwKICAgICAgICAgICAgICAgICAgICAgICgodGhpcy5yZWFkeVN0YXRlID0gImNsb3NpbmciKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vbmNlKCJkcmFpbiIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudXBncmFkaW5nID8gcigpIDogZSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy51cGdyYWRpbmcKICAgICAgICAgICAgICAgICAgICAgICAgPyByKCkKICAgICAgICAgICAgICAgICAgICAgICAgOiBlKCkpLAogICAgICAgICAgICAgICAgICAgIHRoaXMKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbkVycm9yIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAoaC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAhMSksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJlcnJvciIsIHQpLAogICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgidHJhbnNwb3J0IGVycm9yIiwgdCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25DbG9zZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgKCJvcGVuaW5nIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmCiAgICAgICAgICAgICAgICAgICAgIm9wZW4iICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYKICAgICAgICAgICAgICAgICAgICAiY2xvc2luZyIgIT09IHRoaXMucmVhZHlTdGF0ZSkgfHwKICAgICAgICAgICAgICAgICAgICAodGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRoaXMucGluZ1RpbWVvdXRUaW1lciksCiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCJjbG9zZSIpLAogICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCksCiAgICAgICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgcmVtb3ZlRXZlbnRMaXN0ZW5lciAmJgogICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigKICAgICAgICAgICAgICAgICAgICAgICAgIm9mZmxpbmUiLAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZmxpbmVFdmVudExpc3RlbmVyLAogICAgICAgICAgICAgICAgICAgICAgICAhMQogICAgICAgICAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5yZWFkeVN0YXRlID0gImNsb3NlZCIpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLmlkID0gbnVsbCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCJjbG9zZSIsIHQsIGUpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLndyaXRlQnVmZmVyID0gW10pLAogICAgICAgICAgICAgICAgICAgICh0aGlzLnByZXZCdWZmZXJMZW4gPSAwKSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZmlsdGVyVXBncmFkZXMiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBbXSwgbiA9IDAsIHIgPSB0Lmxlbmd0aDsgbiA8IHI7IG4rKykKICAgICAgICAgICAgICAgICAgICB+dGhpcy50cmFuc3BvcnRzLmluZGV4T2YodFtuXSkgJiYgZS5wdXNoKHRbbl0pOwogICAgICAgICAgICAgICAgICByZXR1cm4gZTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSkgJiYgcyhlLnByb3RvdHlwZSwgbiksCiAgICAgICAgICAgIHUgJiYgcyhlLCB1KSwKICAgICAgICAgICAgaAogICAgICAgICAgKTsKICAgICAgICB9KShoKTsKICAgICAgKG0ucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gITEpLAogICAgICAgIChtLnByb3RvY29sID0geS5wcm90b2NvbCksCiAgICAgICAgKHQuZXhwb3J0cyA9IG0pOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgIHRyeSB7CiAgICAgICAgdC5leHBvcnRzID0KICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJgogICAgICAgICAgIndpdGhDcmVkZW50aWFscyIgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0LmV4cG9ydHMgPSAhMTsKICAgICAgfQogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIodCkgewogICAgICAgIHJldHVybiAociA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG8oKSB7CiAgICAgICAgcmV0dXJuIChvID0KICAgICAgICAgIE9iamVjdC5hc3NpZ24gfHwKICAgICAgICAgIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7CiAgICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHNbZV07CiAgICAgICAgICAgICAgZm9yICh2YXIgciBpbiBuKQogICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpICYmICh0W3JdID0gbltyXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGkodCwgZSkgewogICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBlKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHModCwgZSkgewogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgewogICAgICAgICAgdmFyIHIgPSBlW25dOwogICAgICAgICAgKHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSksCiAgICAgICAgICAgIChyLmNvbmZpZ3VyYWJsZSA9ICEwKSwKICAgICAgICAgICAgInZhbHVlIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLAogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgci5rZXksIHIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjKHQsIGUsIG4pIHsKICAgICAgICByZXR1cm4gZSAmJiBzKHQucHJvdG90eXBlLCBlKSwgbiAmJiBzKHQsIG4pLCB0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGEodCwgZSkgewogICAgICAgIGlmICgiZnVuY3Rpb24iICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICApOwogICAgICAgICh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgewogICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgIH0pKSwKICAgICAgICAgIGUgJiYgdSh0LCBlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1KHQsIGUpIHsKICAgICAgICByZXR1cm4gKHUgPQogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8CiAgICAgICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICByZXR1cm4gKHQuX19wcm90b19fID0gZSksIHQ7CiAgICAgICAgICB9KSh0LCBlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmKHQpIHsKICAgICAgICB2YXIgZSA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBpZiAoInVuZGVmaW5lZCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7CiAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExOwogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCgKICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkKICAgICAgICAgICAgICApLAogICAgICAgICAgICAgICEwCiAgICAgICAgICAgICk7CiAgICAgICAgICB9IGNhdGNoICh0KSB7CiAgICAgICAgICAgIHJldHVybiAhMTsKICAgICAgICAgIH0KICAgICAgICB9KSgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgciA9IGgodCk7CiAgICAgICAgICBpZiAoZSkgewogICAgICAgICAgICB2YXIgbyA9IGgodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChyLCBhcmd1bWVudHMsIG8pOwogICAgICAgICAgfSBlbHNlIG4gPSByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICByZXR1cm4gbCh0aGlzLCBuKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGwodCwgZSkgewogICAgICAgIGlmIChlICYmICgib2JqZWN0IiA9PT0gcihlKSB8fCAiZnVuY3Rpb24iID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7CiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIHAodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcCh0KSB7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigKICAgICAgICAgICAgInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaCh0KSB7CiAgICAgICAgcmV0dXJuIChoID0gT2JqZWN0LnNldFByb3RvdHlwZU9mCiAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZgogICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7CiAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIHZhciB5ID0gbigxMCksCiAgICAgICAgZCA9IG4oMTEpLAogICAgICAgIHYgPSBuKDIpLAogICAgICAgIGIgPSBuKDMpLAogICAgICAgIG0gPSBiLnBpY2ssCiAgICAgICAgZyA9IGIuaW5zdGFsbFRpbWVyRnVuY3Rpb25zLAogICAgICAgIGsgPSBuKDApOwogICAgICBmdW5jdGlvbiB3KCkge30KICAgICAgdmFyIE8gPSBudWxsICE9IG5ldyB5KHsgeGRvbWFpbjogITEgfSkucmVzcG9uc2VUeXBlLAogICAgICAgIF8gPSAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGEobiwgdCk7CiAgICAgICAgICB2YXIgZSA9IGYobik7CiAgICAgICAgICBmdW5jdGlvbiBuKHQpIHsKICAgICAgICAgICAgdmFyIHI7CiAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAoaSh0aGlzLCBuKSwKICAgICAgICAgICAgICAociA9IGUuY2FsbCh0aGlzLCB0KSksCiAgICAgICAgICAgICAgInVuZGVmaW5lZCIgIT0gdHlwZW9mIGxvY2F0aW9uKQogICAgICAgICAgICApIHsKICAgICAgICAgICAgICB2YXIgbyA9ICJodHRwczoiID09PSBsb2NhdGlvbi5wcm90b2NvbCwKICAgICAgICAgICAgICAgIHMgPSBsb2NhdGlvbi5wb3J0OwogICAgICAgICAgICAgIHMgfHwgKHMgPSBvID8gNDQzIDogODApLAogICAgICAgICAgICAgICAgKHIueGQgPQogICAgICAgICAgICAgICAgICAoInVuZGVmaW5lZCIgIT0gdHlwZW9mIGxvY2F0aW9uICYmCiAgICAgICAgICAgICAgICAgICAgdC5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8CiAgICAgICAgICAgICAgICAgIHMgIT09IHQucG9ydCksCiAgICAgICAgICAgICAgICAoci54cyA9IHQuc2VjdXJlICE9PSBvKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgYyA9IHQgJiYgdC5mb3JjZUJhc2U2NDsKICAgICAgICAgICAgcmV0dXJuIChyLnN1cHBvcnRzQmluYXJ5ID0gTyAmJiAhYyksIHI7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICBjKG4sIFsKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJyZXF1ZXN0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0ID0KICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXQogICAgICAgICAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0KICAgICAgICAgICAgICAgICAgICAgIDoge307CiAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgbyh0LCB7IHhkOiB0aGlzLnhkLCB4czogdGhpcy54cyB9LCB0aGlzLm9wdHMpLAogICAgICAgICAgICAgICAgICAgIG5ldyBFKHRoaXMudXJpKCksIHQpCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZG9Xcml0ZSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLAogICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICJQT1NUIiwgZGF0YTogdCB9KTsKICAgICAgICAgICAgICAgICAgci5vbigic3VjY2VzcyIsIGUpLAogICAgICAgICAgICAgICAgICAgIHIub24oImVycm9yIiwgZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIG4ub25FcnJvcigieGhyIHBvc3QgZXJyb3IiLCB0KTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJkb1BvbGwiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLAogICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLnJlcXVlc3QoKTsKICAgICAgICAgICAgICAgICAgZS5vbigiZGF0YSIsIHRoaXMub25EYXRhLmJpbmQodGhpcykpLAogICAgICAgICAgICAgICAgICAgIGUub24oImVycm9yIiwgZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgICAgICAgICAgIHQub25FcnJvcigieGhyIHBvbGwgZXJyb3IiLCBlKTsKICAgICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5wb2xsWGhyID0gZSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIF0pLAogICAgICAgICAgICBuCiAgICAgICAgICApOwogICAgICAgIH0pKGQpLAogICAgICAgIEUgPSAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGEobiwgdCk7CiAgICAgICAgICB2YXIgZSA9IGYobik7CiAgICAgICAgICBmdW5jdGlvbiBuKHQsIHIpIHsKICAgICAgICAgICAgdmFyIG87CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgaSh0aGlzLCBuKSwKICAgICAgICAgICAgICAobyA9IGUuY2FsbCh0aGlzKSksCiAgICAgICAgICAgICAgZyhwKG8pLCByKSwKICAgICAgICAgICAgICAoby5vcHRzID0gciksCiAgICAgICAgICAgICAgKG8ubWV0aG9kID0gci5tZXRob2QgfHwgIkdFVCIpLAogICAgICAgICAgICAgIChvLnVyaSA9IHQpLAogICAgICAgICAgICAgIChvLmFzeW5jID0gITEgIT09IHIuYXN5bmMpLAogICAgICAgICAgICAgIChvLmRhdGEgPSB2b2lkIDAgIT09IHIuZGF0YSA/IHIuZGF0YSA6IG51bGwpLAogICAgICAgICAgICAgIG8uY3JlYXRlKCksCiAgICAgICAgICAgICAgbwogICAgICAgICAgICApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgYyhuLCBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiY3JlYXRlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcywKICAgICAgICAgICAgICAgICAgICBlID0gbSgKICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cywKICAgICAgICAgICAgICAgICAgICAgICJhZ2VudCIsCiAgICAgICAgICAgICAgICAgICAgICAiZW5hYmxlc1hEUiIsCiAgICAgICAgICAgICAgICAgICAgICAicGZ4IiwKICAgICAgICAgICAgICAgICAgICAgICJrZXkiLAogICAgICAgICAgICAgICAgICAgICAgInBhc3NwaHJhc2UiLAogICAgICAgICAgICAgICAgICAgICAgImNlcnQiLAogICAgICAgICAgICAgICAgICAgICAgImNhIiwKICAgICAgICAgICAgICAgICAgICAgICJjaXBoZXJzIiwKICAgICAgICAgICAgICAgICAgICAgICJyZWplY3RVbmF1dGhvcml6ZWQiLAogICAgICAgICAgICAgICAgICAgICAgImF1dG9VbnJlZiIKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAoZS54ZG9tYWluID0gISF0aGlzLm9wdHMueGQpLCAoZS54c2NoZW1lID0gISF0aGlzLm9wdHMueHMpOwogICAgICAgICAgICAgICAgICB2YXIgciA9ICh0aGlzLnhociA9IG5ldyB5KGUpKTsKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICByLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTsKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5leHRyYUhlYWRlcnMpCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gaW4gKHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmCiAgICAgICAgICAgICAgICAgICAgICAgICAgci5zZXREaXNhYmxlSGVhZGVyQ2hlY2soITApLAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSkKICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KG8pICYmCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnNldFJlcXVlc3RIZWFkZXIobywgdGhpcy5vcHRzLmV4dHJhSGVhZGVyc1tvXSk7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICAgICAgICAgICAgICBpZiAoIlBPU1QiID09PSB0aGlzLm1ldGhvZCkKICAgICAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2V0UmVxdWVzdEhlYWRlcigKICAgICAgICAgICAgICAgICAgICAgICAgICAiQ29udGVudC10eXBlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04IgogICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgci5zZXRSZXF1ZXN0SGVhZGVyKCJBY2NlcHQiLCAiKi8qIik7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICAgICAgICAgICAgICAid2l0aENyZWRlbnRpYWxzIiBpbiByICYmCiAgICAgICAgICAgICAgICAgICAgICAoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLm9wdHMud2l0aENyZWRlbnRpYWxzKSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5yZXF1ZXN0VGltZW91dCAmJgogICAgICAgICAgICAgICAgICAgICAgICAoci50aW1lb3V0ID0gdGhpcy5vcHRzLnJlcXVlc3RUaW1lb3V0KSwKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzWERSKCkKICAgICAgICAgICAgICAgICAgICAgICAgPyAoKHIub25sb2FkID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5vbkxvYWQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAgICAgICAoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5vbkVycm9yKHIucmVzcG9uc2VUZXh0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkKICAgICAgICAgICAgICAgICAgICAgICAgOiAoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0ID09PSByLnJlYWR5U3RhdGUgJiYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDIwMCA9PT0gci5zdGF0dXMgfHwgMTIyMyA9PT0gci5zdGF0dXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHQub25Mb2FkKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHQuc2V0VGltZW91dEZuKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5vbkVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJudW1iZXIiID09IHR5cGVvZiByLnN0YXR1cyA/IHIuc3RhdHVzIDogMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCkpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAgICAgci5zZW5kKHRoaXMuZGF0YSk7CiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLnNldFRpbWVvdXRGbihmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICB0Lm9uRXJyb3IoZSk7CiAgICAgICAgICAgICAgICAgICAgfSwgMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgInVuZGVmaW5lZCIgIT0gdHlwZW9mIGRvY3VtZW50ICYmCiAgICAgICAgICAgICAgICAgICAgKCh0aGlzLmluZGV4ID0gbi5yZXF1ZXN0c0NvdW50KyspLAogICAgICAgICAgICAgICAgICAgIChuLnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcykpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uU3VjY2VzcyIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoInN1Y2Nlc3MiKSwgdGhpcy5jbGVhbnVwKCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAib25EYXRhIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoImRhdGEiLCB0KSwgdGhpcy5vblN1Y2Nlc3MoKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJvbkVycm9yIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoImVycm9yIiwgdCksIHRoaXMuY2xlYW51cCghMCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiY2xlYW51cCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdGhpcy54aHIgJiYgbnVsbCAhPT0gdGhpcy54aHIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oYXNYRFIoKQogICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gdykKICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdyksCiAgICAgICAgICAgICAgICAgICAgICB0KQogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueGhyLmFib3J0KCk7CiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7fQogICAgICAgICAgICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBkb2N1bWVudCAmJgogICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG4ucmVxdWVzdHNbdGhpcy5pbmRleF0sCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy54aHIgPSBudWxsKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uTG9hZCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDsKICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdCAmJiB0aGlzLm9uRGF0YSh0KTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJoYXNYRFIiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgICAidW5kZWZpbmVkIiAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYKICAgICAgICAgICAgICAgICAgICAhdGhpcy54cyAmJgogICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlc1hEUgogICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImFib3J0IiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICBdKSwKICAgICAgICAgICAgbgogICAgICAgICAgKTsKICAgICAgICB9KSh2KTsKICAgICAgaWYgKAogICAgICAgICgoRS5yZXF1ZXN0c0NvdW50ID0gMCksCiAgICAgICAgKEUucmVxdWVzdHMgPSB7fSksCiAgICAgICAgInVuZGVmaW5lZCIgIT0gdHlwZW9mIGRvY3VtZW50KQogICAgICApCiAgICAgICAgaWYgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIGF0dGFjaEV2ZW50KSBhdHRhY2hFdmVudCgib251bmxvYWQiLCBTKTsKICAgICAgICBlbHNlIGlmICgiZnVuY3Rpb24iID09IHR5cGVvZiBhZGRFdmVudExpc3RlbmVyKSB7CiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCJvbnBhZ2VoaWRlIiBpbiBrID8gInBhZ2VoaWRlIiA6ICJ1bmxvYWQiLCBTLCAhMSk7CiAgICAgICAgfQogICAgICBmdW5jdGlvbiBTKCkgewogICAgICAgIGZvciAodmFyIHQgaW4gRS5yZXF1ZXN0cykKICAgICAgICAgIEUucmVxdWVzdHMuaGFzT3duUHJvcGVydHkodCkgJiYgRS5yZXF1ZXN0c1t0XS5hYm9ydCgpOwogICAgICB9CiAgICAgICh0LmV4cG9ydHMgPSBfKSwgKHQuZXhwb3J0cy5SZXF1ZXN0ID0gRSk7CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgdmFyIHIgPSBuKDEyKS5QQUNLRVRfVFlQRVMsCiAgICAgICAgbyA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBCbG9iIHx8CiAgICAgICAgICAoInVuZGVmaW5lZCIgIT0gdHlwZW9mIEJsb2IgJiYKICAgICAgICAgICAgIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSIgPT09CiAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEJsb2IpKSwKICAgICAgICBpID0gImZ1bmN0aW9uIiA9PSB0eXBlb2YgQXJyYXlCdWZmZXIsCiAgICAgICAgcyA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICB2YXIgbiA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAobi5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSBuLnJlc3VsdC5zcGxpdCgiLCIpWzFdOwogICAgICAgICAgICAgIGUoImIiICsgdCk7CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICBuLnJlYWRBc0RhdGFVUkwodCkKICAgICAgICAgICk7CiAgICAgICAgfTsKICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgICB2YXIgYywKICAgICAgICAgIGEgPSB0LnR5cGUsCiAgICAgICAgICB1ID0gdC5kYXRhOwogICAgICAgIHJldHVybiBvICYmIHUgaW5zdGFuY2VvZiBCbG9iCiAgICAgICAgICA/IGUKICAgICAgICAgICAgPyBuKHUpCiAgICAgICAgICAgIDogcyh1LCBuKQogICAgICAgICAgOiBpICYmCiAgICAgICAgICAgICh1IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwKICAgICAgICAgICAgICAoKGMgPSB1KSwKICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcKICAgICAgICAgICAgICAgID8gQXJyYXlCdWZmZXIuaXNWaWV3KGMpCiAgICAgICAgICAgICAgICA6IGMgJiYgYy5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpCiAgICAgICAgICA/IGUKICAgICAgICAgICAgPyBuKHUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IHUgOiB1LmJ1ZmZlcikKICAgICAgICAgICAgOiBzKG5ldyBCbG9iKFt1XSksIG4pCiAgICAgICAgICA6IG4oclthXSArICh1IHx8ICIiKSk7CiAgICAgIH07CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgdmFyIHIsCiAgICAgICAgbyA9IG4oMTIpLAogICAgICAgIGkgPSBvLlBBQ0tFVF9UWVBFU19SRVZFUlNFLAogICAgICAgIHMgPSBvLkVSUk9SX1BBQ0tFVDsKICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgKHIgPSBuKDI2KSk7CiAgICAgIHZhciBjID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgIGlmIChyKSB7CiAgICAgICAgICAgIHZhciBuID0gci5kZWNvZGUodCk7CiAgICAgICAgICAgIHJldHVybiBhKG4sIGUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHsgYmFzZTY0OiAhMCwgZGF0YTogdCB9OwogICAgICAgIH0sCiAgICAgICAgYSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICBzd2l0Y2ggKGUpIHsKICAgICAgICAgICAgY2FzZSAiYmxvYiI6CiAgICAgICAgICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBCbG9iKFt0XSkgOiB0OwogICAgICAgICAgICBjYXNlICJhcnJheWJ1ZmZlciI6CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICBpZiAoInN0cmluZyIgIT0gdHlwZW9mIHQpIHJldHVybiB7IHR5cGU6ICJtZXNzYWdlIiwgZGF0YTogYSh0LCBlKSB9OwogICAgICAgIHZhciBuID0gdC5jaGFyQXQoMCk7CiAgICAgICAgcmV0dXJuICJiIiA9PT0gbgogICAgICAgICAgPyB7IHR5cGU6ICJtZXNzYWdlIiwgZGF0YTogYyh0LnN1YnN0cmluZygxKSwgZSkgfQogICAgICAgICAgOiBpW25dCiAgICAgICAgICA/IHQubGVuZ3RoID4gMQogICAgICAgICAgICA/IHsgdHlwZTogaVtuXSwgZGF0YTogdC5zdWJzdHJpbmcoMSkgfQogICAgICAgICAgICA6IHsgdHlwZTogaVtuXSB9CiAgICAgICAgICA6IHM7CiAgICAgIH07CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgIShmdW5jdGlvbiAodCkgewogICAgICAgIChlLmVuY29kZSA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgciA9IG5ldyBVaW50OEFycmF5KGUpLAogICAgICAgICAgICBvID0gci5sZW5ndGgsCiAgICAgICAgICAgIGkgPSAiIjsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBvOyBuICs9IDMpCiAgICAgICAgICAgIChpICs9IHRbcltuXSA+PiAyXSksCiAgICAgICAgICAgICAgKGkgKz0gdFsoKDMgJiByW25dKSA8PCA0KSB8IChyW24gKyAxXSA+PiA0KV0pLAogICAgICAgICAgICAgIChpICs9IHRbKCgxNSAmIHJbbiArIDFdKSA8PCAyKSB8IChyW24gKyAyXSA+PiA2KV0pLAogICAgICAgICAgICAgIChpICs9IHRbNjMgJiByW24gKyAyXV0pOwogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgbyAlIDMgPT0gMgogICAgICAgICAgICAgID8gKGkgPSBpLnN1YnN0cmluZygwLCBpLmxlbmd0aCAtIDEpICsgIj0iKQogICAgICAgICAgICAgIDogbyAlIDMgPT0gMSAmJiAoaSA9IGkuc3Vic3RyaW5nKDAsIGkubGVuZ3RoIC0gMikgKyAiPT0iKSwKICAgICAgICAgICAgaQogICAgICAgICAgKTsKICAgICAgICB9KSwKICAgICAgICAgIChlLmRlY29kZSA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgIHZhciBuLAogICAgICAgICAgICAgIHIsCiAgICAgICAgICAgICAgbywKICAgICAgICAgICAgICBpLAogICAgICAgICAgICAgIHMsCiAgICAgICAgICAgICAgYyA9IDAuNzUgKiBlLmxlbmd0aCwKICAgICAgICAgICAgICBhID0gZS5sZW5ndGgsCiAgICAgICAgICAgICAgdSA9IDA7CiAgICAgICAgICAgICI9IiA9PT0gZVtlLmxlbmd0aCAtIDFdICYmIChjLS0sICI9IiA9PT0gZVtlLmxlbmd0aCAtIDJdICYmIGMtLSk7CiAgICAgICAgICAgIHZhciBmID0gbmV3IEFycmF5QnVmZmVyKGMpLAogICAgICAgICAgICAgIGwgPSBuZXcgVWludDhBcnJheShmKTsKICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGE7IG4gKz0gNCkKICAgICAgICAgICAgICAociA9IHQuaW5kZXhPZihlW25dKSksCiAgICAgICAgICAgICAgICAobyA9IHQuaW5kZXhPZihlW24gKyAxXSkpLAogICAgICAgICAgICAgICAgKGkgPSB0LmluZGV4T2YoZVtuICsgMl0pKSwKICAgICAgICAgICAgICAgIChzID0gdC5pbmRleE9mKGVbbiArIDNdKSksCiAgICAgICAgICAgICAgICAobFt1KytdID0gKHIgPDwgMikgfCAobyA+PiA0KSksCiAgICAgICAgICAgICAgICAobFt1KytdID0gKCgxNSAmIG8pIDw8IDQpIHwgKGkgPj4gMikpLAogICAgICAgICAgICAgICAgKGxbdSsrXSA9ICgoMyAmIGkpIDw8IDYpIHwgKDYzICYgcykpOwogICAgICAgICAgICByZXR1cm4gZjsKICAgICAgICAgIH0pOwogICAgICB9KSgiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIpOwogICAgfSwKICAgIGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgIGZ1bmN0aW9uIHIodCkgewogICAgICAgIHJldHVybiAociA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYgInN5bWJvbCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvcgogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJgogICAgICAgICAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQgIT09IFN5bWJvbC5wcm90b3R5cGUKICAgICAgICAgICAgICAgICAgPyAic3ltYm9sIgogICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0OwogICAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG8odCwgZSkgewogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgewogICAgICAgICAgdmFyIHIgPSBlW25dOwogICAgICAgICAgKHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSksCiAgICAgICAgICAgIChyLmNvbmZpZ3VyYWJsZSA9ICEwKSwKICAgICAgICAgICAgInZhbHVlIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLAogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgci5rZXksIHIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBpKHQsIGUsIG4pIHsKICAgICAgICByZXR1cm4gKGkgPQogICAgICAgICAgInVuZGVmaW5lZCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQKICAgICAgICAgICAgPyBSZWZsZWN0LmdldAogICAgICAgICAgICA6IGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgICBmb3IgKAogICAgICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGUpICYmCiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gKHQgPSBmKHQpKTsKCiAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0OwogICAgICAgICAgICAgICAgfSkodCwgZSk7CiAgICAgICAgICAgICAgICBpZiAocikgewogICAgICAgICAgICAgICAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgZSk7CiAgICAgICAgICAgICAgICAgIHJldHVybiBvLmdldCA/IG8uZ2V0LmNhbGwobikgOiBvLnZhbHVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pKHQsIGUsIG4gfHwgdCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcyh0LCBlKSB7CiAgICAgICAgcmV0dXJuIChzID0KICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAogICAgICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgcmV0dXJuICh0Ll9fcHJvdG9fXyA9IGUpLCB0OwogICAgICAgICAgfSkodCwgZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYyh0KSB7CiAgICAgICAgdmFyIGUgPSAoZnVuY3Rpb24gKCkgewogICAgICAgICAgaWYgKCJ1bmRlZmluZWQiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExOwogICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTsKICAgICAgICAgIGlmICgiZnVuY3Rpb24iID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoCiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pCiAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAhMAogICAgICAgICAgICApOwogICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICByZXR1cm4gITE7CiAgICAgICAgICB9CiAgICAgICAgfSkoKTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIG4sCiAgICAgICAgICAgIHIgPSBmKHQpOwogICAgICAgICAgaWYgKGUpIHsKICAgICAgICAgICAgdmFyIG8gPSBmKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QociwgYXJndW1lbnRzLCBvKTsKICAgICAgICAgIH0gZWxzZSBuID0gci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgcmV0dXJuIGEodGhpcywgbik7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhKHQsIGUpIHsKICAgICAgICBpZiAoZSAmJiAoIm9iamVjdCIgPT09IHIoZSkgfHwgImZ1bmN0aW9uIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOwogICAgICAgIGlmICh2b2lkIDAgIT09IGUpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiCiAgICAgICAgICApOwogICAgICAgIHJldHVybiB1KHQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHUodCkgewogICAgICAgIGlmICh2b2lkIDAgPT09IHQpCiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoCiAgICAgICAgICAgICJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiCiAgICAgICAgICApOwogICAgICAgIHJldHVybiB0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGYodCkgewogICAgICAgIHJldHVybiAoZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZgogICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YKICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOwogICAgICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICB2YXIgbCwKICAgICAgICBwID0gbigxMSksCiAgICAgICAgaCA9IG4oMCksCiAgICAgICAgeSA9IC9cbi9nLAogICAgICAgIGQgPSAvXFxuL2csCiAgICAgICAgdiA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgIShmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgKHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7CiAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9LAogICAgICAgICAgICB9KSksCiAgICAgICAgICAgICAgZSAmJiBzKHQsIGUpOwogICAgICAgICAgfSkocCwgdCk7CiAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgbiwKICAgICAgICAgICAgciwKICAgICAgICAgICAgYSA9IGMocCk7CiAgICAgICAgICBmdW5jdGlvbiBwKHQpIHsKICAgICAgICAgICAgdmFyIGU7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpCiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICAgICAgICAgIH0pKHRoaXMsIHApLAogICAgICAgICAgICAgICgoZSA9IGEuY2FsbCh0aGlzLCB0KSkucXVlcnkgPSBlLnF1ZXJ5IHx8IHt9KSwKICAgICAgICAgICAgICBsIHx8IChsID0gaC5fX19laW8gPSBoLl9fX2VpbyB8fCBbXSksCiAgICAgICAgICAgICAgKGUuaW5kZXggPSBsLmxlbmd0aCksCiAgICAgICAgICAgICAgbC5wdXNoKGUub25EYXRhLmJpbmQodShlKSkpLAogICAgICAgICAgICAgIChlLnF1ZXJ5LmogPSBlLmluZGV4KSwKICAgICAgICAgICAgICBlCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAoZSA9IHApLAogICAgICAgICAgICAobiA9IFsKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJzdXBwb3J0c0JpbmFyeSIsCiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICExOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImRvQ2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHQgJiYKICAgICAgICAgICAgICAgICAgICAoKHRoaXMuc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7fSksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2NyaXB0ID0gbnVsbCkpLAogICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybSAmJgogICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSksCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5mb3JtID0gbnVsbCksCiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pZnJhbWUgPSBudWxsKSksCiAgICAgICAgICAgICAgICAgICAgaShmKHAucHJvdG90eXBlKSwgImRvQ2xvc2UiLCB0aGlzKS5jYWxsKHRoaXMpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImRvUG9sbCIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsCiAgICAgICAgICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpOwogICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdCAmJgogICAgICAgICAgICAgICAgICAgICh0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy5zY3JpcHQgPSBudWxsKSksCiAgICAgICAgICAgICAgICAgICAgKGUuYXN5bmMgPSAhMCksCiAgICAgICAgICAgICAgICAgICAgKGUuc3JjID0gdGhpcy51cmkoKSksCiAgICAgICAgICAgICAgICAgICAgKGUub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICB0Lm9uRXJyb3IoImpzb25wIHBvbGwgZXJyb3IiLCBlKTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgic2NyaXB0IilbMF07CiAgICAgICAgICAgICAgICAgIG4KICAgICAgICAgICAgICAgICAgICA/IG4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgbikKICAgICAgICAgICAgICAgICAgICA6IChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKGUpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLnNjcmlwdCA9IGUpLAogICAgICAgICAgICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYKICAgICAgICAgICAgICAgICAgICAgIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dEZuKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpZnJhbWUiKTsKICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KSwKICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpOwogICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJkb1dyaXRlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgICB2YXIgbiwKICAgICAgICAgICAgICAgICAgICByID0gdGhpczsKICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHsKICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImZvcm0iKSwKICAgICAgICAgICAgICAgICAgICAgIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpLAogICAgICAgICAgICAgICAgICAgICAgcyA9ICh0aGlzLmlmcmFtZUlkID0gImVpb19pZnJhbWVfIiArIHRoaXMuaW5kZXgpOwogICAgICAgICAgICAgICAgICAgIChvLmNsYXNzTmFtZSA9ICJzb2NrZXRpbyIpLAogICAgICAgICAgICAgICAgICAgICAgKG8uc3R5bGUucG9zaXRpb24gPSAiYWJzb2x1dGUiKSwKICAgICAgICAgICAgICAgICAgICAgIChvLnN0eWxlLnRvcCA9ICItMTAwMHB4IiksCiAgICAgICAgICAgICAgICAgICAgICAoby5zdHlsZS5sZWZ0ID0gIi0xMDAwcHgiKSwKICAgICAgICAgICAgICAgICAgICAgIChvLnRhcmdldCA9IHMpLAogICAgICAgICAgICAgICAgICAgICAgKG8ubWV0aG9kID0gIlBPU1QiKSwKICAgICAgICAgICAgICAgICAgICAgIG8uc2V0QXR0cmlidXRlKCJhY2NlcHQtY2hhcnNldCIsICJ1dGYtOCIpLAogICAgICAgICAgICAgICAgICAgICAgKGkubmFtZSA9ICJkIiksCiAgICAgICAgICAgICAgICAgICAgICBvLmFwcGVuZENoaWxkKGkpLAogICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvKSwKICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZvcm0gPSBvKSwKICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmFyZWEgPSBpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKCkgewogICAgICAgICAgICAgICAgICAgIGEoKSwgZSgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpOwogICAgICAgICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoci5pZnJhbWUpCiAgICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgICByLmZvcm0ucmVtb3ZlQ2hpbGQoci5pZnJhbWUpOwogICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgICByLm9uRXJyb3IoImpzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3IiLCB0KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPQogICAgICAgICAgICAgICAgICAgICAgICAnPGlmcmFtZSBzcmM9ImphdmFzY3JpcHQ6MCIgbmFtZT0iJyArIHIuaWZyYW1lSWQgKyAnIj4nOwogICAgICAgICAgICAgICAgICAgICAgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgKChuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaWZyYW1lIikpLm5hbWUgPQogICAgICAgICAgICAgICAgICAgICAgICByLmlmcmFtZUlkKSwKICAgICAgICAgICAgICAgICAgICAgICAgKG4uc3JjID0gImphdmFzY3JpcHQ6MCIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAobi5pZCA9IHIuaWZyYW1lSWQpLCByLmZvcm0uYXBwZW5kQ2hpbGQobiksIChyLmlmcmFtZSA9IG4pOwogICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICBhKCksCiAgICAgICAgICAgICAgICAgICAgKHQgPSB0LnJlcGxhY2UoZCwgIlxcXG4iKSksCiAgICAgICAgICAgICAgICAgICAgKHRoaXMuYXJlYS52YWx1ZSA9IHQucmVwbGFjZSh5LCAiXFxuIikpOwogICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5zdWJtaXQoKTsKICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge30KICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQKICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICJjb21wbGV0ZSIgPT09IHIuaWZyYW1lLnJlYWR5U3RhdGUgJiYgYygpOwogICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmlmcmFtZS5vbmxvYWQgPSBjKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSkgJiYgbyhlLnByb3RvdHlwZSwgbiksCiAgICAgICAgICAgIHIgJiYgbyhlLCByKSwKICAgICAgICAgICAgcAogICAgICAgICAgKTsKICAgICAgICB9KShwKTsKICAgICAgdC5leHBvcnRzID0gdjsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICBmdW5jdGlvbiByKHQpIHsKICAgICAgICByZXR1cm4gKHIgPQogICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgU3ltYm9sICYmICJzeW1ib2wiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IKICAgICAgICAgICAgPyBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHQgJiYKICAgICAgICAgICAgICAgICAgImZ1bmN0aW9uIiA9PSB0eXBlb2YgU3ltYm9sICYmCiAgICAgICAgICAgICAgICAgIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0ICE9PSBTeW1ib2wucHJvdG90eXBlCiAgICAgICAgICAgICAgICAgID8gInN5bWJvbCIKICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9KSh0KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvKHQsIGUpIHsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHsKICAgICAgICAgIHZhciByID0gZVtuXTsKICAgICAgICAgIChyLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEpLAogICAgICAgICAgICAoci5jb25maWd1cmFibGUgPSAhMCksCiAgICAgICAgICAgICJ2YWx1ZSIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIua2V5LCByKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaSh0LCBlKSB7CiAgICAgICAgcmV0dXJuIChpID0KICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fAogICAgICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgcmV0dXJuICh0Ll9fcHJvdG9fXyA9IGUpLCB0OwogICAgICAgICAgfSkodCwgZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcyh0KSB7CiAgICAgICAgdmFyIGUgPSAoZnVuY3Rpb24gKCkgewogICAgICAgICAgaWYgKCJ1bmRlZmluZWQiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExOwogICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTsKICAgICAgICAgIGlmICgiZnVuY3Rpb24iID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoCiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pCiAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAhMAogICAgICAgICAgICApOwogICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICByZXR1cm4gITE7CiAgICAgICAgICB9CiAgICAgICAgfSkoKTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIG4sCiAgICAgICAgICAgIHIgPSBhKHQpOwogICAgICAgICAgaWYgKGUpIHsKICAgICAgICAgICAgdmFyIG8gPSBhKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QociwgYXJndW1lbnRzLCBvKTsKICAgICAgICAgIH0gZWxzZSBuID0gci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgcmV0dXJuIGModGhpcywgbik7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjKHQsIGUpIHsKICAgICAgICBpZiAoZSAmJiAoIm9iamVjdCIgPT09IHIoZSkgfHwgImZ1bmN0aW9uIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOwogICAgICAgIGlmICh2b2lkIDAgIT09IGUpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiCiAgICAgICAgICApOwogICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpCiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigKICAgICAgICAgICAgICAidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIgogICAgICAgICAgICApOwogICAgICAgICAgcmV0dXJuIHQ7CiAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYSh0KSB7CiAgICAgICAgcmV0dXJuIChhID0gT2JqZWN0LnNldFByb3RvdHlwZU9mCiAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZgogICAgICAgICAgOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7CiAgICAgICAgICAgIH0pKHQpOwogICAgICB9CiAgICAgIHZhciB1ID0gbig0KSwKICAgICAgICBmID0gbigxKSwKICAgICAgICBsID0gbig1KSwKICAgICAgICBwID0gbigxMyksCiAgICAgICAgaCA9IG4oMykucGljaywKICAgICAgICB5ID0gbigyOSksCiAgICAgICAgZCA9IHkuV2ViU29ja2V0LAogICAgICAgIHYgPSB5LnVzaW5nQnJvd3NlcldlYlNvY2tldCwKICAgICAgICBiID0geS5kZWZhdWx0QmluYXJ5VHlwZSwKICAgICAgICBtID0geS5uZXh0VGljaywKICAgICAgICBnID0KICAgICAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYKICAgICAgICAgICJzdHJpbmciID09IHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCAmJgogICAgICAgICAgInJlYWN0bmF0aXZlIiA9PT0gbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSwKICAgICAgICBrID0gKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAhKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIGlmICgiZnVuY3Rpb24iICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpCiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIKICAgICAgICAgICAgICApOwogICAgICAgICAgICAodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsKICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0sCiAgICAgICAgICAgIH0pKSwKICAgICAgICAgICAgICBlICYmIGkodCwgZSk7CiAgICAgICAgICB9KShhLCB0KTsKICAgICAgICAgIHZhciBlLAogICAgICAgICAgICBuLAogICAgICAgICAgICByLAogICAgICAgICAgICBjID0gcyhhKTsKICAgICAgICAgIGZ1bmN0aW9uIGEodCkgewogICAgICAgICAgICB2YXIgZTsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAoZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBlKSkKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgICAgICAgfSkodGhpcywgYSksCiAgICAgICAgICAgICAgKChlID0gYy5jYWxsKHRoaXMsIHQpKS5zdXBwb3J0c0JpbmFyeSA9ICF0LmZvcmNlQmFzZTY0KSwKICAgICAgICAgICAgICBlCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAoZSA9IGEpLAogICAgICAgICAgICAobiA9IFsKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJuYW1lIiwKICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gIndlYnNvY2tldCI7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAga2V5OiAiZG9PcGVuIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrKCkpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMudXJpKCksCiAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5vcHRzLnByb3RvY29scywKICAgICAgICAgICAgICAgICAgICAgIG4gPSBnCiAgICAgICAgICAgICAgICAgICAgICAgID8ge30KICAgICAgICAgICAgICAgICAgICAgICAgOiBoKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImFnZW50IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJwZXJNZXNzYWdlRGVmbGF0ZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAicGZ4IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJrZXkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgInBhc3NwaHJhc2UiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImNlcnQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImNhIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjaXBoZXJzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJyZWplY3RVbmF1dGhvcml6ZWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImxvY2FsQWRkcmVzcyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAicHJvdG9jb2xWZXJzaW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJvcmlnaW4iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1heFBheWxvYWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgImZhbWlseSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiY2hlY2tTZXJ2ZXJJZGVudGl0eSIKICAgICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5leHRyYUhlYWRlcnMgJiYKICAgICAgICAgICAgICAgICAgICAgIChuLmhlYWRlcnMgPSB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKTsKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgdGhpcy53cyA9CiAgICAgICAgICAgICAgICAgICAgICAgIHYgJiYgIWcgPyAoZSA/IG5ldyBkKHQsIGUpIDogbmV3IGQodCkpIDogbmV3IGQodCwgZSwgbik7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgiZXJyb3IiLCB0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgKHRoaXMud3MuYmluYXJ5VHlwZSA9IHRoaXMuc29ja2V0LmJpbmFyeVR5cGUgfHwgYiksCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJhZGRFdmVudExpc3RlbmVycyIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7CiAgICAgICAgICAgICAgICAgICh0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICB0Lm9wdHMuYXV0b1VucmVmICYmIHQud3MuX3NvY2tldC51bnJlZigpLCB0Lm9uT3BlbigpOwogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcykpLAogICAgICAgICAgICAgICAgICAgICh0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5vbkRhdGEoZS5kYXRhKTsKICAgICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgICAodGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Lm9uRXJyb3IoIndlYnNvY2tldCBlcnJvciIsIGUpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIndyaXRlIiwKICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7CiAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSAhMTsKICAgICAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uIChuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdFtuXSwKICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gbiA9PT0gdC5sZW5ndGggLSAxOwogICAgICAgICAgICAgICAgICAgICAgICBmLmVuY29kZVBhY2tldChyLCBlLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0ge307CiAgICAgICAgICAgICAgICAgICAgICAgICAgdiB8fAogICAgICAgICAgICAgICAgICAgICAgICAgICAgKHIub3B0aW9ucyAmJiAobi5jb21wcmVzcyA9IHIub3B0aW9ucy5jb21wcmVzcyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm9wdHMucGVyTWVzc2FnZURlZmxhdGUgJiYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCJzdHJpbmciID09IHR5cGVvZiB0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBCdWZmZXIuYnl0ZUxlbmd0aCh0KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdC5sZW5ndGgpIDwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm9wdHMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkICYmCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuLmNvbXByZXNzID0gITEpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA/IGUud3Muc2VuZCh0KSA6IGUud3Muc2VuZCh0LCBuKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7fQogICAgICAgICAgICAgICAgICAgICAgICAgIG8gJiYKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS53cml0YWJsZSA9ICEwKSwgZS5lbWl0KCJkcmFpbiIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5zZXRUaW1lb3V0Rm4pOwogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICByID0gMDsKICAgICAgICAgICAgICAgICAgICByIDwgdC5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgcisrCiAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICBuKHIpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogIm9uQ2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdS5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogImRvQ2xvc2UiLAogICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLndzICYmICh0aGlzLndzLmNsb3NlKCksICh0aGlzLndzID0gbnVsbCkpOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGtleTogInVyaSIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucXVlcnkgfHwge30sCiAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMub3B0cy5zZWN1cmUgPyAid3NzIiA6ICJ3cyIsCiAgICAgICAgICAgICAgICAgICAgbiA9ICIiOwogICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5wb3J0ICYmCiAgICAgICAgICAgICAgICAgICAgICAoKCJ3c3MiID09PSBlICYmIDQ0MyAhPT0gTnVtYmVyKHRoaXMub3B0cy5wb3J0KSkgfHwKICAgICAgICAgICAgICAgICAgICAgICAgKCJ3cyIgPT09IGUgJiYgODAgIT09IE51bWJlcih0aGlzLm9wdHMucG9ydCkpKSAmJgogICAgICAgICAgICAgICAgICAgICAgKG4gPSAiOiIgKyB0aGlzLm9wdHMucG9ydCksCiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzICYmCiAgICAgICAgICAgICAgICAgICAgICAodFt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gcCgpKSwKICAgICAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5IHx8ICh0LmI2NCA9IDEpLAogICAgICAgICAgICAgICAgICAgICh0ID0gbC5lbmNvZGUodCkpLmxlbmd0aCAmJiAodCA9ICI/IiArIHQpLAogICAgICAgICAgICAgICAgICAgIGUgKwogICAgICAgICAgICAgICAgICAgICAgIjovLyIgKwogICAgICAgICAgICAgICAgICAgICAgKC0xICE9PSB0aGlzLm9wdHMuaG9zdG5hbWUuaW5kZXhPZigiOiIpCiAgICAgICAgICAgICAgICAgICAgICAgID8gIlsiICsgdGhpcy5vcHRzLmhvc3RuYW1lICsgIl0iCiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRzLmhvc3RuYW1lKSArCiAgICAgICAgICAgICAgICAgICAgICBuICsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICsKICAgICAgICAgICAgICAgICAgICAgIHQKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBrZXk6ICJjaGVjayIsCiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gISgKICAgICAgICAgICAgICAgICAgICAhZCB8fAogICAgICAgICAgICAgICAgICAgICgiX19pbml0aWFsaXplIiBpbiBkICYmIHRoaXMubmFtZSA9PT0gYS5wcm90b3R5cGUubmFtZSkKICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgXSkgJiYgbyhlLnByb3RvdHlwZSwgbiksCiAgICAgICAgICAgIHIgJiYgbyhlLCByKSwKICAgICAgICAgICAgYQogICAgICAgICAgKTsKICAgICAgICB9KSh1KTsKICAgICAgdC5leHBvcnRzID0gazsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICB2YXIgciA9IG4oMCksCiAgICAgICAgbyA9CiAgICAgICAgICAiZnVuY3Rpb24iID09IHR5cGVvZiBQcm9taXNlICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIFByb21pc2UucmVzb2x2ZQogICAgICAgICAgICA/IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgIHJldHVybiBlKHQsIDApOwogICAgICAgICAgICAgIH07CiAgICAgIHQuZXhwb3J0cyA9IHsKICAgICAgICBXZWJTb2NrZXQ6IHIuV2ViU29ja2V0IHx8IHIuTW96V2ViU29ja2V0LAogICAgICAgIHVzaW5nQnJvd3NlcldlYlNvY2tldDogITAsCiAgICAgICAgZGVmYXVsdEJpbmFyeVR5cGU6ICJhcnJheWJ1ZmZlciIsCiAgICAgICAgbmV4dFRpY2s6IG8sCiAgICAgIH07CiAgICB9LAogICAgZnVuY3Rpb24gKHQsIGUsIG4pIHsKICAgICAgZnVuY3Rpb24gcih0KSB7CiAgICAgICAgcmV0dXJuIChyID0KICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJiAic3ltYm9sIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yCiAgICAgICAgICAgID8gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0ICYmCiAgICAgICAgICAgICAgICAgICJmdW5jdGlvbiIgPT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgICB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYKICAgICAgICAgICAgICAgICAgdCAhPT0gU3ltYm9sLnByb3RvdHlwZQogICAgICAgICAgICAgICAgICA/ICJzeW1ib2wiCiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHQ7CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogITAgfSksCiAgICAgICAgKGUucmVjb25zdHJ1Y3RQYWNrZXQgPSBlLmRlY29uc3RydWN0UGFja2V0ID0gdm9pZCAwKTsKICAgICAgdmFyIG8gPSBuKDE1KTsKICAgICAgKGUuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbiAodCkgewogICAgICAgIHZhciBlID0gW10sCiAgICAgICAgICBuID0gdC5kYXRhLAogICAgICAgICAgaSA9IHQ7CiAgICAgICAgcmV0dXJuICgKICAgICAgICAgIChpLmRhdGEgPSAoZnVuY3Rpb24gdChlLCBuKSB7CiAgICAgICAgICAgIGlmICghZSkgcmV0dXJuIGU7CiAgICAgICAgICAgIGlmIChvLmlzQmluYXJ5KGUpKSB7CiAgICAgICAgICAgICAgdmFyIGkgPSB7IF9wbGFjZWhvbGRlcjogITAsIG51bTogbi5sZW5ndGggfTsKICAgICAgICAgICAgICByZXR1cm4gbi5wdXNoKGUpLCBpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IG5ldyBBcnJheShlLmxlbmd0aCksIGMgPSAwOyBjIDwgZS5sZW5ndGg7IGMrKykKICAgICAgICAgICAgICAgIHNbY10gPSB0KGVbY10sIG4pOwogICAgICAgICAgICAgIHJldHVybiBzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgib2JqZWN0IiA9PT0gcihlKSAmJiAhKGUgaW5zdGFuY2VvZiBEYXRlKSkgewogICAgICAgICAgICAgIHZhciBhID0ge307CiAgICAgICAgICAgICAgZm9yICh2YXIgdSBpbiBlKSBlLmhhc093blByb3BlcnR5KHUpICYmIChhW3VdID0gdChlW3VdLCBuKSk7CiAgICAgICAgICAgICAgcmV0dXJuIGE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGU7CiAgICAgICAgICB9KShuLCBlKSksCiAgICAgICAgICAoaS5hdHRhY2htZW50cyA9IGUubGVuZ3RoKSwKICAgICAgICAgIHsgcGFja2V0OiBpLCBidWZmZXJzOiBlIH0KICAgICAgICApOwogICAgICB9KSwKICAgICAgICAoZS5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAodC5kYXRhID0gKGZ1bmN0aW9uIHQoZSwgbikgewogICAgICAgICAgICAgIGlmICghZSkgcmV0dXJuIGU7CiAgICAgICAgICAgICAgaWYgKGUgJiYgZS5fcGxhY2Vob2xkZXIpIHJldHVybiBuW2UubnVtXTsKICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkKICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykgZVtvXSA9IHQoZVtvXSwgbik7CiAgICAgICAgICAgICAgZWxzZSBpZiAoIm9iamVjdCIgPT09IHIoZSkpCiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGUpIGUuaGFzT3duUHJvcGVydHkoaSkgJiYgKGVbaV0gPSB0KGVbaV0sIG4pKTsKICAgICAgICAgICAgICByZXR1cm4gZTsKICAgICAgICAgICAgfSkodC5kYXRhLCBlKSksCiAgICAgICAgICAgICh0LmF0dGFjaG1lbnRzID0gdm9pZCAwKSwKICAgICAgICAgICAgdAogICAgICAgICAgKTsKICAgICAgICB9KTsKICAgIH0sCiAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICBmdW5jdGlvbiBuKHQpIHsKICAgICAgICAodCA9IHQgfHwge30pLAogICAgICAgICAgKHRoaXMubXMgPSB0Lm1pbiB8fCAxMDApLAogICAgICAgICAgKHRoaXMubWF4ID0gdC5tYXggfHwgMWU0KSwKICAgICAgICAgICh0aGlzLmZhY3RvciA9IHQuZmFjdG9yIHx8IDIpLAogICAgICAgICAgKHRoaXMuaml0dGVyID0gdC5qaXR0ZXIgPiAwICYmIHQuaml0dGVyIDw9IDEgPyB0LmppdHRlciA6IDApLAogICAgICAgICAgKHRoaXMuYXR0ZW1wdHMgPSAwKTsKICAgICAgfQogICAgICAodC5leHBvcnRzID0gbiksCiAgICAgICAgKG4ucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIHQgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7CiAgICAgICAgICBpZiAodGhpcy5qaXR0ZXIpIHsKICAgICAgICAgICAgdmFyIGUgPSBNYXRoLnJhbmRvbSgpLAogICAgICAgICAgICAgIG4gPSBNYXRoLmZsb29yKGUgKiB0aGlzLmppdHRlciAqIHQpOwogICAgICAgICAgICB0ID0gMCA9PSAoMSAmIE1hdGguZmxvb3IoMTAgKiBlKSkgPyB0IC0gbiA6IHQgKyBuOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAgfCBNYXRoLm1pbih0LCB0aGlzLm1heCk7CiAgICAgICAgfSksCiAgICAgICAgKG4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgdGhpcy5hdHRlbXB0cyA9IDA7CiAgICAgICAgfSksCiAgICAgICAgKG4ucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB0aGlzLm1zID0gdDsKICAgICAgICB9KSwKICAgICAgICAobi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIHRoaXMubWF4ID0gdDsKICAgICAgICB9KSwKICAgICAgICAobi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIHRoaXMuaml0dGVyID0gdDsKICAgICAgICB9KTsKICAgIH0sCiAgXSk7Cn0pOwovLyMgc291cmNlTWFwcGluZ1VSTD1zb2NrZXQuaW8ubWluLmpzLm1hcAo=";

// src/BlokdotsSocketIOServer/webserver/style.css
var style_default = "data:text/css;charset=utf-8;base64,LyogVmFyaWFibGVzICovCjpyb290IHsKICAvKiBmb250cyAqLwogIC0tZm9udC1mYW1pbHktcmVnOiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICJTZWdvZSBVSSIsIFJvYm90bywKICAgIE94eWdlbi1TYW5zLCBVYnVudHUsIENhbnRhcmVsbCwgIkhlbHZldGljYSBOZXVlIiwgc2Fucy1zZXJpZjsKICAtLWZvbnQtZmFtaWx5LW1vbm86ICJTRiBNb25vIiwgIlJvYm90byBNb25vIiwgIk1lbmxvIiwgbW9ub3NwYWNlOwoKICAtLWZvbnQtc2l6ZS1yZWc6IDE2cHg7CiAgLS1mb250LXNpemUtc21hbGw6IDEzcHg7CiAgLS1mb250LXNpemUtdGlueTogMTBweDsKCiAgLS1mb250LXdlaWdodC1tZWQ6IDUwMDsKICAtLWZvbnQtd2VpZ2h0LXJlZzogNDAwOwogIC0tZm9udC13ZWlnaHQtdGhpbjogMzAwOwoKICAvKiBTaXplcyAqLwogIC0tbWF4LXdpZHRoOiA2NDBweDsKCiAgLyogQ29sb3JzICovCgogIC0tY29sb3Itd2hpdGU6ICNmZmZmZmY7CiAgLS1jb2xvci1ibGFjazogIzAwMDAwMDsKCiAgLS1jb2xvci1mb250LXJlZzogdmFyKC0tY29sb3ItYmxhY2spOwogIC0tY29sb3ItZm9udC1tZWQ6ICM4MDgwODA7CiAgLS1jb2xvci1mb250LWRpczogI2IzYjNiMzsKCiAgLS1jb2xvci1ncmF5LTE6ICNmOGY4Zjg7CiAgLS1jb2xvci1ncmF5LTI6ICNmNWY1ZjU7CiAgLS1jb2xvci1ncmF5LTM6ICNmMmYyZjI7CiAgLS1jb2xvci1ncmF5LTQ6ICNmMGYwZjA7CiAgLS1jb2xvci1ncmF5LTU6ICNlYWVhZWE7CiAgLS1jb2xvci1ncmF5LTY6ICNkY2RjZGM7CiAgLS1jb2xvci1ncmF5LTc6ICNjMWMxYzE7CiAgLS1jb2xvci1ncmF5LTg6ICNhOGE4YTg7CiAgLS1jb2xvci1ncmF5LTk6ICM2MDYwNjA7CgogIC0tY29sb3ItYnJhbmQ6ICNmYmU5NDE7CiAgLS1jb2xvci1icmFuZC1tZWRpdW06ICNmYmQ4NDE7CiAgLS1jb2xvci1icmFuZC1kYXJrOiAjZjdjNTEwOwoKICAtLWNvbG9yLXJlZDogI2U3NGMzYzsKICAtLWNvbG9yLWdyZWVuOiAjMWFiYzljOwogIC0tY29sb3ItZ3JlZW4tZGFyazogIzE3YTM4NzsKICAtLWNvbG9yLWJsdWU6ICM1ZDliYzU7CiAgLS1jb2xvci12aW9sZXQ6ICM5ZjYzYjc7CiAgLS1jb2xvci1vcmFuZ2U6ICNmMzljMTI7CiAgLS1jb2xvci15ZWxsb3c6IHZhcigtLWNvbG9yLWJyYW5kLW1lZGl1bSk7CgogIC0tY29sb3ItYWxlcnQtaGlnaDogdmFyKC0tY29sb3ItcmVkKTsKICAtLWNvbG9yLWFsZXJ0LW1lZGl1bTogdmFyKC0tY29sb3Itb3JhbmdlKTsKICAtLWNvbG9yLWFsZXJ0LWxvdzogdmFyKC0tY29sb3IteWVsbG93KTsKCiAgLyogU2l6ZXMgKi8KCiAgLS1ib3JkZXItcmFkaXVzLXJlZzogMnB4OwogIC0td2luZG93cy1tZW51LWJhci1oZWlnaHQ6IDI4cHg7Cn0KCkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICA6cm9vdCB7CiAgICAtLWNvbG9yLXdoaXRlOiAjMzkzOTNhOwogICAgLS1jb2xvci1ibGFjazogI2ZmZmZmZjsKCiAgICAtLWNvbG9yLWdyYXktMTogIzQyNDI0MzsKICAgIC0tY29sb3ItZ3JheS0yOiAjNGQ0ZDRkOwogICAgLS1jb2xvci1ncmF5LTM6ICM4MDgwODA7CiAgICAtLWNvbG9yLWdyYXktNDogIzNkM2QzZTsKICAgIC0tY29sb3ItZ3JheS01OiAjMmQyZDJlOwogICAgLS1jb2xvci1ncmF5LTY6ICM1MDUwNTE7CiAgICAtLWNvbG9yLWdyYXktNzogIzU2NTY1NzsKICAgIC0tY29sb3ItZ3JheS04OiAjNmY2Zjc0OwogICAgLS1jb2xvci1ncmF5LTk6ICM3ODc4N2M7CgogICAgLS1jb2xvci1mb250LXJlZzogdmFyKC0tY29sb3ItYmxhY2spOwogICAgLS1jb2xvci1mb250LW1lZDogIzkwOTA5MDsKICAgIC0tY29sb3ItZm9udC1kaXM6IHZhcigtLWNvbG9yLWdyYXktNik7CiAgfQp9CgpAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHsKICA6cm9vdCB7CiAgICAtLW1heC13aWR0aDogMTAwdnc7CiAgfQp9CgovKiBSZXNldCAqLwpodG1sLApib2R5LApkaXYsCnNwYW4sCmFwcGxldCwKb2JqZWN0LAppZnJhbWUsCmgxLApoMiwKaDMsCmg0LApoNSwKaDYsCnAsCmEsCmltZywKb2wsCnVsLApsaSwKZmllbGRzZXQsCmZvcm0sCmxhYmVsLApsZWdlbmQsCnRhYmxlLApjYXB0aW9uLAp0Ym9keSwKdGZvb3QsCnRoZWFkLAp0ciwKdGgsCnRkIHsKICBib3JkZXI6IDA7CiAgb3V0bGluZTogMDsKICBmb250LXdlaWdodDogaW5oZXJpdDsKICBmb250LXN0eWxlOiBpbmhlcml0OwogIGZvbnQtc2l6ZTogMTAwJTsKICBmb250LWZhbWlseTogaW5oZXJpdDsKICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOmZvY3VzIHsKICBvdXRsaW5lOiAwOwp9Cm9sLAp1bCB7CiAgbGlzdC1zdHlsZTogbm9uZTsKfQp0YWJsZSB7CiAgYm9yZGVyLWNvbGxhcHNlOiBzZXBhcmF0ZTsKICBib3JkZXItc3BhY2luZzogMDsKfQpjYXB0aW9uLAp0aCwKdGQgewogIHRleHQtYWxpZ246IGxlZnQ7CiAgZm9udC13ZWlnaHQ6IDQwMDsKfQpibG9ja3F1b3RlOmJlZm9yZSwKYmxvY2txdW90ZTphZnRlciwKcTpiZWZvcmUsCnE6YWZ0ZXIgewogIGNvbnRlbnQ6ICIiOwp9Ci5jbGVhcmZpeDphZnRlciB7CiAgY29udGVudDogIi4iOwogIGRpc3BsYXk6IGJsb2NrOwogIGNsZWFyOiBib3RoOwogIHZpc2liaWxpdHk6IGhpZGRlbjsKICBsaW5lLWhlaWdodDogMDsKICBoZWlnaHQ6IDA7Cn0KLmNsZWFyZml4IHsKICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7Cn0KaHRtbFt4bWxuc10gLmNsZWFyZml4IHsKICBkaXNwbGF5OiBibG9jazsKfQoqIGh0bWwgLmNsZWFyZml4IHsKICBoZWlnaHQ6IDElOwp9Ci5jbGVhciB7CiAgY2xlYXI6IGJvdGg7CiAgaGVpZ2h0OiAwOwogIHdpZHRoOiAwOwogIG1hcmdpbjogMDsKICBwYWRkaW5nOiAwOwp9Ci5ubywKLmF1c2JsZW5kZW4gewogIGRpc3BsYXk6IG5vbmU7Cn0KaGVhZGVyLApzZWN0aW9uLApmb290ZXIsCmFzaWRlLApuYXYsCmFydGljbGUsCmZpZ3VyZSB7CiAgZGlzcGxheTogYmxvY2s7Cn0KCi8qIEFjdHVhbCBTdHlsZSAqLwoqIHsKICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgYm94LXNpemluZzogYm9yZGVyLWJveDsKfQoKaHRtbCwKYm9keSB7CiAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5LXJlZyk7CgogIGNvbG9yOiB2YXIoLS1jb2xvci1mb250LXJlZyk7CiAgYmFja2dyb3VuZDogdmFyKC0tY29sb3Itd2hpdGUpOwoKICBmb250LXNpemU6IHZhcigtLWZvbnQtc2l6ZS1yZWcpOwogIGxpbmUtaGVpZ2h0OiAxLjY7CiAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LXJlZyk7Cn0KCmgxIHsKICBmb250LXdlaWdodDogNTAwOwogIG1hcmdpbjogMXJlbSAwOwp9CgphIHsKICBjb2xvcjogdmFyKC0tY29sb3ItZ3JlZW4pOwp9CgpwICsgcCB7CiAgbWFyZ2luLXRvcDogOHB4Owp9Cgojd3JhcHBlciB7CiAgbWF4LXdpZHRoOiB2YXIoLS1tYXgtd2lkdGgpOwogIG1hcmdpbjogMCBhdXRvOwogIHBhZGRpbmc6IDIwcHg7Cn0KCiN0ZXN0SW5wdXQgewogIG1hcmdpbjogM3JlbSAwOwogIGRpc3BsYXk6IGZsZXg7CiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogIGdhcDogOHB4Owp9CiN0ZXN0SW5wdXQgbGFiZWwgewogIGRpc3BsYXk6IGZsZXg7CiAgZmxleDogMTsKICBhbGlnbi1pdGVtczogY2VudGVyOwp9CiN0ZXN0SW5wdXQgaW5wdXQsCmJ1dHRvbiB7CiAgb3V0bGluZTogbm9uZTsKICBib3JkZXI6IG5vbmU7CiAgYmFja2dyb3VuZDogbm9uZTsKICBib3JkZXItcmFkaXVzOiAwOwogIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseS1yZWcpOwogIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplLXJlZyk7CiAgY29sb3I6IHZhcigtLWNvbG9yLWZvbnQtcmVnKTsKfQojdGVzdElucHV0IGxhYmVsIHNwYW4gewogIGZsZXg6IDA7CiAgcGFkZGluZy1yaWdodDogM3B4Owp9CiN0ZXN0SW5wdXQgaW5wdXQgewogIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCB2YXIoLS1jb2xvci1ncmF5LTcpOwogIGZsZXg6IDE7Cn0KI3Rlc3RJbnB1dCBpbnB1dDo6cGxhY2Vob2xkZXIgewogIGNvbG9yOiB2YXIoLS1jb2xvci1mb250LWRpcyk7Cn0KI3Rlc3RJbnB1dCBidXR0b24gewogIGN1cnNvcjogcG9pbnRlcjsKICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1ncmVlbik7CiAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1yZWcpOwogIHBhZGRpbmc6IDAuM2VtIDAuNmVtOwogIGNvbG9yOiAjZmZmOwogIGZsZXgtZ3JvdzogMDsKfQpAbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHsKICAjdGVzdElucHV0IHsKICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgfQogICN0ZXN0SW5wdXQgbGFiZWwgewogICAgd2lkdGg6IDEwMCU7CiAgICBmbGV4OiAxOwogIH0KICAjdGVzdElucHV0IGJ1dHRvbiB7CiAgICB3aWR0aDogMTAwJTsKICAgIGZsZXgtZ3JvdzogMTsKICB9CiAgI3Rlc3RJbnB1dCBsYWJlbCBzcGFuIHsKICAgIGZsZXg6IDE7CiAgfQogICN0ZXN0SW5wdXQgbGFiZWwgaW5wdXQgewogICAgZmxleDogMzsKICB9Cn0KCiNzb2NrZXQtaGlzdG9yeSB7CiAgbWFyZ2luOiA0MHB4IDA7Cn0KI3NvY2tldC1oaXN0b3J5IGxpIHsKICB3aWR0aDogMTAwJTsKICBwYWRkaW5nOiA4cHggMDsKICBib3JkZXItdG9wOiBzb2xpZCAxcHggdmFyKC0tY29sb3ItZ3JheS02KTsKfQoKI3NlcnZlckFkZHJlc3MsCiNjb25uZWN0aW9uU3RhdHVzLAouY29kZSB7CiAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5LW1vbm8pOwogIGZvbnQtc2l6ZTogMC45ZW07CiAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItZ3JheS00KTsKICBwYWRkaW5nOiAycHggNHB4OwogIGJvcmRlci1yYWRpdXM6IDJweDsKICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7Cn0KCiNjb25uZWN0aW9uU3RhdHVzLm9rLAouY29kZS5vayB7CiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZ3JlZW4pOwogIGNvbG9yOiAjZmZmOwp9CgoubWVzc2FnZVRpbWUgewogIGNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTgpOwogIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseS1tb25vKTsKICBtYXJnaW4tcmlnaHQ6IDhweDsKfQoubWVzc2FnZUFycm93IHsKICBoZWlnaHQ6IDAuOGVtOwogIG1hcmdpbi1yaWdodDogOHB4Owp9Ci5tZXNzYWdlQ29udGVudERpc3BsYXkgewp9Ci5tZXNzYWdlVmFsdWVEaXNwbGF5OmJlZm9yZSB7CiAgY29udGVudDogIlsiOwogIGNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTgpOwp9Ci5tZXNzYWdlVmFsdWVEaXNwbGF5OmFmdGVyIHsKICBjb250ZW50OiAiXSI7CiAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktOCk7Cn0KLm1lc3NhZ2VWYWx1ZURpc3BsYXkgewogIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseS1tb25vKTsKICBjb2xvcjogdmFyKC0tY29sb3ItZ3JheS04KTsKICBtYXJnaW4tbGVmdDogOHB4Owp9Ci5tZXNzYWdlVmFsdWVEaXNwbGF5LWlzLW51bWJlciB7CiAgY29sb3I6IHZhcigtLWNvbG9yLXZpb2xldCk7Cn0K";

// src/BlokdotsSocketIOServer/setupHttpServer.js
var setupHttpServer = () => {
  const httpServer = import_http.default.createServer((req, res) => {
    const headers = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "OPTIONS, POST, GET",
      "Access-Control-Max-Age": 2592e3,
      "Cache-Control": "max-age=86400"
    };
    if (req.method === "OPTIONS") {
      res.writeHead(204, headers);
      res.end();
      return;
    }
    let file = null;
    switch (req.url) {
      case "/favicon.ico":
        headers["Content-Type"] = "image/x-icon";
        file = favicon_default;
        break;
      case "/style.css":
        headers["Content-Type"] = "text/css";
        file = style_default;
        break;
      case "/socket-io.min.js":
        headers["Content-Type"] = "text/javascript";
        file = socket_io_min_default;
        break;
      case "/log-arrow-out.svg":
        headers["Content-Type"] = "image/svg+xml";
        file = log_arrow_out_default;
        break;
      case "/log-arrow-in.svg":
        headers["Content-Type"] = "image/svg+xml";
        file = log_arrow_in_default;
        break;
      default:
        headers["Content-Type"] = "text/html";
        delete headers["Cache-Control"];
        file = webserver_default;
    }
    res.writeHead(200, headers);
    const buffer = Buffer.from(file.split(",")[1], "base64");
    const stream = new import_stream.Readable();
    stream.push(buffer);
    stream.push(null);
    stream.pipe(res);
  });
  return httpServer;
};
var setupHttpServer_default = setupHttpServer;

// src/BlokdotsSocketIOServer/BlokdotsSocketIOServer.ts
var BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT = 8777;
var getBlokdotsSocketIOServerAddress = () => {
  const currentIP = Object.values((0, import_os.networkInterfaces)()).flat().find((i) => i.family === "IPv4" && !i.internal).address;
  return `http://${currentIP}:${BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT}`;
};
var BlokdotsSocketIOServer = class {
  constructor() {
    this.activeIntegrations = {};
    this.io = null;
  }
  init() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        this.start();
        resolve();
      });
    });
  }
  start() {
    const httpServer = setupHttpServer_default();
    this.io = new Server(httpServer, {
      wsEngine: import_ws.default.Server,
      pingInterval: 5e3,
      pingTimeout: 5e3,
      allowEIO3: true,
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });
    httpServer.listen(BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT, "0.0.0.0");
    this.io.on("connection", (socket) => {
      socket.on("requestInfo", () => {
        this.emitInfo(socket);
      });
      this.emitInfo(socket);
    });
  }
  emitInfo(socket) {
    if (!socket)
      socket = this.io.sockets;
    socket.emit("info", {
      url: getBlokdotsSocketIOServerAddress(),
      integrations: Object.values(this.activeIntegrations).map((i) => ({
        id: i.id,
        url: i.url,
        connections: i.ioNamespace.sockets.size
      }))
    });
  }
  stop(callback) {
    this.io.closeServer(callback);
  }
  registerIntegration({
    integrationName,
    handlers = [],
    onClientConnect,
    onClientDisconnect
  }) {
    let integration = this.activeIntegrations[integrationName];
    if (integration) {
      integration.handlers = integration.handlers.concat(handlers);
      onClientConnect && integration.onClientConnect.push(onClientConnect);
      onClientDisconnect && integration.onClientDisconnect.push(onClientDisconnect);
      for (let [, socket] of integration.ioNamespace.sockets) {
        handlers.forEach(({ eventName, callback }) => {
          socket.on(eventName, callback);
        });
      }
    } else {
      this.activeIntegrations[integrationName] = {
        id: integrationName,
        url: `${getBlokdotsSocketIOServerAddress()}/${integrationName}`,
        handlers: [...handlers],
        ioNamespace: this.io.of("/" + integrationName),
        onClientConnect: onClientConnect ? [onClientConnect] : [],
        onClientDisconnect: onClientDisconnect ? [onClientDisconnect] : []
      };
      integration = this.activeIntegrations[integrationName];
      integration.ioNamespace.on("connection", (socket) => {
        integration.handlers.forEach(({ eventName, callback }) => {
          socket.on(eventName, callback);
        });
        integration.ioNamespace.emit("client-connect", {
          integration: integrationName,
          connections: integration.ioNamespace.sockets.size
        });
        integration.onClientConnect.forEach((h) => {
          h({
            integration: integrationName,
            connections: integration.ioNamespace.sockets.size
          });
        });
        this.emitInfo();
        socket.on("disconnect", (reason) => {
          integration.ioNamespace.emit("client-disconnect", {
            reason,
            integration: integrationName,
            connections: integration.ioNamespace.sockets.size
          });
          integration.onClientDisconnect.forEach((h) => {
            h({
              reason,
              integration: integrationName,
              connections: integration.ioNamespace.sockets.size
            });
          });
          this.emitInfo();
        });
      });
      this.emitInfo();
    }
    return __spreadProps(__spreadValues({}, integration), {
      connections: integration.ioNamespace.sockets.size
    });
  }
  unregisterIntegration({
    integrationName,
    handlers = [],
    onClientConnect,
    onClientDisconnect
  }) {
    let integration = this.activeIntegrations[integrationName];
    if (!integration) {
      return;
    }
    integration.handlers = integration.handlers.filter((h) => handlers.some((hU) => hU.eventName === h.eventName && hU.callback === h.callback));
    integration.onClientConnect = integration.onClientConnect.filter((h) => h !== onClientConnect);
    integration.onClientDisconnect = integration.onClientDisconnect.filter((h) => h !== onClientDisconnect);
    for (let [, socket] of integration.ioNamespace.sockets) {
      handlers.forEach(({ eventName, callback }) => {
        socket.off(eventName, callback);
      });
    }
    if (integration.handlers.length === 0) {
      integration.ioNamespace.disconnectSockets();
      delete this.activeIntegrations[integrationName];
      this.emitInfo();
    }
  }
};
var blokdotsSocketIOServer = null;
var getBlokdotsSocketIOServer = () => __async(void 0, null, function* () {
  return new Promise((resolve) => {
    if (blokdotsSocketIOServer === null) {
      blokdotsSocketIOServer = new BlokdotsSocketIOServer();
      blokdotsSocketIOServer.init().then(() => {
        resolve(blokdotsSocketIOServer);
      });
    } else {
      resolve(blokdotsSocketIOServer);
    }
  });
});
var BlokdotsSocketIOServer_default = getBlokdotsSocketIOServer;

// src/Counter/Counter.js
var import_events = __toModule(require("events"));
var Counter = class extends import_events.default {
  constructor(initialValue = 0) {
    super();
    this.value = initialValue;
  }
  countUp() {
    this.value++;
    this.emit("change", this.value);
  }
  countDown() {
    this.value--;
    this.emit("change", this.value);
  }
  setCountTo(value) {
    this.value = value;
    this.emit("change", this.value);
  }
};
var Counter_default = Counter;

// src/Encoder/Encoder.js
var import_events2 = __toModule(require("events"));
var import_johnny_five = __toModule(require_johnny_five());
var Encoder = class extends import_events2.default {
  constructor({ slot, board, initialValue = 0, debounce = 7 }) {
    super();
    this.value = initialValue;
    this.waveform = "";
    this.waveformTimeout;
    this.upButton = new import_johnny_five.default.Button({
      pin: slot,
      debounce,
      board
    });
    this.downButton = new import_johnny_five.default.Button({
      pin: slot + 1,
      debounce,
      board
    });
    this.upButton.on("up", () => {
      this.waveform += "1";
      this.handleWaveform();
    });
    this.downButton.on("up", () => {
      this.waveform += "0";
      this.handleWaveform();
    });
  }
  handleWaveform() {
    if (this.waveform.length < 2) {
      this.waveformTimeout = setTimeout(() => {
        this.waveform = "";
      }, 100);
      return;
    }
    if (this.waveformTimeout) {
      clearTimeout(this.waveformTimeout);
    }
    if (this.waveform === "01") {
      this.value = this.value + 1;
      this.emit("change", this.value);
      this.emit("up", this.value);
    } else if (this.waveform === "10") {
      this.value = this.value - 1;
      this.emit("change", this.value);
      this.emit("down", this.value);
    }
    this.waveform = "";
  }
  cleanUp() {
    if (this.upButton && this.upButton._events) {
      this.upButton.removeAllListeners();
    }
    if (this.downButton && this.downButton._events) {
      this.downButton.removeAllListeners();
    }
  }
};
var Encoder_default = Encoder;

// src/FigmaIntegration/FigmaIntegration.js
var EventEmitter3 = require("events");
var INTEGRATION_NAME = "figma";
var FigmaIntegration = class extends EventEmitter3 {
  constructor() {
    super();
    this.server = null;
    this.integration = null;
    BlokdotsSocketIOServer_default().then((server) => {
      this.server = server;
      this.integration = server.registerIntegration({
        integrationName: INTEGRATION_NAME
      });
    });
  }
  sendReaction(message, shouldUpdateState = true) {
    this.emit("reaction", message);
    this.integration.ioNamespace.emit("reaction", message);
    if (shouldUpdateState) {
      this.emit("updateState", message);
    }
  }
  cleanUp() {
    this.server.unregisterIntegration({
      integrationName: INTEGRATION_NAME
    });
  }
  rotate(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "rotate",
      parameters: { value: parameters.value, relation: parameters.relation },
      timestamp: Date.now()
    });
  }
  setText(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "setText",
      parameters: { string: parameters.string },
      timestamp: Date.now()
    });
  }
  setPosition(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "setPosition",
      parameters: {
        x: parameters.x,
        y: parameters.y,
        relation: parameters.relation
      },
      timestamp: Date.now()
    });
  }
  setOpacity(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "setOpacity",
      parameters: { value: parseFloat(parameters.value) / 100 },
      timestamp: Date.now()
    });
  }
  setSize(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "setSize",
      parameters: {
        width: parameters.width,
        height: parameters.height,
        relation: parameters.relation
      },
      timestamp: Date.now()
    });
  }
  setColor(parameters) {
    this.sendReaction({
      target: parameters.layer,
      reaction: "setColor",
      parameters: { value: parameters.value },
      timestamp: Date.now()
    });
  }
};
var FigmaIntegration_default = FigmaIntegration;

// src/HapticLabs/HapticLabs.js
var import_johnny_five2 = __toModule(require_johnny_five());
var HapticLabs = class {
  constructor({ slot, board, initialValue = 0 }) {
    this.value = initialValue;
    this.track1 = new import_johnny_five2.default.Pin({
      pin: slot,
      type: "digital",
      board
    });
    this.track2 = new import_johnny_five2.default.Pin({
      pin: slot + 1,
      type: "digital",
      board
    });
  }
};
var HapticLabs_default = HapticLabs;

// src/InvertableSensor/InvertableSensor.ts
var import_events3 = __toModule(require("events"));
var import_johnny_five3 = __toModule(require_johnny_five());
var InvertableSensor = class extends import_events3.default {
  constructor(_a) {
    var _b = _a, {
      invert = false,
      pin
    } = _b, componentProps = __objRest(_b, [
      "invert",
      "pin"
    ]);
    super();
    this.transformValue = (value) => {
      if (this.invert) {
        value = 1023 - value;
      }
      return value;
    };
    this.j5Object = new import_johnny_five3.default.Sensor(__spreadValues({ pin }, componentProps));
    this.invert = invert;
    this.j5Object.on("change", () => {
      this.emit("change", this.transformValue(this.j5Object.value));
    });
  }
  cleanUp() {
  }
};
var InvertableSensor_default = InvertableSensor;

// src/Joystick/Joystick.js
var import_events4 = __toModule(require("events"));
var import_johnny_five4 = __toModule(require_johnny_five());
var Joystick = class extends import_events4.default {
  constructor({ slot, board, invertX = false, invertY = false }) {
    super();
    __publicField(this, "transformValue", (value) => {
      let pressed = 0;
      let x = Math.round(value.x * 100);
      let y = Math.round(value.y * 100);
      x = import_johnny_five4.default.Fn.constrain(x, -50, 50);
      y = import_johnny_five4.default.Fn.constrain(y, -50, 50);
      if (this.invertX)
        x *= -1;
      if (this.invertY)
        y *= -1;
      if (value.x === 1) {
        pressed = true;
        x = this.previousX;
      } else {
        this.previousX = x;
      }
      return { x, y, pressed };
    });
    this.j5Object = new import_johnny_five4.default.Joystick({
      pins: [slot, `A${parseInt(slot.substring(1)) + 1}`],
      board
    });
    this.invertX = invertX;
    this.invertY = invertY;
    this.previousX;
    this.j5Object.on("change", (v) => {
      this.emit("change", this.transformValue(v));
    });
  }
  cleanUp() {
    if (this.j5Object && this.j5Object._events) {
      this.j5Object.removeAllListeners();
    }
  }
};
var Joystick_default = Joystick;

// src/Metronome/Metronome.js
var import_events5 = __toModule(require("events"));
var Metronome = class extends import_events5.default {
  constructor(frequency = 1e3) {
    super();
    this.frequency = frequency;
    this.interval = void 0;
  }
  start() {
    if (this.interval) {
      return;
    }
    this.emit("start", {
      timestamp: Date.now(),
      frequency: this.frequency
    });
    this.interval = setInterval(() => {
      this.emit("tick", {
        timestamp: Date.now(),
        frequency: this.frequency
      });
    }, this.frequency);
  }
  stop() {
    clearInterval(this.interval);
    this.interval = void 0;
    this.emit("stop");
  }
  setFrequency(frequency) {
    if (this.frequency !== frequency) {
      this.frequency = frequency;
      clearInterval(this.interval);
      this.interval = setInterval(() => {
        this.emit("tick", {
          timestamp: Date.now(),
          frequency: this.frequency
        });
      }, this.frequency);
    }
  }
};
var Metronome_default = Metronome;

// src/OLED/OLED.ts
var import_oled_font_5x7 = __toModule(require_oled_font_5x7());
var import_oled_js = __toModule(require_oled());
var import_qr_image = __toModule(require_qr2());
var OLED_WIDTH = 128;
var OLED_HEIGHT = 64;
var OLED = class extends import_oled_js.default {
  constructor({ board, five: five5 }) {
    super(board, five5, {
      width: 128,
      height: 64,
      address: 60,
      resetPin: null
    });
    this.previousBitmap = null;
    this.drawingIsBlocked = false;
    this.drawingBuffer = Array(OLED_WIDTH * OLED_HEIGHT).fill(null);
    this.clearDisplay = () => {
      this.drawBitmapOptimized(Array(OLED_WIDTH * OLED_HEIGHT).fill(0));
    };
  }
  drawString(string) {
    const buffer = addStringToBuffer(1, 1, string, 1);
    this.drawBitmapOptimized(buffer);
  }
  drawQRCodeNew(data, apply = true) {
    const buffer = addQrCodeToBuffer(1, 1, data, 4);
    if (apply) {
      this.drawBitmapOptimized(buffer);
    }
    return buffer;
  }
  drawValue(label, value, apply = true) {
    const buffer = addTextToBuffer([
      { x: 1, y: 1, string: label, size: 1 },
      { x: 1, y: 24, string: value, size: 2 }
    ]);
    if (apply) {
      this.drawBitmapOptimized(buffer);
    }
    return buffer;
  }
  drawBitmapOptimized(bitmap) {
    if (this.previousBitmap) {
      const updatePixels = [];
      for (let i = 0; i < bitmap.length; i++) {
        if (this.previousBitmap[i] !== bitmap[i]) {
          const [col, row] = indexToCoords(i);
          updatePixels.push([col, row, bitmap[i]]);
        }
      }
      this.updatePixelsBlocking(updatePixels);
      this.previousBitmap = bitmap;
    } else {
      this.drawBitmap(bitmap);
      this.previousBitmap = bitmap;
    }
  }
  updatePixelsBlocking(pixels) {
    if (this.drawingIsBlocked) {
      pixels.forEach(([col, row, color]) => {
        const index = coordsToIndex(col, row);
        this.drawingBuffer[index] = color;
      });
      return;
    }
    let blockingTime = 50 + 2e3 / 8096 * pixels.length;
    this.drawingIsBlocked = true;
    setTimeout(() => {
      this.drawingIsBlocked = false;
      const pixels2 = [];
      this.drawingBuffer.forEach((color, i) => {
        if (color !== null) {
          const [col, row] = indexToCoords(i);
          pixels2.push([col, row, color]);
        }
      });
      this.drawingBuffer = Array(OLED_WIDTH * OLED_HEIGHT).fill(null);
      if (pixels2.length > 0) {
        this.updatePixelsBlocking(pixels2);
      }
    }, blockingTime);
    this.drawPixel(pixels);
  }
};
var getClearBuffer = () => Array(OLED_WIDTH * OLED_HEIGHT).fill(0);
var addQrCodeToBuffer = (x, y, data, margin = 2, size = 2, buffer = getClearBuffer()) => {
  const matrix = import_qr_image.default.matrix(data);
  const pixels = matrix.flat();
  const width = Math.sqrt(pixels.length);
  for (let xi = x; xi < x + width * size + 2 * margin; xi++) {
    for (let yi = y; yi < y + width * size + 2 * margin; yi++) {
      const index = coordsToIndex(xi, yi);
      buffer[index] = 1;
    }
  }
  for (let i = 0; i < pixels.length; i++) {
    let px = Math.floor(i % width) * size;
    let py = Math.floor(i / width) * size;
    px += margin + x;
    py += margin + y;
    for (let xi = px; xi < px + size; xi++) {
      for (let yi = py; yi < py + size; yi++) {
        const index = coordsToIndex(xi, yi);
        buffer[index] = pixels[i] ? 0 : 1;
      }
    }
  }
  return buffer;
};
var addCharToBuffer = (x, y, byteArray, size, buffer = getClearBuffer()) => {
  for (let i = 0; i < byteArray.length; i += 1) {
    for (let j = 0; j < 8; j += 1) {
      const pixelState = byteArray[i][j];
      let xpos;
      let ypos;
      if (size === 1) {
        xpos = x + i;
        ypos = y + j;
        const index = coordsToIndex(xpos, ypos);
        buffer[index] = pixelState ? 1 : 0;
      } else {
        xpos = x + i * size;
        ypos = y + j * size;
        for (let xi = 0; xi < size; xi++) {
          for (let yi = 0; yi < size; yi++) {
            const index = coordsToIndex(xpos + xi, ypos + yi);
            buffer[index] = pixelState ? 1 : 0;
          }
        }
      }
    }
  }
  return buffer;
};
var findCharBuf = (c) => {
  let cBufPos = import_oled_font_5x7.default.lookup.indexOf(c) * import_oled_font_5x7.default.width;
  let cBuf = import_oled_font_5x7.default.fontData.slice(cBufPos, cBufPos + import_oled_font_5x7.default.width);
  return cBuf;
};
var readCharBytes = (byteArray, charHeight) => {
  let bitArr = [], bitCharArr = [];
  for (let i = 0; i < byteArray.length; i += 1) {
    let byte = byteArray[i];
    for (let j = 0; j < charHeight; j += 1) {
      let bit = byte >> j & 1;
      bitArr.push(bit);
    }
    bitCharArr.push(bitArr);
    bitArr = [];
  }
  return bitCharArr;
};
var LETTER_SPACING = 2;
var LINE_SPACING = 3;
var addStringToBuffer = (x, y, string, size = 1, buffer = getClearBuffer()) => {
  const charsPerRow = Math.floor((OLED_WIDTH - x) / (import_oled_font_5x7.default.width + LETTER_SPACING) * size);
  let wordArr = string.split(" ");
  let acc = "";
  while (wordArr.length > 0) {
    let word = wordArr[0];
    let hasLinebreak = false;
    if (word.includes("\n")) {
      const s = word.split("\n");
      hasLinebreak = true;
      word = s.shift();
      wordArr.splice(1, 0, s.join("\n"));
    }
    const wordLength = word.length;
    let charsTillEndOfRow = charsPerRow - acc.length % charsPerRow;
    if (wordLength + 1 > charsTillEndOfRow) {
      for (let j = 0; j < charsTillEndOfRow; j++) {
        acc += " ";
      }
    } else if (acc.length % charsPerRow !== 0) {
      word = " " + word;
    }
    acc += word;
    if (hasLinebreak && (word.length === 0 || acc.length % charsPerRow !== 0)) {
      charsTillEndOfRow = charsPerRow - acc.length % charsPerRow;
      for (let j = 0; j < charsTillEndOfRow; j++) {
        acc += " ";
      }
    }
    wordArr.shift();
  }
  acc.split("").forEach((char, char_index) => {
    const charBuf = findCharBuf(char);
    const bytes = readCharBytes(charBuf, import_oled_font_5x7.default.height);
    const lineY = Math.floor(char_index / charsPerRow);
    const charX = char_index - lineY * charsPerRow;
    let xpos = x + charX * ((import_oled_font_5x7.default.width + LETTER_SPACING) * size);
    let ypos = y + lineY * ((import_oled_font_5x7.default.height + LINE_SPACING) * size);
    buffer = addCharToBuffer(xpos, ypos, bytes, size, buffer);
  });
  return buffer;
};
var addTextToBuffer = (text, buffer = getClearBuffer()) => {
  text.forEach((t) => {
    buffer = addStringToBuffer(t.x, t.y, t.string, t.size, buffer);
  });
  return buffer;
};
var indexToCoords = (i) => {
  const row = Math.floor(i / OLED_WIDTH);
  const col = i - OLED_WIDTH * row;
  return [col, row];
};
var coordsToIndex = (col, row) => {
  return col + row * OLED_WIDTH;
};
var OLED_default = OLED;

// src/SignalTower/SignalTower.js
var import_events6 = __toModule(require("events"));
var SignalTower = class extends import_events6.default {
  constructor() {
    super();
    this.value = void 0;
  }
  send(message) {
    this.value = message;
    this.emit("send", this.value);
  }
};
var SignalTower_default = SignalTower;

// src/SocketIOIntegration/SocketIOIntegration.js
var EventEmitter8 = require("events");
var SocketIOIntegration = class extends EventEmitter8 {
  constructor(integrationName = "blokdots", messageEventName = "blokdots", format = { message: "msg", value: "val" }) {
    super();
    this.integrationName = integrationName;
    this.messageEventName = messageEventName;
    this.format = format;
    this.server = null;
    this.integration = null;
    this.onMessage = this.onMessage.bind(this);
    BlokdotsSocketIOServer_default().then((server) => {
      this.server = server;
      this.integration = server.registerIntegration({
        integrationName: this.integrationName,
        handlers: [
          {
            eventName: this.messageEventName,
            callback: this.onMessage
          }
        ]
      });
    });
  }
  onMessage(data) {
    const message = {
      message: data[this.format.message],
      value: data[this.format.value],
      direction: "in"
    };
    this.emit("received", message);
    this.emit("updateState", message);
  }
  send(message, shouldUpdateState = true) {
    if (!message.direction)
      message.direction = "out";
    this.emit("send", message);
    this.integration.ioNamespace.emit(this.messageEventName, {
      [this.format.message]: message.message,
      [this.format.value]: message.value
    });
    if (shouldUpdateState) {
      this.emit("updateState", message);
    }
  }
  cleanUp() {
    this.server.unregisterIntegration({
      integrationName: this.integrationName,
      handlers: [
        {
          eventName: this.messageEventName,
          callback: this.onMessage
        }
      ]
    });
  }
};
var SocketIOIntegration_default = SocketIOIntegration;

// src/Timer/Timer.js
var import_events7 = __toModule(require("events"));
var Timer = class extends import_events7.default {
  constructor(value = 0) {
    super();
    this.value = value;
    this.interval = void 0;
  }
  start() {
    if (this.interval) {
      return;
    }
    this.interval = setInterval(() => {
      this.value++;
      this.emit("change", this.value);
    }, 1e3);
    this.emit("start");
  }
  stop() {
    clearInterval(this.interval);
    this.interval = void 0;
    this.emit("stop");
  }
  reset() {
    this.value = 0;
    this.emit("change", this.value);
    this.emit("reset");
  }
  setTo(value) {
    this.value = value;
    this.emit("change", this.value);
  }
};
var Timer_default = Timer;

// src/utils.js
var utils = {
  rgbToHex: (r, g, b) => {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }
};
var utils_default = utils;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BLOKDOTS_SOCKET_IO_SERVER_DEFAULT_PORT,
  Counter,
  Encoder,
  FigmaIntegration,
  HapticLabs,
  InvertableSensor,
  Joystick,
  Metronome,
  OLED_HEIGHT,
  OLED_WIDTH,
  Oled,
  SignalTower,
  SocketIOIntegration,
  Timer,
  addTextToBuffer,
  getBlokdotsSocketIOServer,
  getBlokdotsSocketIOServerAddress,
  utils
});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * base64id v0.1.0
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! https://mths.be/utf8js v2.1.2 by @mathias */
